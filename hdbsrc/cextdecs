/* @ @ @ START COPYRIGHT @ @ @
** (C) Copyright 2018 Hewlett Packard Enterprise Development LP
** @@@ END COPYRIGHT @@@
**
** CExtdecs T9003ACQ (H01) - (22MAY2018): Common for TNS, TNS/R and TNS/E
**
*/



#define WHOLE_CEXTDECS_INCLUDED__

#pragma section abend
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status ABEND (
    short _ptr32 *,      /* IN OPTIONAL  */
                         /* processid to be abended */
    short ,              /* IN OPTIONAL  */
                         /* if true, abend backup */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* returned error value */
    short ,              /* IN OPTIONAL  */
                         /* completion code */
    short ,              /* IN OPTIONAL  */
                         /* termination info */
    short _ptr32 *,      /* IN OPTIONAL  */
                         /* subsystem ID */
    short ,              /* IN OPTIONAL  */
                         /* length of text in bytes */
    const char _ptr32 *  /* IN OPTIONAL  */
                         /* text */
    );
#else
_tal _extensible _cc_status ABEND (
    short _near *,      /* IN OPTIONAL  */
                        /* processid to be abended */
    short ,             /* IN OPTIONAL  */
                        /* if true, abend backup */
    short _near *,      /* OUT OPTIONAL  */
                        /* returned error value */
    short ,             /* IN OPTIONAL  */
                        /* completion code */
    short ,             /* IN OPTIONAL  */
                        /* termination info */
    short _far *,       /* IN OPTIONAL  */
                        /* subsystem ID */
    short ,             /* IN OPTIONAL  */
                        /* length of text in bytes */
    const char _far *   /* IN OPTIONAL  */
                        /* text */
    );
 #endif

#pragma section aborttransaction
_tal short ABORTTRANSACTION (
    void);

#pragma section activateprocess
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status ACTIVATEPROCESS (
    short _ptr32 *       /* IN  */
                         /* PROCESSID TO BE ACTIVATED */
    );
#else
_tal _cc_status ACTIVATEPROCESS (
    short _near *       /* IN  */
                        /* PROCESSID TO BE ACTIVATED */
    );
#endif

#pragma section activatereceivetransid
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status ACTIVATERECEIVETRANSID (
    short               /* IN  */
    );

#pragma section adddsttransition
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status ADDDSTTRANSITION (
    long long ,         /* IN  */
    long long ,         /* IN  */
    short               /* IN  */
    );


#pragma section address_delimit_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short ADDRESS_DELIMIT_ (
    __int32_t ,          /* IN  */
                         /* extended address in area to be checked */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* extended address of first byte of area */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* extended address of last byte of area */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* type of area QADDR is part of */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* segment id of area */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* detail info, if non-zero error is returned */
    );
#else
_tal _extensible short ADDRESS_DELIMIT_ (
    __int32_t ,         /* IN  */
                        /* extended address in area to be checked */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* extended address of first byte of area */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* extended address of last byte of area */
    short _far *,       /* OUT OPTIONAL  */
                        /* type of area QADDR is part of */
    short _far *,       /* OUT OPTIONAL  */
                        /* segment id of area */
    short _far *        /* OUT OPTIONAL  */
                        /* detail info, if non-zero error is returned */
    );
#endif

#pragma section address_delimit64_
#if _TANDEM_ARCH_ >= 2
#ifdef __cplusplus
extern "C" {
#endif
_extensible _resident _callable short
ADDRESS_DELIMIT64_(
   void _ptr64 *           /*qaddr*/,
   void _ptr64 * _ptr64 *  /*low_addr*/,
   void _ptr64 * _ptr64 *  /*hi_addr*/,
   short _ptr64 *          /*addr_type*/,
   short _ptr64 *          /*seg_id*/,
   short _ptr64 *          /*err_detail*/);
#ifdef __cplusplus
 }
#endif
#endif

#pragma section addrtoprocname
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short ADDRTOPROCNAME (
    short ,             /* IN  */
                        /* P-register value to translate. */
    short ,             /* IN  */
                        /* E-register, stack, setting for PVAL. */
    char _ptr32 *,      /* OUT  */
                        /* Symbolic procedure name for PVAL. */
    short ,             /* IN  */
                        /* Length of user buffer. */
    short _ptr32 *,     /* OUT  */
                        /* Number of bytes returned in NAME. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* Base word address of procedure. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* Size of procedure in words. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* Entry word address to procedure. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* Attributes of procedure. */
    short               /* IN OPTIONAL  */
                        /* Pin for PVAL. */
    );
#else
_tal _extensible short ADDRTOPROCNAME (
    short ,             /* IN  */
                        /* P-register value to translate. */
    short ,             /* IN  */
                        /* E-register, stack, setting for PVAL. */
    char _far *,        /* OUT  */
                        /* Symbolic procedure name for PVAL. */
    short ,             /* IN  */
                        /* Length of user buffer. */
    short _far *,       /* OUT  */
                        /* Number of bytes returned in NAME. */
    short _far *,       /* OUT OPTIONAL  */
                        /* Base word address of procedure. */
    short _far *,       /* OUT OPTIONAL  */
                        /* Size of procedure in words. */
    short _far *,       /* OUT OPTIONAL  */
                        /* Entry word address to procedure. */
    short _far *,       /* OUT OPTIONAL  */
                        /* Attributes of procedure. */
    short               /* IN OPTIONAL  */
                        /* Pin for PVAL. */
    );
 #endif

#pragma section allocatesegment
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short ALLOCATESEGMENT (
    short ,             /* IN  */
    __int32_t ,         /* IN OPTIONAL  */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#else
_tal _variable short ALLOCATESEGMENT (
    short ,             /* IN  */
    __int32_t ,         /* IN OPTIONAL  */
    short _near *,      /* IN/OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section alter
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status ALTER (
    short _ptr32 *,     /* IN  */
    short ,             /* IN  */
    short _ptr32 *,     /* IN  */
    short               /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status ALTER (
    short _near *,      /* IN  */
    short ,             /* IN  */
    short _near *,      /* IN  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section alterpriority
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status ALTERPRIORITY (
    short _ptr32 *,      /* IN  */
    short                /* IN  */
    );
#else
_tal _cc_status ALTERPRIORITY (
    short _near *,      /* IN  */
    short               /* IN  */
    );
#endif

#pragma section aps_activity_discardreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_DISCARDREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN OPTIONAL  */
                        /* REASON FOR THE DISCARD REQUEST PRIMITIVE */
                        /* ONE OF THE ZAPS-VAL-ACT-... VALUES. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#else
_tal _extensible short APS_ACTIVITY_DISCARDREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN OPTIONAL  */
                        /* REASON FOR THE DISCARD REQUEST PRIMITIVE */
                        /* ONE OF THE ZAPS-VAL-ACT-... VALUES. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#endif

#pragma section aps_activity_discardrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_DISCARDRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_ACTIVITY_DISCARDRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_activity_endreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_ENDREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS) */
    );
#else
_tal _extensible short APS_ACTIVITY_ENDREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS) */
    );
#endif

#pragma section aps_activity_endrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_ENDRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_ACTIVITY_ENDRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_activity_getparam_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_GETPARAM_ (
    short ,               /* IN  */
                          /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* IDENTIFIER OF THE CURRENT ACTIVITY */
                          /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* REASON FOR THE ACTIVITY INTERRUPT/DISCARD */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* THE SYNCHRONISATION POINT SERIAL NUMBER */
                          /* OF AN S-ACTIVITY-END OR S-ACTIVITY-RESUME */
                          /* INDICATION, OR A COMPLETED S-ACTIVITY-END */
                          /* REQUEST PRIMITIVE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* L5 (SESSION) CONNECTION IDENTIFIER */
                          /* ( ZAPS-DDL-L5-CONID ) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /* IDENTIFIER OF INTERRUPTED ACTIVITY */
    );
#else
_tal _extensible short APS_ACTIVITY_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* OUT OPTIONAL  */
                        /* IDENTIFIER OF THE CURRENT ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* REASON FOR THE ACTIVITY INTERRUPT/DISCARD */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* THE SYNCHRONISATION POINT SERIAL NUMBER */
                        /* OF AN S-ACTIVITY-END OR S-ACTIVITY-RESUME */
                        /* INDICATION, OR A COMPLETED S-ACTIVITY-END */
                        /* REQUEST PRIMITIVE */
    short _far *,       /* OUT OPTIONAL  */
                        /* L5 (SESSION) CONNECTION IDENTIFIER */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _far *        /* OUT OPTIONAL  */
                        /* IDENTIFIER OF INTERRUPTED ACTIVITY */
    );
#endif

#pragma section aps_activity_interruptreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_INTERRUPTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN OPTIONAL  */
                        /* REASON FOR THE INTERRUPT REQUEST PRIMITIVE */
                        /* ONE OF THE ZAPS-VAL-ACT-... VALUES */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#else
_tal _extensible short APS_ACTIVITY_INTERRUPTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN OPTIONAL  */
                        /* REASON FOR THE INTERRUPT REQUEST PRIMITIVE */
                        /* ONE OF THE ZAPS-VAL-ACT-... VALUES */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#endif

#pragma section aps_activity_interruptrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_INTERRUPTRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_ACTIVITY_INTERRUPTRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_activity_resumereq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_RESUMEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* IDENTIFIER OF THE ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _ptr32 *,     /* IN  */
                        /* IDENTIFIER OF INTERRUPTED ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    __int32_t ,         /* IN  */
                        /* NEW SYNCHRONISATION POINT SERIAL NUMBER */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* IDENTIFIER OF THE CONNECTION ON WHICH THE */
                        /* ACTIVITY WAS ORIGINALLY STARTED */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOEKNS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_ACTIVITY_RESUMEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* IDENTIFIER OF THE ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _far *,       /* IN  */
                        /* IDENTIFIER OF INTERRUPTED ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    __int32_t ,         /* IN  */
                        /* NEW SYNCHRONISATION POINT SERIAL NUMBER */
    short _far *,       /* IN OPTIONAL  */
                        /* IDENTIFIER OF THE CONNECTION ON WHICH THE */
                        /* ACTIVITY WAS ORIGINALLY STARTED */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOEKNS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_activity_startreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ACTIVITY_STARTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* IDENTIFIER OF THE ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_ACTIVITY_STARTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* IDENTIFIER OF THE ACTIVITY */
                        /* ( ZAPS-DDL-ACTIVITY-ID ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_assoc_abortreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_ABORTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#else
_tal _extensible short APS_ASSOC_ABORTREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#endif

#pragma section aps_assoc_attach_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_ATTACH_ (
    short _ptr32 *,     /* OUT  */
                        /* CEPI GENERATED AND RETURNED BY APS. THIS */
                        /* IS THE MEANS BY WHICH THE USER REFERENCES */
                        /* THE CONNECTION IN OTHER APS CALLS. */
    short _ptr32 *,     /* IN  */
                        /* DEFINES THE OSI END-SYSTEM NAME, AND THE */
                        /* WAIT MODE OF THE CONNECTION. */
                        /* ( ZAPS-DDL-ENVIRONMENT ) */
    short _ptr32 *,     /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS */
                        /* OF THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SERVICE TO BE USED */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SUBDEVICE TO BE CREATED OR REUSED. */
                        /* ( ZAPS-DDL-FILENAME ) */
    short               /* IN OPTIONAL  */
    );
#else
_tal _extensible short APS_ASSOC_ATTACH_ (
    short _far *,       /* OUT  */
                        /* CEPI GENERATED AND RETURNED BY APS. THIS */
                        /* IS THE MEANS BY WHICH THE USER REFERENCES */
                        /* THE CONNECTION IN OTHER APS CALLS. */
    short _far *,       /* IN  */
                        /* DEFINES THE OSI END-SYSTEM NAME, AND THE */
                        /* WAIT MODE OF THE CONNECTION. */
                        /* ( ZAPS-DDL-ENVIRONMENT ) */
    short _far *,       /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS */
                        /* OF THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SERVICE TO BE USED */
    short _far *,       /* IN OPTIONAL  */
                        /* SUBDEVICE TO BE CREATED OR REUSED. */
                        /* ( ZAPS-DDL-FILENAME ) */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section aps_assoc_connectreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_CONNECTREQ_ (
    short _ptr32 *,     /* OUT  */
                        /* CEPI GENERATED AND RETURNED BY APS. THIS */
                        /* IS THE MEANS BY WHICH THE USER REFERENCES */
                        /* THE CONNECTION IN OTHER APS CALLS. */
    short _ptr32 *,     /* IN  */
                        /* DEFINES THE OSI END-SYSTEM NAME, AND THE */
                        /* WAIT MODE OF THE CONNECTION. */
                        /* ( ZAPS-DDL-APS-ENVIRON ) */
    short _ptr32 *,     /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _ptr32 *,     /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE REMOTE APPLICATION ENTITY (THIS IS THE */
                        /* RECIPIENT OF THE S-CONNECT.REQ PRIMITIVE). */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _ptr32 *,     /* IN  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. (ZAPS-DDL-SRV-RQMNTS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SERVICE TO BE USED, SESSION DEFAULT */
    short ,             /* IN OPTIONAL  */
                        /* MODE TO BE USED FOR PRES & ACSE */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* ( ZAPS-DDL-PRES-CNTXT-LIST ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT NAME */
                        /* ( ZAPS-DDL-PRES-DEFLT-CNTXT ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* ( ZAPS-DDL-APPL-CNTXT ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* ( ZAPS-DDL-AE-TITLE ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* REMOTE APPLICATION ENTITY TITLE */
                        /* ( ZAPS-DDL-AE-TITLE ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* ( ZAPS-DDL-INVOCATION-IDS ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* REMOTE INVOCATION IDS */
                        /* ( ZAPS-DDL-INVOCATION-IDS ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SUBDEVICE TO BE CREATED OR REUSED. */
                        /* ( ZAPS-DDL-FILENAME ) */
    short               /* IN OPTIONAL  */
);
#else
_tal _extensible short APS_ASSOC_CONNECTREQ_ (
    short _far *,       /* OUT  */
                        /* CEPI GENERATED AND RETURNED BY APS. THIS */
                        /* IS THE MEANS BY WHICH THE USER REFERENCES */
                        /* THE CONNECTION IN OTHER APS CALLS. */
    short _far *,       /* IN  */
                        /* DEFINES THE OSI END-SYSTEM NAME, AND THE */
                        /* WAIT MODE OF THE CONNECTION. */
                        /* ( ZAPS-DDL-APS-ENVIRON ) */
    short _far *,       /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _far *,       /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE REMOTE APPLICATION ENTITY (THIS IS THE */
                        /* RECIPIENT OF THE S-CONNECT.REQ PRIMITIVE). */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _far *,       /* IN  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. (ZAPS-DDL-SRV-RQMNTS) */
    short _far *,       /* IN OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SERVICE TO BE USED, SESSION DEFAULT */
    short ,             /* IN OPTIONAL  */
                        /* MODE TO BE USED FOR PRES & ACSE */
    short _far *,       /* IN OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* ( ZAPS-DDL-PRES-CNTXT-LIST ) */
    short _far *,       /* IN OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT NAME */
                        /* ( ZAPS-DDL-PRES-DEFLT-CNTXT ) */
    short _far *,       /* IN OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* ( ZAPS-DDL-APPL-CNTXT ) */
    short _far *,       /* IN OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* ( ZAPS-DDL-AE-TITLE ) */
    short _far *,       /* IN OPTIONAL  */
                        /* REMOTE APPLICATION ENTITY TITLE */
                        /* ( ZAPS-DDL-AE-TITLE ) */
    short _far *,       /* IN OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* ( ZAPS-DDL-INVOCATION-IDS ) */
    short _far *,       /* IN OPTIONAL  */
                        /* REMOTE INVOCATION IDS */
                        /* ( ZAPS-DDL-INVOCATION-IDS ) */
    short _far *,       /* IN OPTIONAL  */
                        /* SUBDEVICE TO BE CREATED OR REUSED. */
                        /* ( ZAPS-DDL-FILENAME ) */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section aps_assoc_connectrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_CONNECTRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS */
                        /* OF THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short ,             /* IN  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* ESTABLISHMENT ATTEMPT. */
    short _ptr32 *,     /* IN  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. (ZAPS-DDL-SRV-RQMNTS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-RLIST) */
    short ,             /* IN OPTIONAL  */
                        /* INDICATES THE RESULT OF */
                        /* THE CONTEXT LIST */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* (ZAPS-DDL-APPL-CNTXT) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short               /* IN OPTIONAL  */
                        /* USER DIAGNOSTIC WHEN CONNECTION */
                        /* IS REJECTED. */
    );
#else
_tal _extensible short APS_ASSOC_CONNECTRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS */
                        /* OF THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short ,             /* IN  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* ESTABLISHMENT ATTEMPT. */
    short _far *,       /* IN  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. (ZAPS-DDL-SRV-RQMNTS) */
    short _far *,       /* IN OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *,       /* IN OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-RLIST) */
    short ,             /* IN OPTIONAL  */
                        /* INDICATES THE RESULT OF */
                        /* THE CONTEXT LIST */
    short _far *,       /* IN OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* (ZAPS-DDL-APPL-CNTXT) */
    short _far *,       /* IN OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* IN OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short               /* IN OPTIONAL  */
                        /* USER DIAGNOSTIC WHEN CONNECTION */
                        /* IS REJECTED. */
    );
#endif

#pragma section aps_assoc_getparam_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE REMOTE APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* ESTABLISHMENT ATTEMPT. */
    short _ptr32 *,     /* OUT  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. THESE ARE RETURNED */
                        /* FROM THE RESPONDING APPLICATION ENTITY. */
                        /* ( ZAPS-DDL-SRV-RQMNTS ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* INDICATES THE RESULT OF THE CONNECTION ON */
                        /* RELEASE ATTEMPT. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* INDICATES THE REASON FOR */
                        /* THE ABORT INDICATION */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* MODE TO BE USED FOR PRES & ACSE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-LIST) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRESENTATION CONTEXT RESULT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-RLIST) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT NAME */
                        /* (ZAPS-DDL-PRES-DEFLT-CNTXT) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT RSLT */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* (ZAPS-DDL-APPL-CNTXT) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* REMOTE APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* REMOTE INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* RESULT SOURCE OF CONNECT CONFIRM */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DIAGNOSTIC OF CONNECT CONFIRM */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* RELEASE REASON OF RELEASE IND, CNF */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* SOURCE OF ABORT */
    );
#else
_tal _extensible short APS_ASSOC_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* OUT OPTIONAL  */
                        /* SESSION CONNECTION IDENTIFIER. */
                        /* ( ZAPS-DDL-L5-CONID ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE LOCAL APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* APPLICATION TITLE AND/OR THE OSI ADDRESS OF */
                        /* THE REMOTE APPLICATION ENTITY */
                        /* ( ZAPS-DDL-APPL-ADDR ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* ESTABLISHMENT ATTEMPT. */
    short _far *,       /* OUT  */
                        /* SPECIFICATION OF THE SERVICE REQUIREMENTS */
                        /* FOR THIS CONNECTION. THESE ARE RETURNED */
                        /* FROM THE RESPONDING APPLICATION ENTITY. */
                        /* ( ZAPS-DDL-SRV-RQMNTS ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* INDICATES THE RESULT OF THE CONNECTION ON */
                        /* RELEASE ATTEMPT. */
    short _far *,       /* OUT OPTIONAL  */
                        /* INDICATES THE REASON FOR */
                        /* THE ABORT INDICATION */
    short _far *,       /* OUT OPTIONAL  */
                        /* MODE TO BE USED FOR PRES & ACSE */
    short _far *,       /* OUT OPTIONAL  */
                        /* PRESENTATION CONTEXT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-LIST) */
    short _far *,       /* OUT OPTIONAL  */
                        /* PRESENTATION CONTEXT RESULT LIST */
                        /* (ZAPS-DDL-PRES-CNTXT-RLIST) */
    short _far *,       /* OUT OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT NAME */
                        /* (ZAPS-DDL-PRES-DEFLT-CNTXT) */
    short _far *,       /* OUT OPTIONAL  */
                        /* PRESENTATION DEFAULT CONTEXT RSLT */
    short _far *,       /* OUT OPTIONAL  */
                        /* APPLICATION CONTEXT NAME */
                        /* (ZAPS-DDL-APPL-CNTXT) */
    short _far *,       /* OUT OPTIONAL  */
                        /* LOCAL APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* OUT OPTIONAL  */
                        /* REMOTE APPLICATION ENTITY TITLE */
                        /* (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* OUT OPTIONAL  */
                        /* LOCAL INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short _far *,       /* OUT OPTIONAL  */
                        /* REMOTE INVOCATION IDS */
                        /* (ZAPS-DDL-INVOCATION-IDS) */
    short _far *,       /* OUT OPTIONAL  */
                        /* RESULT SOURCE OF CONNECT CONFIRM */
    short _far *,       /* OUT OPTIONAL  */
                        /* DIAGNOSTIC OF CONNECT CONFIRM */
    short _far *,       /* OUT OPTIONAL  */
                        /* RELEASE REASON OF RELEASE IND, CNF */
    short _far *        /* OUT OPTIONAL  */
                        /* SOURCE OF ABORT */
    );
#endif

#pragma section aps_assoc_releasereq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_RELEASEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short               /* IN OPTIONAL  */
                        /* ACSE parameter */
    );
#else
_tal _extensible short APS_ASSOC_RELEASEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short               /* IN OPTIONAL  */
                        /* ACSE parameter */
    );
#endif

#pragma section aps_assoc_releasersp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_ASSOC_RELEASERSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* RELEASE ATTEMPT.  THIS VALUE INDICATES */
                        /* WHETHER THE LOCAL USER AGREES TO RELEASE */
                        /* THE CONNECTION. (ZAPS-VAL-RLS-...) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short               /* IN OPTIONAL  */
                        /* ACSE parameter */
    );
#else
_tal _extensible short APS_ASSOC_RELEASERSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* INDICATES THE RESULT OF THE CONNECTION */
                        /* RELEASE ATTEMPT.  THIS VALUE INDICATES */
                        /* WHETHER THE LOCAL USER AGREES TO RELEASE */
                        /* THE CONNECTION. (ZAPS-VAL-RLS-...) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short               /* IN OPTIONAL  */
                        /* ACSE parameter */
    );
#endif

#pragma section aps_capdata_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_CAPDATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#else
_tal _extensible short APS_CAPDATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#endif

#pragma section aps_capdata_rsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_CAPDATA_RSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_CAPDATA_RSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_control_givereq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_CONTROL_GIVEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#else
_tal _extensible short APS_CONTROL_GIVEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#endif

#pragma section aps_data_getparam_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_DATA_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SIZE (BYTES) OF BUFFER.  A VALUE OF 0D */
                        /* INDICATES THAT NO DATA ARE TO BE RETURNED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* BUFFER INTO WHICH THE RECEIVED DATA ARE TO */
                        /* BE COPIED.  THIS PARAMETER MUST BE SUPPLIED */
                        /* IF BUFFER^SIZE IS GREATER THAN 0D. */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /* SIZE (BYTES) OF REMAINING DATA INCLUDING */
                        /* ALL NECESSARY HEADERS.  A VALUE OF 0D */
                        /* INDICATES THAT NO DATA ARE REMAINING. */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /* OFFSET (BYTES) OF THE NEXT DATA BYTE TO BE */
                        /* RETURNED FROM THE APS INTERNAL DATA AREA. */
                        /* THIS VALUE REFERS TO USER DATA */
                        /* (I.E. EXCLUDING HEADERS). IF THERE ARE NO */
                        /* MORE DATA TO BE RETURNED, THE VALUE -1D */
                        /* IS RETURNED. */
    __int32_t           /* IN OPTIONAL  */
                        /* SPECIFIES THE OFFSET (BYTES) OF THE FIRST */
                        /* DATA BYTE TO BE RETURNED. THIS VALUE */
                        /* REFERS TO  USER DATA (I.E. EXCLUDING */
                        /* HEADERS). */
    );
#else
_tal _extensible short APS_DATA_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SIZE (BYTES) OF BUFFER.  A VALUE OF 0D */
                        /* INDICATES THAT NO DATA ARE TO BE RETURNED */
    short _far *,       /* OUT OPTIONAL  */
                        /* BUFFER INTO WHICH THE RECEIVED DATA ARE TO */
                        /* BE COPIED.  THIS PARAMETER MUST BE SUPPLIED */
                        /* IF BUFFER^SIZE IS GREATER THAN 0D. */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* SIZE (BYTES) OF REMAINING DATA INCLUDING */
                        /* ALL NECESSARY HEADERS.  A VALUE OF 0D */
                        /* INDICATES THAT NO DATA ARE REMAINING. */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* OFFSET (BYTES) OF THE NEXT DATA BYTE TO BE */
                        /* RETURNED FROM THE APS INTERNAL DATA AREA. */
                        /* THIS VALUE REFERS TO USER DATA */
                        /* (I.E. EXCLUDING HEADERS). IF THERE ARE NO */
                        /* MORE DATA TO BE RETURNED, THE VALUE -1D */
                        /* IS RETURNED. */
    __int32_t           /* IN OPTIONAL  */
                        /* SPECIFIES THE OFFSET (BYTES) OF THE FIRST */
                        /* DATA BYTE TO BE RETURNED. THIS VALUE */
                        /* REFERS TO  USER DATA (I.E. EXCLUDING */
                        /* HEADERS). */
    );
#endif

#pragma section aps_data_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_DATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SEND OPERATION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    short               /* IN OPTIONAL  */
                        /* AMOUNT OF DATA TO SEND PER BLOCK */
    );
#else
_tal _extensible short APS_DATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SEND OPERATION */
    short _far *,       /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    short               /* IN OPTIONAL  */
                        /* AMOUNT OF DATA TO SEND PER BLOCK */
    );
#endif

#pragma section aps_discard_
_tal _extensible short APS_DISCARD_ (
    short               /* IN  */
                        /* CEPI OF THE CONNECTION TO BE DISCARDED */
    );

#pragma section aps_event_receive_
#include <tnsint.h>
_tal _extensible short APS_EVENT_RECEIVE_ (
    short ,             /* IN  */
                        /* CEPI ON WHICH TO RECEIVE AN EVENT */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TIME TO WAIT FOR AN EVENT TO OCCUR */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TAG FOR THIS REQUEST (FOR NOWAIT) */
    short               /* IN OPTIONAL  */
                        /* AMOUNT OF DATA TO SEND PER BLOCK */
    );

#pragma section aps_exceptionreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_EXCEPTIONREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* SPECIFIES THE REASON FOR THE EXCEPTION. */
                        /* ONE OF THE ZAPS-VAL-EXC... VALUES. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_EXCEPTIONREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* SPECIFIES THE REASON FOR THE EXCEPTION. */
                        /* ONE OF THE ZAPS-VAL-EXC... VALUES. */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_get_dteaddr_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_GET_DTEADDR_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *      /* OUT  */
                        /* DTE ADDRESS OF THE REMOTE APPLICATION */
                        /* ( ZAPS-DDL-L5-DTE-ADDR ) */
    );
#else
_tal _extensible short APS_GET_DTEADDR_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *        /* OUT  */
                        /* DTE ADDRESS OF THE REMOTE APPLICATION */
                        /* ( ZAPS-DDL-L5-DTE-ADDR ) */
    );
#endif

#pragma section aps_initialize_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_INITIALIZE_ (
    short _ptr32 *        /* IN OPTIONAL  */
                          /* SWAP VOLUME TO USE FOR THE APS SEGMENT */
    );
#else
_tal _extensible short APS_INITIALIZE_ (
    short _far *        /* IN OPTIONAL  */
                        /* SWAP VOLUME TO USE FOR THE APS SEGMENT */
    );
#endif

#pragma section aps_objid_compress_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_OBJID_COMPRESS_ (
    short _ptr32 *,       /* IN  */
                          /*  (ZAPS-DDL-OBJ-ID-32) */
    short _ptr32 *        /* OUT  */
                          /*  (ZAPS-DDL-OBJ-ID) */
    );
#else
_tal _extensible short APS_OBJID_COMPRESS_ (
    short _far *,       /* IN  */
                        /*  (ZAPS-DDL-OBJ-ID-32) */
    short _far *        /* OUT  */
                        /*  (ZAPS-DDL-OBJ-ID) */
    );
#endif

#pragma section aps_objid_expand_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_OBJID_EXPAND_ (
    short _ptr32 *,       /* IN  */
                          /*  (ZAPS-DDL-OBJ-ID) */
    short _ptr32 *        /* OUT  */
                          /*  (ZAPS-DDL-OBJ-ID-32) */
    );
#else
_tal _extensible short APS_OBJID_EXPAND_ (
    short _far *,       /* IN  */
                        /*  (ZAPS-DDL-OBJ-ID) */
    short _far *        /* OUT  */
                        /*  (ZAPS-DDL-OBJ-ID-32) */
    );
#endif

#pragma section aps_resyncreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_RESYNCREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* SPECIFIES THE TYPE OF RESYNCHRONISATION */
                        /* ONE OF THE ZAPS-VAL-RESYNC-... LITERALS */
                        /* (EXCEPT ZAPS-VAL-RESYNC-NOVALUE). */
    __int32_t ,         /* IN OPTIONAL  */
                        /* SPECIFIES A PAST SYNCHRONISATION SERIAL */
                        /* NUMBER TO WHICH RESYNCHRONISATION IS TO */
                        /* BE ATTEMPTED. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SPECIFIES THE AVAILABILITY AND OWNERSHIP OF */
                        /* TOKENS FOR THE CONNECTION. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#else
_tal _extensible short APS_RESYNCREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* SPECIFIES THE TYPE OF RESYNCHRONISATION */
                        /* ONE OF THE ZAPS-VAL-RESYNC-... LITERALS */
                        /* (EXCEPT ZAPS-VAL-RESYNC-NOVALUE). */
    __int32_t ,         /* IN OPTIONAL  */
                        /* SPECIFIES A PAST SYNCHRONISATION SERIAL */
                        /* NUMBER TO WHICH RESYNCHRONISATION IS TO */
                        /* BE ATTEMPTED. */
    short _far *,       /* IN OPTIONAL  */
                        /* SPECIFIES THE AVAILABILITY AND OWNERSHIP OF */
                        /* TOKENS FOR THE CONNECTION. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#endif

#pragma section aps_resyncrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_RESYNCRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SPECIFIES A PAST SYNCHRONISATION SERIAL */
                        /* NUMBER TO WHICH RESYNCHRONISATION IS TO */
                        /* BE ATTEMPTED. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SPECIFIES THE AVAILABILITY AND OWNERSHIP OF */
                        /* TOKENS FOR THE CONNECTION. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_RESYNCRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SPECIFIES A PAST SYNCHRONISATION SERIAL */
                        /* NUMBER TO WHICH RESYNCHRONISATION IS TO */
                        /* BE ATTEMPTED. */
    short _far *,       /* IN OPTIONAL  */
                        /* SPECIFIES THE AVAILABILITY AND OWNERSHIP OF */
                        /* TOKENS FOR THE CONNECTION. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_status_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_STATUS_ (
    short ,             /* IN  */
                        /* CEPI FOR WHICH STATUS IS REQUESTED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* ONE OF THE ZAPS-VAL-EVT-... CODES */
                        /* INDICATING THE LAST EVENT ON THIS */
                        /* CONNECTION.  THE NULL VALUE FOR THIS */
                        /* IS ZAPS-VAL-EVT-NONE. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NAME OF CONNECTION (INCLUDING SUBDEVICE) */
                        /* INDICATED BY CEPI. (ZAPS-DDL-FILENAME) */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* IDENTIFIER OF THE SERVICE REPORTING THE */
                        /* ERROR INDICATED BY THE ERROR^CODE AND */
                        /* ERROR^SUBCODE VALUES RETURNED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DIAGNOSTIC INFORMATION ABOUT THE ERROR */
                        /* CONDITION (GENERALLY TANDEM INTERNAL). */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* FIRST-DETECTED ERROR. */
                        /* ( ZAPS-DDL-ORIGINAL-ERROR ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* TRANSPORT STATE FOR RESOLVING ERRORS. */
                        /* ( INT ) */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* TRANSPORT STATE FOR RESOLVING ERRORS. */
                        /* ( INT ) */
    );
#else
_tal _extensible short APS_STATUS_ (
    short ,             /* IN  */
                        /* CEPI FOR WHICH STATUS IS REQUESTED */
    short _far *,       /* OUT OPTIONAL  */
                        /* ONE OF THE ZAPS-VAL-EVT-... CODES */
                        /* INDICATING THE LAST EVENT ON THIS */
                        /* CONNECTION.  THE NULL VALUE FOR THIS */
                        /* IS ZAPS-VAL-EVT-NONE. */
    short _far *,       /* OUT OPTIONAL  */
                        /* NAME OF CONNECTION (INCLUDING SUBDEVICE) */
                        /* INDICATED BY CEPI. (ZAPS-DDL-FILENAME) */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* IDENTIFIER OF THE SERVICE REPORTING THE */
                        /* ERROR INDICATED BY THE ERROR^CODE AND */
                        /* ERROR^SUBCODE VALUES RETURNED */
    short _far *,       /* OUT OPTIONAL  */
                        /* DIAGNOSTIC INFORMATION ABOUT THE ERROR */
                        /* CONDITION (GENERALLY TANDEM INTERNAL). */
    short _far *,       /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* FIRST-DETECTED ERROR. */
                        /* ( ZAPS-DDL-ORIGINAL-ERROR ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* TRANSPORT STATE FOR RESOLVING ERRORS. */
                        /* ( INT ) */
    short _far *        /* OUT OPTIONAL  */
                        /* PROVIDES INFORMATION ABOUT THE */
                        /* TRANSPORT STATE FOR RESOLVING ERRORS. */
                        /* ( INT ) */
    );
#endif

#pragma section aps_subdevice_discard_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SUBDEVICE_DISCARD_ (
    short _ptr32 *,     /* IN  */
                        /* OSIMGR THAT CREATED THE SUBDEVICE */
                        /* ( ZAPS-DDL-FILENAME ) */
    short _ptr32 *      /* IN  */
                        /* TAPS SUBDEVICE TO BE DELETED */
                        /* ( ZAPS-DDL-FILENAME ) */
    );
#else
_tal _extensible short APS_SUBDEVICE_DISCARD_ (
    short _far *,       /* IN  */
                        /* OSIMGR THAT CREATED THE SUBDEVICE */
                        /* ( ZAPS-DDL-FILENAME ) */
    short _far *        /* IN  */
                        /* TAPS SUBDEVICE TO BE DELETED */
                        /* ( ZAPS-DDL-FILENAME ) */
    );
#endif

#pragma section aps_sync_getparam_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SYNC_GETPARAM_ (
    short ,               /* IN  */
                          /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* SYNCHRONISATION POINT SERIAL NUMBER. */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* SPECIFIES THE AVAILABILITY AND OWNERSHIP */
                          /* OF TOKENS FOR THE CONNECTION. */
                          /* ( ZAPS-DDL-TOKENS ) */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* SPECIFIES THE TYPE OF RESYNCHRONISATION. */
                          /* ONE OF THE ZAPS-VAL-RESYNC-... LITERALS */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /* SPECIFIES THE REASON PARAMETER OF THE */
                          /* LAST RECEIVED S-U-EXCEPTION.IND OR */
                          /* S-P-EXCEPTION.IND PRIMITIVE. */
    );
#else
_tal _extensible short APS_SYNC_GETPARAM_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* SYNCHRONISATION POINT SERIAL NUMBER. */
    short _far *,       /* OUT OPTIONAL  */
                        /* SPECIFIES THE AVAILABILITY AND OWNERSHIP */
                        /* OF TOKENS FOR THE CONNECTION. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _far *,       /* OUT OPTIONAL  */
                        /* SPECIFIES THE TYPE OF RESYNCHRONISATION. */
                        /* ONE OF THE ZAPS-VAL-RESYNC-... LITERALS */
    short _far *        /* OUT OPTIONAL  */
                        /* SPECIFIES THE REASON PARAMETER OF THE */
                        /* LAST RECEIVED S-U-EXCEPTION.IND OR */
                        /* S-P-EXCEPTION.IND PRIMITIVE. */
    );
#endif

#pragma section aps_sync_majorreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SYNC_MAJORREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_SYNC_MAJORREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_sync_majorrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SYNC_MAJORRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_SYNC_MAJORRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_sync_minorreq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SYNC_MINORREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* BOOLEAN INDICATING WHETHER AN EXPLICIT */
                        /* ACKNOWLEDGEMENT FROM THE REMOTE ENTITY */
                        /* IS REQUESTED. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_SYNC_MINORREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short ,             /* IN  */
                        /* BOOLEAN INDICATING WHETHER AN EXPLICIT */
                        /* ACKNOWLEDGEMENT FROM THE REMOTE ENTITY */
                        /* IS REQUESTED. */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO GIVE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_sync_minorrsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_SYNC_MINORRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SYNCHRONISATION POINT SERIAL NUMBER. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#else
_tal _extensible short APS_SYNC_MINORRSP_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    __int32_t ,         /* IN  */
                        /* SYNCHRONISATION POINT SERIAL NUMBER. */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* TOKENS TO PLEASE ( ZAPS-DDL-TOKENS ) */
    );
#endif

#pragma section aps_token_givereq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_TOKEN_GIVEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* SPECIFIES WHICH TOKENS ARE TO BE GIVEN */
                        /* TO THE REMOTE ENTITY. */
                        /* ( ZAPS-DDL-TOKENS ) */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#else
_tal _extensible short APS_TOKEN_GIVEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* SPECIFIES WHICH TOKENS ARE TO BE GIVEN */
                        /* TO THE REMOTE ENTITY. */
                        /* ( ZAPS-DDL-TOKENS ) */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short _far *        /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    );
#endif

#pragma section aps_token_pleasereq_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_TOKEN_PLEASEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* SPECIFIES WHICH TOKENS ARE REQUESTED */
                        /* FROM THE REMOTE ENTITY. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#else
_tal _extensible short APS_TOKEN_PLEASEREQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* SPECIFIES WHICH TOKENS ARE REQUESTED */
                        /* FROM THE REMOTE ENTITY. */
                        /* ( ZAPS-DDL-TOKENS ) */
    short _far *,       /* IN OPTIONAL  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY */
    __int32_t           /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    );
#endif

#pragma section aps_typeddata_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short APS_TYPEDDATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _ptr32 *,     /* IN  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SEND OPERATION */
    short               /* IN OPTIONAL  */
                        /* AMOUNT OF DATA TO SEND PER BLOCK */
    );
#else
_tal _extensible short APS_TYPEDDATA_REQ_ (
    short ,             /* IN  */
                        /* CEPI OF THE REFERENCED CONNECTION */
    short _far *,       /* IN  */
                        /* USER DATA TO BE SENT TO THE REMOTE ENTITY. */
    __int32_t ,         /* IN OPTIONAL  */
                        /* USER-SUPPLIED TAG */
    short ,             /* IN OPTIONAL  */
                        /* SEND OPERATION */
    short               /* IN OPTIONAL  */
                        /* AMOUNT OF DATA TO SEND PER BLOCK */
    );
#endif

#pragma section armtrap
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ ARMTRAP;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal void ARMTRAP (
    short ,             /* IN  */
                        /* P VALUE FOR THE TRAP BRANCH */
    short               /* IN  */
                        /* S VALUE */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section awaitio
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status AWAITIO (
    short _ptr32 *,     /* IN/OUT  */
                        /* FILE NUMBER. ( -1 IMPLIES ANY FILE. */
                        /* THE FILE NUMBER OF THE COMPLETING */
                        /* REQUEST IS RETURNED ) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* USER DATA BUFFER POINTER */
    unsigned short _ptr32 *,      /* OUT OPTIONAL  */
                        /* ACTUAL NUMBER OF BYTES TRANSFERRED BY */
                        /* OPERATION (ZERO FOR CONTROL */
                        /* OPERATIONS) */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /* REQUEST TAG PASSED WITH THE ORIGINAL */
                        /* REQUEST */
    __int32_t           /* IN OPTIONAL  */
                        /* AMOUNT OF TIME TO WAIT FOR A */
                        /* COMPLETION (0D MEANS CHECK BUT DON'T */
                        /* WAIT IF THERE IS NO SATISFYING */
                        /* COMPLETION) */
    );
#else
_tal _variable _cc_status AWAITIO (
    short _near *,              /* IN/OUT  */
                                /* FILE NUMBER. ( -1 IMPLIES ANY FILE. */
                                /* THE FILE NUMBER OF THE COMPLETING */
                                /* REQUEST IS RETURNED ) */
    short _near *,              /* OUT OPTIONAL  */
                                /* USER DATA BUFFER POINTER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* ACTUAL NUMBER OF BYTES TRANSFERRED BY */
                                /* OPERATION (ZERO FOR CONTROL */
                                /* OPERATIONS) */
    __int32_t _near *,          /* OUT OPTIONAL  */
                                /* REQUEST TAG PASSED WITH THE ORIGINAL */
                                /* REQUEST */
    __int32_t                   /* IN OPTIONAL  */
                                /* AMOUNT OF TIME TO WAIT FOR A */
                                /* COMPLETION (0D MEANS CHECK BUT DON'T */
                                /* WAIT IF THERE IS NO SATISFYING */
                                /* COMPLETION) */
    );
#endif

#pragma section awaitiox
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status AWAITIOX (
    short _ptr32 *,             /* IN/OUT  */
    __int32_t _ptr32 *,         /* OUT OPTIONAL  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t _ptr32 *,         /* OUT OPTIONAL  */
    __int32_t ,                 /* IN OPTIONAL  */
    short _ptr32 *              /* OUT OPTIONAL  */
    );
#else
_tal _extensible _cc_status AWAITIOX (
    short _far *,               /* IN/OUT  */
    __int32_t _far *,           /* OUT OPTIONAL  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t _far *,           /* OUT OPTIONAL  */
    __int32_t ,                 /* IN OPTIONAL  */
    short _far *                /* OUT OPTIONAL  */
    );
#endif

#pragma section awaitioxl
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
#if (_TANDEM_ARCH_ == 0 )
_tal _extensible short AWAITIOXL (
    short _far *,       /* IN/OUT       */
    __int32_t _far *,   /* OUT OPTIONAL */
    __int32_t _far *,   /* OUT OPTIONAL */
    long long _far *,   /* OUT OPTIONAL */
    __int32_t,          /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL */
        );
 #else
 _tal _extensible short AWAITIOXL (
    short _ptr32 *,       /* IN/OUT       */
    __int32_t _ptr32 *,   /* OUT OPTIONAL */
    __int32_t _ptr32 *,   /* OUT OPTIONAL */
    long long _ptr32 *,   /* OUT OPTIONAL */
    __int32_t,            /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL */
        );
 #endif
#endif

#pragma section backspaceedit
_tal _extensible short BACKSPACEEDIT (
    short               /* IN  */
    );

#pragma section begintransaction
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _variable
short BEGINTRANSACTION (
    __int32_t _ptr64 *      /* OUT OPTIONAL  */
                            /* TAG FOR RESUMETRANSACTION RETURNED HERE */    );
#else
_tal _variable
short BEGINTRANSACTION (
    __int32_t _near *      /* OUT OPTIONAL  */
                           /* TAG FOR RESUMETRANSACTION RETURNED HERE */    );
#endif


#pragma section begintransaction_ext_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible
short BEGINTRANSACTION_EXT_ (
    __int32_t _ptr64 *      /* OUT OPTIONAL  */
                            /* TAG FOR RESUMETRANSACTION RETURNED HERE */
  ,__int32_t                /* IN OPTIONAL */
   ,long long               /* IN OPTIONAL */
    );
#else
_tal _extensible
short BEGINTRANSACTION_EXT_ (
    __int32_t _near *      /* OUT OPTIONAL  */
                           /* TAG FOR RESUMETRANSACTION RETURNED HERE */
  ,__int32_t               /* IN OPTIONAL */
   ,long long              /* IN OPTIONAL */
    );
#endif


#pragma section binsem_close_
#include <tnsint.h>
_tal _extensible short BINSEM_CLOSE_ (
    __int32_t           /* IN  */
    );

#pragma section binsem_create_
#include <tnsint.h>
_tal _extensible short BINSEM_CREATE_ (
    __int32_t _far *,   /* OUT  */
    short               /* IN  */
    );

#pragma section binsem_forcelock_
#include <tnsint.h>
_tal short BINSEM_FORCELOCK_ (
    __int32_t ,         /* IN  */
    short _far *        /* OUT  */
    );

#pragma section binsem_lock_
#include <tnsint.h>
_tal short BINSEM_LOCK_ (
    __int32_t ,         /* IN  */
    __int32_t           /* IN  */
    );

#pragma section binsem_open_
#include <tnsint.h>
_tal _extensible short BINSEM_OPEN_ (
    __int32_t _far *,   /* OUT  */
    short _far *,       /* IN  */
    __int32_t           /* IN  */
    );

#pragma section binsem_unlock_
#include <tnsint.h>
_tal short BINSEM_UNLOCK_ (
    __int32_t           /* IN  */
    );

#pragma section breakmessage_send_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short BREAKMESSAGE_SEND_ (
    short _ptr32 *,       /* IN  */
                          /* [0:9] */
    short ,               /* IN  */
    short _ptr32 *        /* IN OPTIONAL  */
                          /* [0:1] */
    );
#else
_tal _extensible short BREAKMESSAGE_SEND_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short ,             /* IN  */
    short _far *        /* IN OPTIONAL  */
                        /* [0:1] */
    );
#endif

#pragma section cancel
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status CANCEL (
    short               /* IN  */
                        /* FILE NUMBER */
    );

#pragma section cancelprocesstimeout
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status CANCELPROCESSTIMEOUT (
    short               /* IN  */
                        /* TLE ADDRESS */
    );

#pragma section cancelreq
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status CANCELREQ (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN OPTIONAL  */
                        /* TAG OF REQUEST TO CANCEL */
    );

#pragma section cancelreql
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
_tal _variable short CANCELREQL (
    short ,             /* IN  */
                        /* FILE NUMBER */
    long long           /* IN OPTIONAL  */
                        /* TAG OF REQUEST TO CANCEL */
     );
#endif

#pragma section canceltimeout
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status CANCELTIMEOUT (
    short               /* IN  */
    );

#pragma section changelist
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status CHANGELIST (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* >=0: UNIT IN ADDRESS LIST */
                        /* -1: CHANGE LIST TYPE */
                        /* -2: RESET PARTIAL DISABLE */
    short               /* IN OPTIONAL  */
                        /* UNIT CHANGE: 0=ENABLE */
                        /* 1=DISABLE */
                        /* TYPE CHANGE: NEW LIST TYPE */
                        /* RESET:       DON'T CARE */
    );

#pragma section checkallocatesegment
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status CHECKALLOCATESEGMENT (
    short ,               /* IN  */
    short _ptr32 *,       /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible _cc_status CHECKALLOCATESEGMENT (
    short ,             /* IN  */
    short _far *,       /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT  */
    );
#endif

#pragma section checkclose
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status CHECKCLOSE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short               /* IN OPTIONAL  */
                        /* DISPOSITION */
    );

#pragma section checkdeallocatesegment
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status CHECKDEALLOCATESEGMENT (
    short ,               /* IN  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible _cc_status CHECKDEALLOCATESEGMENT (
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT  */
    );
#endif

#pragma section checkdefine
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CHECKDEFINE (
    const char _ptr32 *   /* IN OPTIONAL  */
    );
#else
_tal _extensible short CHECKDEFINE (
    const char _far *   /* IN OPTIONAL  */
    );
#endif

#pragma section checkmonitor
_tal short CHECKMONITOR (
    void);

#pragma section checkopen
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status CHECKOPEN (
    short _ptr32 *,     /* IN  */
                        /* FILE NAME IN FORM SUITABLE FOR */
                        /* OPEN */
    short ,             /* IN/OUT  */
                        /* FILE NUMBER IN THIS PROCESS, */
                        /* THIS AND THE PREVIOUS PARAMETER */
                        /* ARE REQUIRED */
    short ,             /* IN OPTIONAL  */
                        /* FILE SYSTEM OPEN PARAMETERS */
    short ,             /* IN OPTIONAL  */
                        /* SYNCHRONIZATION DEPTH */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SEQUENTIAL BLOCK BUFFER */
    short ,             /* IN OPTIONAL  */
                        /* SEQUENTIAL BLOCK BUFFER SIZE */
    short _ptr32 *      /* OUT  */
                        /* ERROR NUMBER FROM BACKUP'S OPEN */
    );
#else
_tal _variable _cc_status CHECKOPEN (
    short _near *,      /* IN  */
                        /* FILE NAME IN FORM SUITABLE FOR */
                        /* OPEN */
    short ,             /* IN/OUT  */
                        /* FILE NUMBER IN THIS PROCESS, */
                        /* THIS AND THE PREVIOUS PARAMETER */
                        /* ARE REQUIRED */
    short ,             /* IN OPTIONAL  */
                        /* FILE SYSTEM OPEN PARAMETERS */
    short ,             /* IN OPTIONAL  */
                        /* SYNCHRONIZATION DEPTH */
    short _near *,      /* IN OPTIONAL  */
                        /* SEQUENTIAL BLOCK BUFFER */
    short ,             /* IN OPTIONAL  */
                        /* SEQUENTIAL BLOCK BUFFER SIZE */
    short _near *       /* OUT  */
                        /* ERROR NUMBER FROM BACKUP'S OPEN */
    );
#endif

#pragma section checkpoint
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ CHECKPOINT;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*   not native  */
_tal _variable short CHECKPOINT (
    short _near *,      /* IN OPTIONAL  */
                        /* POINTER TO STACK BASE */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
                        /* DATA BLOCK DEFINITIONS, OR IF */
                        /* ONLY THE 2ND PARAMETER IS GIVEN, */
                        /* THEN IT IS A FILE NUMBER */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section checkpointedit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CHECKPOINTEDIT (
    short _ptr32 *        /* OUT  */
                          /*  first word address of file info  */
    );
#else
_tal _extensible short CHECKPOINTEDIT (
    short _far *        /* OUT  */
                        /*  first word address of file info  */
    );
#endif

#pragma section checkpointmany
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ CHECKPOINTMANY;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*   not native  */
_tal _variable short CHECKPOINTMANY (
    short _near *,      /* IN OPTIONAL  */
                        /* POINTER TO STACK BASE */
    short _near *       /* IN OPTIONAL  */
                        /* ITEMS TO CHECKPOINT */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section checkpointmanyx
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CHECKPOINTMANYX (
    short _ptr32 *,       /* IN OPTIONAL  */
    short _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _extensible short CHECKPOINTMANYX (
    short _near *,      /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );
#endif

#pragma section checkpointx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CHECKPOINTX (
    short _ptr32 *,       /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short CHECKPOINTX (
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section checkresizesegment
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status CHECKRESIZESEGMENT (
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible _cc_status CHECKRESIZESEGMENT (
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section checkrestoreedit
_tal _extensible short CHECKRESTOREEDIT (
    short               /* IN  */
                        /*  first word address of file info  */
    );

#pragma section checksetmode
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status CHECKSETMODE (
    short ,               /* IN  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible _cc_status CHECKSETMODE (
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section checkswitch
_tal short CHECKSWITCH (
    void);

#pragma section check_break
#if (_TANDEM_ARCH_ > 1)
_tal _alias ("CHECK^BREAK") short CHECK_BREAK (
    short _ptr32 *       /* IN  */
                         /* FCB OF FILE TO CHECK BREAK STATUS OF */
    );
#else
_tal _alias ("CHECK^BREAK") short CHECK_BREAK (
    short _near *       /* IN  */
                        /* FCB OF FILE TO CHECK BREAK STATUS OF */
    );
#endif

#pragma section check_file
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("CHECK^FILE") _extensible short CHECK_FILE (
    short _ptr32 *,      /* IN  */
                         /* FCB TO GET VALUE FROM */
    short ,              /* IN  */
                         /* WHICH CHECK^FILE OPERATION TO PERFORM */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* RETURNED VALUE (IF ADDRESS) */
    );
#elif (_TANDEM_ARCH_ == 1)
   _tal _alias ("CHECK^FILE") _extensible short CHECK_FILE (
    short _near *,      /* IN  */
                        /* FCB TO GET VALUE FROM */
    short ,             /* IN  */
                        /* WHICH CHECK^FILE OPERATION TO PERFORM */
    short _near *       /* OUT OPTIONAL  */
                        /* RETURNED VALUE (IF ADDRESS) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! ( _TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("CHECK^FILE") _variable short CHECK_FILE (
    short _near *,      /* IN  */
                        /* FCB TO GET VALUE FROM */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section child_lost_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CHILD_LOST_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *        /* IN  */
                          /* [0:9] */
    );
#else
_tal _extensible short CHILD_LOST_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *        /* IN  */
                        /* [0:9] */
    );
#endif

#pragma section close
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status CLOSE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short               /* IN OPTIONAL  */
                        /* MAGNETIC TAPE CLOSE STATUS */
    );

#pragma section closealledit
_tal _extensible void CLOSEALLEDIT (
    void);

#pragma section closeedit
_tal _extensible void CLOSEEDIT (
    short ,             /* IN  */
                        /*  open file number  */
    short               /* IN OPTIONAL  */
                        /*  keep file number option  */
    );

#pragma section closeedit_
_tal _extensible short CLOSEEDIT_ (
    short ,             /* IN  */
                        /*  open file number  */
    short               /* IN OPTIONAL  */
                        /*  keep file number option  */
    );

#pragma section close_file
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("CLOSE^FILE") _extensible short CLOSE_FILE (
    short _ptr32 *,      /* IN  */
                         /* FCB OF FILE TO CLOSE */
    short                /* IN OPTIONAL  */
                         /* CONTROLS TAPE OPTIONS */
    );
#elif (_TANDEM_ARCH_ == 1)
_tal _alias ("CLOSE^FILE") _extensible short CLOSE_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO CLOSE */
    short               /* IN OPTIONAL  */
                        /* CONTROLS TAPE OPTIONS */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("CLOSE^FILE") _variable short CLOSE_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO CLOSE */
    short               /* IN OPTIONAL  */
                        /* CONTROLS TAPE OPTIONS */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section completeioedit
#include <tnsint.h>
_tal _extensible short COMPLETEIOEDIT (
    short ,             /* IN  */
                        /*  file number returned by AWAITIO  */
    short ,             /* IN  */
                        /*  transfer count returned by AWAITIO  */
    __int32_t           /* IN  */
                        /*  tag returned by AWAITIO  */
    );

#pragma section compressedit
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short COMPRESSEDIT (
    short _ptr32 *,       /* IN/OUT  */
                          /*  open file number  */
    __int32_t ,           /* IN  */
                          /*  new line number of first line  */
    __int32_t ,           /* IN  */
                          /*  new line number increment  */
    short (_ptr32 *)(
    )                     /* IN OPTIONAL  */
                          /*  proc for UNDO capability  */
    );
#else
_tal _extensible short COMPRESSEDIT (
    short _far *,       /* IN/OUT  */
                        /*  open file number  */
    __int32_t ,         /* IN  */
                        /*  new line number of first line  */
    __int32_t ,         /* IN  */
                        /*  new line number increment  */
    short (*)(
    )                   /* IN OPTIONAL  */
                        /*  proc for UNDO capability  */
    );
#endif

#pragma section computejuliandayno
#include <tnsint.h>
_tal _extensible __int32_t COMPUTEJULIANDAYNO (
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section computetimestamp
_tal _extensible long long COMPUTETIMESTAMP (
    short _near *,      /* IN  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section computetransid
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short COMPUTETRANSID (
    long long _ptr64 *,   /* OUT  */
    __int32_t ,           /* IN  */
    short ,               /* IN  */
    __int32_t ,           /* IN  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short COMPUTETRANSID (
    long long _far *,   /* OUT  */
    __int32_t ,         /* IN  */
    short ,             /* IN  */
    __int32_t ,         /* IN  */
    short               /* IN OPTIONAL  */
    );
#endif


#pragma section config_getinfo_byldev2_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t CONFIG_GETINFO_BYLDEV2_ (
    __int32_t ,           /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN   */
    short _ptr32 *,       /* OUT  */
    __int32_t ,           /* IN   */
    __int32_t _ptr32 *    /* OUT  */
    );
#else
_tal __int32_t CONFIG_GETINFO_BYLDEV2_ (
    __int32_t ,         /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN   */
    short _far *,       /* OUT  */
    __int32_t ,         /* IN   */
    __int32_t _far *    /* OUT  */
    );
#endif

#pragma section config_getinfo_byldev_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t CONFIG_GETINFO_BYLDEV_ (
    __int32_t ,           /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t ,           /* IN  */
    __int32_t _ptr32 *    /* OUT  */
    );
#else
_tal __int32_t CONFIG_GETINFO_BYLDEV_ (
    __int32_t ,         /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t ,         /* IN  */
    __int32_t _far *    /* OUT  */
    );
#endif

#pragma section config_getinfo_byname2_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t CONFIG_GETINFO_BYNAME2_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN   */
    short _ptr32 *,       /* OUT  */
    __int32_t ,           /* IN   */
    __int32_t _ptr32 *    /* OUT  */
    );
#else
_tal __int32_t CONFIG_GETINFO_BYNAME2_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN   */
    short _far *,       /* OUT  */
    __int32_t ,         /* IN   */
    __int32_t _far *    /* OUT  */
    );
#endif

#pragma section config_getinfo_byname_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t CONFIG_GETINFO_BYNAME_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t ,           /* IN  */
    __int32_t _ptr32 *    /* OUT  */
    );
#else
_tal __int32_t CONFIG_GETINFO_BYNAME_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t ,         /* IN  */
    __int32_t _far *    /* OUT  */
    );
#endif

#pragma section contime
_tal void CONTIME (
    short _near *,      /* OUT  */
                        /* TIME IS RETURNED HERE, IN THE FORM: */
                        /* 0:  YEAR      (1975-2074+) */
                        /* 1:  MONTH     (1-12) */
                        /* 2:  DAY       (1-31) */
                        /* 3:  HOUR      (0-23) */
                        /* 4:  MINUTE    (0-59) */
                        /* 5:  SECONDS   (0-59) */
                        /* 6:  .01 SECS  (0-99) */
                        /* TIME STAMP: */
    short ,             /* IN  */
                        /* HIGH ORDER 16 BITS */
    short ,             /* IN  */
                        /* MIDDLE 16 BITS */
    short               /* IN  */
                        /* LOW 16 BITS */
    );

#pragma section control
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status CONTROL (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* CONTROL NUMBER */
    short ,             /* IN  */
                        /* PARAMETER */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );

#pragma section controlbuf
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status CONTROLBUF (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* CONTROL NUMBER */
    short _ptr32 *,     /* IN  */
                        /* CONTROL BUFFER */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN CONTROL BUFFER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status CONTROLBUF (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* CONTROL NUMBER */
    short _near *,      /* IN  */
                        /* CONTROL BUFFER */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN CONTROL BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );
#endif

#pragma section controlmessagesystem
_tal _extensible short CONTROLMESSAGESYSTEM (
    short ,             /* IN  */
    short               /* IN  */
    );

#pragma section convertasciiebcdic
_tal void CONVERTASCIIEBCDIC (
    char _far *,            /* IN/OUT  */
                            /*  characters to be translated */
    const unsigned short ,  /* IN  */
                            /*  number of characters (unsigned: 0..65535) */
    const short             /* IN  */
                            /*  0:     no translation */
                            /*  1:     EBCDIC to ASCII */
                            /*  2:     ASCII to EBCDIC */
                            /*  other: undefined */
    );

#pragma section convertprocessname
#if (_TANDEM_ARCH_ > 1)
_tal void CONVERTPROCESSNAME (
    short _ptr32 *       /* IN/OUT  */
                         /* NAME TO BE CONVERTED */
    );
#else
_tal void CONVERTPROCESSNAME (
    short _near *       /* IN/OUT  */
                        /* NAME TO BE CONVERTED */
    );
#endif

#pragma section convertprocesstime
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status CONVERTPROCESSTIME (
    long long ,         /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section converttimestamp
_tal _extensible long long CONVERTTIMESTAMP (
    long long ,         /* IN  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section cprl_arealphas_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_AREALPHAS_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    __int32_t _ptr32 *,   /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_AREALPHAS_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    __int32_t _far *,   /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_arenumerics_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_ARENUMERICS_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    __int32_t _ptr32 *,   /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_ARENUMERICS_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    __int32_t _far *,   /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_are_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_ARE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    __int32_t _ptr32 *,   /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_ARE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    __int32_t _far *,   /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_compare1encoded_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_COMPARE1ENCODED_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_COMPARE1ENCODED_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_compareobjects_
#include <tnsint.h>
_tal _extensible short CPRL_COMPAREOBJECTS_ (
    __int32_t ,         /* IN  */
    __int32_t           /* IN  */
    );

#pragma section cprl_compare_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_COMPARE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_COMPARE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_decode_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_DECODE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_DECODE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_downshift_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_DOWNSHIFT_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_DOWNSHIFT_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_encode_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_ENCODE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_ENCODE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getalphatable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETALPHATABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETALPHATABLE_ (
    char _far *,        /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getcharclasstable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETCHARCLASSTABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t ,           /* IN  */
    char _ptr32 *,        /* IN  */
    short                 /* IN  */
    );
#else
_tal _extensible short CPRL_GETCHARCLASSTABLE_ (
    char _far *,        /* OUT  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN  */
    short               /* IN  */
    );
#endif

#pragma section cprl_getdownshifttable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETDOWNSHIFTTABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETDOWNSHIFTTABLE_ (
    char _far *,        /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getfirst_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETFIRST_ (
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETFIRST_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getlast_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETLAST_ (
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETLAST_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getnextinsequence_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETNEXTINSEQUENCE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETNEXTINSEQUENCE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getnumtable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETNUMTABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETNUMTABLE_ (
    char _far *,        /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getspecialtable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETSPECIALTABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETSPECIALTABLE_ (
    char _far *,        /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_getupshifttable_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_GETUPSHIFTTABLE_ (
    char _ptr32 *,        /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_GETUPSHIFTTABLE_ (
    char _far *,        /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cprl_info_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_INFO_ (
    __int32_t ,           /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short CPRL_INFO_ (
    __int32_t ,         /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section cprl_readobject_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_READOBJECT_ (
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    __int32_t _ptr32 *    /* OUT OPTIONAL  */
    );
#else
_tal _extensible short CPRL_READOBJECT_ (
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    __int32_t _far *    /* OUT OPTIONAL  */
    );
#endif

#pragma section cprl_upshift_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPRL_UPSHIFT_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short CPRL_UPSHIFT_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section cputimes
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status CPUTIMES (
    short ,             /* IN OPTIONAL  */
                        /* CPU NUM */
    short ,             /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    long long _near *,  /* OUT OPTIONAL  */
                        /* CPU TIME IN MICROSEC SINCE COLDLOAD */
    long long _near *,  /* OUT OPTIONAL  */
                        /* CPU TIME IN MICROSEC SPENT IN PROCESS STATE */
    long long _near *,  /* OUT OPTIONAL  */
                        /* CPU TIME IN MICROSEC SPENT IN INTERRUPT STATE */
    long long _near *   /* OUT OPTIONAL  */
                        /* CPU TIME IN MICROSEC SPENT IN IDLE LOOP */
    );

#pragma section cpu_getinfolist_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CPU_GETINFOLIST_ (
    const char _ptr32 *,  /* IN OPTIONAL  */
                          /*  TARGET NODE NAME */
    short ,               /* IN OPTIONAL  */
                          /*  TARGET NODE NAME LENGTH */
                          /*  LOCAL NODE ASSUMED IF OMITTED */
    short ,               /* IN OPTIONAL  */
                          /*  TARGET CPU */
                          /*  CALLER'S CPU ASSUMED IF OMITTED */
    short _ptr32 *,       /* IN  */
                          /*  ARRAY INDICATING WHICH ATTRIBUTES */
    short ,               /* IN  */
                          /*  SHOULD HAVE THEIR VALUES RETURNED IN V_LST */
                          /*  ATTR_COUNT IS THE NUMBER OF ITEMS IN THE LIST */
    short _ptr32 *,       /* OUT  */
                          /*  ARRAY TO CONTAIN RETURNED DATA */
    short ,               /* IN  */
                          /*  MAX LENGTH, IN WORDS, OF V_LEN */
    short _ptr32 *,       /* OUT  */
                          /*  ACTUAL LENGTH FILLED IN */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  MAY CONTAIN INFO TO AUGMENT ERROR */
    );
#else
_tal _extensible short CPU_GETINFOLIST_ (
    const char _far *,  /* IN OPTIONAL  */
                        /*  TARGET NODE NAME */
    short ,             /* IN OPTIONAL  */
                        /*  TARGET NODE NAME LENGTH */
                        /*  LOCAL NODE ASSUMED IF OMITTED */
    short ,             /* IN OPTIONAL  */
                        /*  TARGET CPU */
                        /*  CALLER'S CPU ASSUMED IF OMITTED */
    short _far *,       /* IN  */
                        /*  ARRAY INDICATING WHICH ATTRIBUTES */
    short ,             /* IN  */
                        /*  SHOULD HAVE THEIR VALUES RETURNED IN V_LST */
                        /*  ATTR_COUNT IS THE NUMBER OF ITEMS IN THE LIST */
    short _far *,       /* OUT  */
                        /*  ARRAY TO CONTAIN RETURNED DATA */
    short ,             /* IN  */
                        /*  MAX LENGTH, IN WORDS, OF V_LEN */
    short _far *,       /* OUT  */
                        /*  ACTUAL LENGTH FILLED IN */
    short _far *        /* OUT OPTIONAL  */
                        /*  MAY CONTAIN INFO TO AUGMENT ERROR */
    );
#endif

#pragma section create
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status CREATE (
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *,     /* IN/OUT  */
                        /* FILE NAME */
#else
    short _near *,      /* IN/OUT  */
                        /* FILE NAME */
#endif
    short ,             /* IN OPTIONAL  */
                        /* PRIMARY EXTENT SIZE */
    short ,             /* IN OPTIONAL  */
                        /* FILE CODE */
    short ,             /* IN OPTIONAL  */
                        /* SECONDARY EXTENT SIZE */
    short ,             /* IN OPTIONAL  */
                        /* FILE TYPE */
    short ,             /* IN OPTIONAL  */
                        /* RECORD LENGTH */
    unsigned short ,    /* IN OPTIONAL  */
                        /* BLOCK LENGTH */
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* INDEX SEQUENTIAL ARRAY */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* KEY ARRAY */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PARTITION ARRAY */
#else
    short _near *,      /* IN OPTIONAL  */
                        /* INDEX SEQUENTIAL ARRAY */
    short _near *,      /* IN OPTIONAL  */
                        /* KEY ARRAY */
    short _near *,      /* IN OPTIONAL  */
                        /* PARTITION ARRAY */
#endif
    short ,             /* IN OPTIONAL  */
                        /* MAXEXTENTS VALUE           - DP2 ONLY */
    short ,             /* IN OPTIONAL  */
                        /* UNSTRUCTURED BUFFER SIZE   - DP2 ONLY */
    short               /* IN OPTIONAL  */
                        /* FILE ATTRIBUTE FLAGS       - DP2 ONLY */
    );

#pragma section createprocessname
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status CREATEPROCESSNAME (
    short _ptr32 *      /* OUT  */
                        /* PROCESS NAME */
    );
#else
_tal _cc_status CREATEPROCESSNAME (
    short _near *       /* OUT  */
                        /* PROCESS NAME */
    );
#endif

#pragma section createremotename
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status CREATEREMOTENAME (
    short _ptr32 *,     /* OUT  */
                        /* PROCESS NAME */
    short               /* IN  */
                        /* SYSTEM ID */
    );
#else
_tal _cc_status CREATEREMOTENAME (
    short _near *,      /* OUT  */
                        /* PROCESS NAME */
    short               /* IN  */
                        /* SYSTEM ID */
    );
#endif

#pragma section creatoraccessid
_tal short CREATORACCESSID (
    void);

#pragma section crtpid_to_processhandle_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short CRTPID_TO_PROCESSHANDLE_ (
    short _ptr32 *,       /* IN  */
    short _ptr32 *,       /* OUT  */
                          /* [0:9] */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short CRTPID_TO_PROCESSHANDLE_ (
    short _far *,       /* IN  */
    short _far *,       /* OUT  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section currentspace
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ CURRENTSPACE;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal _variable short CURRENTSPACE (
    char _near *        /* OUT OPTIONAL  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section dayofweek
#include <tnsint.h>
_tal short DAYOFWEEK (
    __int32_t           /* IN  */
                        /* Julian Day Number */
    );

#pragma section deallocatesegment
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status DEALLOCATESEGMENT (
    short ,             /* IN  */
    short               /* IN OPTIONAL  */
    );

#pragma section debug
_tal void DEBUG (
    void);

#pragma section debugprocess
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void DEBUGPROCESS (
    short _ptr32 *,     /* IN  */
                        /* PROCESS ID OF PROCESS TO DEBUG */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* RESULTING ERROR NUMBER */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* HOME TERM FOR DEBUGGING */
    short               /* IN OPTIONAL  */
                        /* DEBUG THE PROCESS NOW (REQUIRES PRIV */
                        /* OR SUPER ID ACCESS) */
    );
#else
_tal _extensible void DEBUGPROCESS (
    short _near *,      /* IN  */
                        /* PROCESS ID OF PROCESS TO DEBUG */
    short _near *,      /* OUT OPTIONAL  */
                        /* RESULTING ERROR NUMBER */
    short _near *,      /* IN OPTIONAL  */
                        /* HOME TERM FOR DEBUGGING */
    short               /* IN OPTIONAL  */
                        /* DEBUG THE PROCESS NOW (REQUIRES PRIV */
                        /* OR SUPER ID ACCESS) */
    );
#endif

#pragma section defineadd
_tal _extensible short DEFINEADD (
    const char _far *,  /* IN  */
    short ,             /* IN OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section definedelete
_tal _extensible short DEFINEDELETE (
#if(_TANDEM_ARCH_ > 1)
    const char _ptr32 *   /* IN  */
#else
    const char _far *     /* IN  */
#endif
    );

#pragma section definedeleteall
_tal _extensible short DEFINEDELETEALL (
    void);

#pragma section defineinfo
_tal _extensible short DEFINEINFO (
    const char _far *,  /* IN  */
    char _far *,        /* OUT  */
    char _far *,        /* OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _near *       /* OUT  */
    );

#pragma section definelist
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status DEFINELIST (
    short ,               /* IN  */
                          /* FILE NUMBER */
 #if (_TANDEM_ARCH_ > 1)
    short _ptr32 *,       /* IN  */
                          /* ADDRESS LIST */
 #else
    short _near *,        /* IN  */
                          /* ADDRESS LIST */
 #endif
    short ,               /* IN  */
                          /* WORDS/ENTRY */
    short ,               /* IN  */
                          /* TOTAL ENTRIES */
    short ,               /* IN  */
                          /* NUMBER OF POLLING ENTRIES */
    short                 /* IN  */
                          /* 0=CONTINUOUS POLL */
                          /* <>0 =NUMBER OF PASSES THRU POLL LIST */
    );

#pragma section definemode
_tal _extensible short DEFINEMODE (
    short ,             /* IN OPTIONAL  */
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *      /* OUT OPTIONAL  */
#else
    short _near *       /* OUT OPTIONAL  */
#endif
    );

#pragma section definenextname
_tal _extensible short DEFINENEXTNAME (
#if (_TANDEM_ARCH_ > 1)
    char _ptr32 *         /* IN/OUT  */
#else
    char _far *           /* IN/OUT  */
#endif
    );

#pragma section definepool
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal short DEFINEPOOL (
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* IN  */
    __int32_t             /* IN  */
    );
#else
_tal short DEFINEPOOL (
    short _far *,       /* OUT  */
    short _far *,       /* IN  */
    __int32_t           /* IN  */
    );
#endif

#pragma section definereadattr
_tal _extensible short DEFINEREADATTR (
    const char _far *,  /* IN OPTIONAL  */
    char _far *,        /* IN/OUT  */
    short _near *,      /* IN/OUT OPTIONAL  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _near *,      /* OUT  */
    short ,             /* IN OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section definerestore
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short DEFINERESTORE (
    short _ptr32 *,       /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short DEFINERESTORE (
    short _far *,       /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short _near *       /* OUT  */
    );
#endif

#pragma section definerestorework
_tal _extensible short DEFINERESTOREWORK (
    void);

#pragma section definerestorework2
_tal _extensible short DEFINERESTOREWORK2 (
    void);


#pragma section definesave
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short DEFINESAVE (
    const char _ptr32 *,  /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short                 /* IN  */
    );
#else
_tal _extensible short DEFINESAVE (
    const char _far *,  /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short               /* IN  */
    );
#endif

#pragma section definesavework
_tal _extensible short DEFINESAVEWORK (
    void);

#pragma section definesavework2
_tal _extensible short DEFINESAVEWORK2 (
    void);

#pragma section definesetattr
_tal _extensible short DEFINESETATTR (
    const char _far *,  /* IN  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _near *       /* IN OPTIONAL  */
    );

#pragma section definesetlike
_tal _extensible short DEFINESETLIKE (
    const char _far *   /* IN  */
    );

#pragma section definevalidatework
_tal _extensible short DEFINEVALIDATEWORK (
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *       /* OUT OPTIONAL  */
#else
    short _near *        /* OUT OPTIONAL  */
#endif
    );

#pragma section delay
#include <tnsint.h>
_tal void DELAY (
    __int32_t           /* IN  */
    );

#pragma section deleteedit
#include <tnsint.h>
_tal _extensible short DELETEEDIT (
    short ,             /* IN  */
                        /*  open file number  */
    __int32_t ,         /* IN  */
                        /*   first line number in range  */
    __int32_t           /* IN  */
                        /*   last  line number in range  */
    );

#pragma section deviceinfo
#if (_TANDEM_ARCH_ > 1)
_tal void DEVICEINFO (
    short _ptr32 *,      /* IN  */
                         /* 8 CHARACTER DEVICE NAME */
    short _ptr32 *,      /* OUT  */
                         /* .<0>     DEMOUNTABLE */
                         /* .<4:9>   DEVICE TYPE */
                         /* .<10:15> DEVICE SUBTYPE */
    short _ptr32 *       /* OUT  */
                         /* RECORD SIZE */
    );
#else
_tal void DEVICEINFO (
    short _near *,      /* IN  */
                        /* 8 CHARACTER DEVICE NAME */
    short _near *,      /* OUT  */
                        /* .<0>     DEMOUNTABLE */
                        /* .<4:9>   DEVICE TYPE */
                        /* .<10:15> DEVICE SUBTYPE */
    short _near *       /* OUT  */
                        /* RECORD SIZE */
    );
#endif

#pragma section deviceinfo2
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void DEVICEINFO2 (
    short _ptr32 *,     /* IN  */
                        /* 8 CHARACTER DEVICE NAME */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* .<0>     DEMOUNTABLE */
                        /* .<4:9>   DEVICE TYPE */
                        /* .<10:15> DEVICE SUBTYPE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* RECORD SIZE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DISC PROCESS TYPE ( 1 IF DP2) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* error return */
    short ,             /* IN OPTIONAL  */
                        /* processing options: */
                        /* .<14>  time msgs to 0,30 processes */
                        /* .<15>  do not send msgs to 0,30 processes */
    __int32_t           /* IN OPTIONAL  */
                        /* max wait time for option <14> */
    );
#else
_tal _extensible void DEVICEINFO2 (
    short _near *,      /* IN  */
                        /* 8 CHARACTER DEVICE NAME */
    short _near *,      /* OUT OPTIONAL  */
                        /* .<0>     DEMOUNTABLE */
                        /* .<4:9>   DEVICE TYPE */
                        /* .<10:15> DEVICE SUBTYPE */
    short _near *,      /* OUT OPTIONAL  */
                        /* RECORD SIZE */
    short _near *,      /* OUT OPTIONAL  */
                        /* DISC PROCESS TYPE ( 1 IF DP2) */
    short _near *,      /* OUT OPTIONAL  */
                        /* error return */
    short ,             /* IN OPTIONAL  */
                        /* processing options: */
                        /* .<14>  time msgs to 0,30 processes */
                        /* .<15>  do not send msgs to 0,30 processes */
    __int32_t           /* IN OPTIONAL  */
                        /* max wait time for option <14> */
    );
#endif

#pragma section device_getinfobyldev_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short DEVICE_GETINFOBYLDEV_ (
    __int32_t ,         /* IN  */
                        /*  LOGICAL DEVICE TO GET INFO ON */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^LOGICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  MAX TIME TO WAIT ON IOP */
    short ,             /* IN OPTIONAL  */
                        /*  OPTION FLAGS */
    short ,             /* IN OPTIONAL  */
                        /*  TYPE TO SEARCH DCT FOR */
    short ,             /* IN OPTIONAL  */
                        /*  SUBTYPE TO SEARCH DCT FOR */
    char _ptr32 *,      /* IN/OUT OPTIONAL  */
                        /*  AREA TO RETURN NAME INTO */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF NAME */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /*  FILE SYSTEM ERROR CODE */
    );
#else
_tal _extensible short DEVICE_GETINFOBYLDEV_ (
    __int32_t ,         /* IN  */
                        /*  LOGICAL DEVICE TO GET INFO ON */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^LOGICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _far *,       /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _far *,       /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^DEF) */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _far *,       /* OUT OPTIONAL  */
                        /*  LENGTH ACTUALLY RETURNED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  MAX TIME TO WAIT ON IOP */
    short ,             /* IN OPTIONAL  */
                        /*  OPTION FLAGS */
    short ,             /* IN OPTIONAL  */
                        /*  TYPE TO SEARCH DCT FOR */
    short ,             /* IN OPTIONAL  */
                        /*  SUBTYPE TO SEARCH DCT FOR */
    char _far *,        /* IN/OUT OPTIONAL  */
                        /*  AREA TO RETURN NAME INTO */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF ABOVE AREA */
    short _far *,       /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF NAME */
    short _far *        /* OUT OPTIONAL  */
                        /*  FILE SYSTEM ERROR CODE */
    );
#endif

#pragma section device_getinfobyname_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short DEVICE_GETINFOBYNAME_ (
    char _ptr32 *,      /* IN  */
                        /*  DEVICE TO GET INFO ON */
    short ,             /* IN  */
                        /*  LENGTH OF NAME IN BYTES */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^LOGICALDEVICEINFO^D */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA  (BYTES) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^ */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA (BYTES) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^ */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA (BYTES) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  MAX TIME TO WAIT FOR IOP */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /*  DETAILER ERROR INFO */
    );
#else
_tal _extensible short DEVICE_GETINFOBYNAME_ (
    char _far *,        /* IN  */
                        /*  DEVICE TO GET INFO ON */
    short ,             /* IN  */
                        /*  LENGTH OF NAME IN BYTES */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^LOGICALDEVICEINFO^D */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA  (BYTES) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^ */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA (BYTES) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    short _far *,       /* OUT OPTIONAL  */
                        /*  (ZSYS^DDL^PHYSICALDEVICEINFO^ */
    short ,             /* IN OPTIONAL  */
                        /*  MAX LENGTH OF AREA (BYTES) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  ACTUAL LENGTH OF AREA USED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  MAX TIME TO WAIT FOR IOP */
    short _far *        /* OUT OPTIONAL  */
                        /*  DETAILER ERROR INFO */
    );
#endif

#pragma section diskinfo
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short DISKINFO (
    short _ptr32 *,       /* IN  */
                          /* volume/ldev name (or disc file), or define */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* volume capacity in pages */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* current volume freespace in pages */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* current number of fragments */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* largest fragment in pages */
    char _ptr32 *,        /* OUT OPTIONAL  */
                          /* pri & mirror drive product #s */
    __int32_t _ptr32 *    /* OUT OPTIONAL  */
                          /* pri & mirror drive capacities */
    );
#else
_tal _extensible short DISKINFO (
    short _far *,       /* IN  */
                        /* volume/ldev name (or disc file), or define */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* volume capacity in pages */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* current volume freespace in pages */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* current number of fragments */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* largest fragment in pages */
    char _far *,        /* OUT OPTIONAL  */
                        /* pri & mirror drive product #s */
    __int32_t _far *    /* OUT OPTIONAL  */
                        /* pri & mirror drive capacities */
    );
#endif

#pragma section disk_refresh_
_tal _extensible short DISK_REFRESH_ (
  #if (_TANDEM_ARCH_ > 1)
    char _ptr32 *,        /* IN  */
  #else
    char _far *,          /* IN  */
  #endif
    short                 /* IN  */
    );

#pragma section dnumin
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _resident _extensible __int32_t DNUMIN (
    char _ptr32 *,        /* IN  */
    __int32_t _ptr32 *,   /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _resident _extensible __int32_t DNUMIN (
    char _far *,        /* IN  */
    __int32_t _far *,   /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section DNUMIN64_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _resident _extensible
void _ptr64 * DNUMIN64_ (
   char  _ptr64 *         /*str*/,
   __int32_t  _ptr64 *    /*number*/,
   short                  /*base*/,
   short _ptr64 *         /*result*/,
   short                  /*flags*/);
#endif


#pragma section dnumout
#include <tnsint.h>
_tal _extensible short DNUMOUT (
    char _far *,        /* OUT  */
    __int32_t ,         /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section dst_getinfo_
_tal short DST_GETINFO_ (
    long long ,         /* IN  */
                        /* GMT for which info has to be found */
    short _far *        /* OUT  */
                        /* Buffer for DST info found */
    );

#pragma section dst_transition_add_
_tal short DST_TRANSITION_ADD_ (
    short _far *        /* IN  */
                        /* DST entry to be added to DST Table */
    );

#pragma section dst_transition_delete_
_tal short DST_TRANSITION_DELETE_ (
    short _far *        /* IN  */
                        /* DST entry to be deleted from DST Table */
    );

#pragma section dst_transition_modify_
_tal short DST_TRANSITION_MODIFY_ (
    short _far *,       /* IN  */
                        /* DST entry that is to be modified */
    short _far *        /* IN  */
                        /* DST entry that will replace OLDDST */
    );

#pragma section editread
#include <tnsint.h>
_tal short EDITREAD (
    short _near *,      /* IN  */
    char _near *,       /* OUT  */
    short ,             /* IN  */
      __int32_t _near *      /* OUT  */
    );

#pragma section editreadinit
_tal short EDITREADINIT (
    short _near *,      /* OUT  */
    short ,             /* IN  */
    short               /* IN  */
    );

#pragma section emsaddbuffer
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMSADDBUFFER (
    short _ptr32 *,       /* IN/OUT  */
    short _ptr32 *,       /* IN  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _extensible short EMSADDBUFFER (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );
#endif

#pragma section emsaddsubject
#include <tnsint.h>
_tal _extensible short EMSADDSUBJECT (
    short _far *,       /* IN/OUT  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );

#pragma section emsaddsubjectmap
_tal _extensible short EMSADDSUBJECTMAP (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );

#pragma section emsaddtokenmaps
_tal _variable short EMSADDTOKENMAPS (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN OPTIONAL  */
    short _far *,       /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* IN OPTIONAL  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN OPTIONAL  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN OPTIONAL  */
    char _far *,        /* IN  */
    short               /* IN  */
    );

#pragma section emsaddtokens
#include <tnsint.h>
_tal _variable short EMSADDTOKENS (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN OPTIONAL  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );


#pragma section emsget
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMSGET (
    short _ptr32 *,       /* IN/OUT  */
    short _ptr32 *,       /* IN  */
    char _ptr32 *,        /* IN/OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short EMSGET (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section emsgettkn
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMSGETTKN (
    short _ptr32 *,       /* IN/OUT  */
    __int32_t ,           /* IN  */
    char _ptr32 *,        /* IN/OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short EMSGETTKN (
    short _far *,       /* IN/OUT  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section emsinit
#include <tnsint.h>
_tal _extensible short EMSINIT (
    short _far *,       /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
    long long           /* IN OPTIONAL  */
    );

#pragma section emsinitmap
_tal _extensible short EMSINITMAP (
    short _far *,       /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
    long long           /* IN OPTIONAL  */
    );

#pragma section emssend
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMSSEND (
    short _ptr32 *,       /* IN/OUT  */
    short                 /* IN/OUT  */
    );
#else
_tal _extensible short EMSSEND (
    short _far *,       /* IN/OUT  */
    short               /* IN/OUT  */
    );
#endif

#pragma section emstext
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible __int32_t EMSTEXT (
    short _ptr32 *,     /* IN  */
                        /* EVENT BUFFER */
    char _ptr32 *,      /* OUT  */
                        /* PRINTABLE TEXT */
    short ,             /* IN  */
                        /* LOGICAL LINE LENGTH IN PRINTLINES */
    short ,             /* IN  */
                        /* NUMBER OF LOGICAL LINES IN PRINTLINES */
    short _ptr32 *,     /* OUT  */
                        /* ACTUAL NUMBER OF CHARACTERS FORMATTED */
                        /* INTO EACH LOGICAL LINE */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* KEY OF TEMPLATE FOR FORMATTING EVENT */
                        /* HEADER */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COLUMNS TO INDENT ON 2ND AND */
                        /* SUBSEQUENT LOGICAL LINES */
    short ,             /* IN OPTIONAL  */
                        /* SELECT NORMAL OR OPRLOG STYLE FORMATTIN */
    __int32_t _ptr32 *  /* IN OPTIONAL  */
                        /* DETAILED STATUS */
    );
#else
_tal _extensible __int32_t EMSTEXT (
    short _far *,       /* IN  */
                        /* EVENT BUFFER */
    char _far *,        /* OUT  */
                        /* PRINTABLE TEXT */
    short ,             /* IN  */
                        /* LOGICAL LINE LENGTH IN PRINTLINES */
    short ,             /* IN  */
                        /* NUMBER OF LOGICAL LINES IN PRINTLINES */
    short _far *,       /* OUT  */
                        /* ACTUAL NUMBER OF CHARACTERS FORMATTED */
                        /* INTO EACH LOGICAL LINE */
    short _far *,       /* IN OPTIONAL  */
                        /* KEY OF TEMPLATE FOR FORMATTING EVENT */
                        /* HEADER */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COLUMNS TO INDENT ON 2ND AND */
                        /* SUBSEQUENT LOGICAL LINES */
    short ,             /* IN OPTIONAL  */
                        /* SELECT NORMAL OR OPRLOG STYLE FORMATTIN */
    __int32_t _far *    /* IN OPTIONAL  */
                        /* DETAILED STATUS */
    );
#endif

#pragma section ems_common_tokens_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_COMMON_TOKENS_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  user content type */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_COMMON_TOKENS_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  user content type */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_obj_avail_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_OBJ_AVAIL_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_OBJ_AVAIL_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_obj_unavail_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_OBJ_UNAVAIL_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  underlying object name */
    short ,             /* IN OPTIONAL  */
                        /*  underlying object name length */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  symptom string */
    short ,             /* IN OPTIONAL  */
                        /*  symptom string */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_OBJ_UNAVAIL_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    char _far *,        /* IN OPTIONAL  */
                        /*  underlying object name */
    short ,             /* IN OPTIONAL  */
                        /*  underlying object name length */
    char _far *,        /* IN OPTIONAL  */
                        /*  symptom string */
    short ,             /* IN OPTIONAL  */
                        /*  symptom string */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the manager */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_oper_attn_comped_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_OPER_ATTN_COMPED_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  action id */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_OPER_ATTN_COMPED_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  action id */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_oper_attn_needed_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_OPER_ATTN_NEEDED_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  action id */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_OPER_ATTN_NEEDED_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  action id */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_other_state_change_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_OTHER_STATE_CHANGE_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_OTHER_STATE_CHANGE_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  current state */
    short ,             /* IN  */
                        /*  previous state */
    short ,             /* IN  */
                        /*  change reason */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_transient_fault_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_TRANSIENT_FAULT_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  transient fault type */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  critical indicator.  TRUE means critical. */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#else
_tal _extensible short EMS_TRANSIENT_FAULT_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short ,             /* IN  */
                        /*  transient fault type */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  critical indicator.  TRUE means critical. */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  job id */
    );
#endif

#pragma section ems_usage_threshold_chk_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_USAGE_THRESHOLD_CHK_ (
    float ,             /* IN */
                        /* current utilization usage level */
    short _ptr32 *,     /* IN/OUT  */
                        /*  usage threshold control block */
    short _ptr32 *      /* OUT  */
                        /*  report the event or not */
                        /*  zspi^val^true  -- the standard Usage */
                        /*                    Threshold event */
                        /*                    should be reported. */
                        /*  zspi^val^false -- otherwise */
    );
#else
_tal _extensible short EMS_USAGE_THRESHOLD_CHK_ (
    float ,             /* IN */
                        /* current utilization usage level */
    short _far *,       /* IN/OUT  */
                        /*  usage threshold control block */
    short _far *        /* OUT  */
                        /*  report the event or not */
                        /*  zspi^val^true  -- the standard Usage Threshold */
                        /*                    event should be reported. */
                        /*  zspi^val^false -- otherwise */
    );
#endif

#pragma section ems_usage_threshold_evt_bld_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_USAGE_THRESHOLD_EVT_BLD_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _ptr32 *,     /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short _ptr32 *,     /* IN  */
                        /*  usage threshold control block */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _ptr32 *,      /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  subject ssid */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  Job id */
    );
#else
_tal _extensible short EMS_USAGE_THRESHOLD_EVT_BLD_ (
    short _far *,       /* IN/OUT  */
                        /*  event buffer */
    short ,             /* IN  */
                        /*  event buffer length in bytes */
    short _far *,       /* IN  */
                        /*  the owner of this event signature */
    short ,             /* IN  */
                        /*  the subsystem specific event number */
    short _far *,       /* IN  */
                        /*  usage threshold control block */
    __int32_t ,         /* IN  */
                        /*  subject token id */
    char _far *,        /* IN  */
                        /*  subject token value */
    short ,             /* IN OPTIONAL  */
                        /*  subject token value length, in bytes. */
    short _far *,       /* IN OPTIONAL  */
                        /*  subject ssid */
    short _far *,       /* OUT OPTIONAL  */
                        /*  used buffer length in bytes */
    short ,             /* IN OPTIONAL  */
                        /*  true means critical */
    char _far *,        /* IN OPTIONAL  */
                        /*  the name of the maanger */
    short ,             /* IN OPTIONAL  */
                        /*  the length in bytes of the mgr^name */
    short               /* IN OPTIONAL  */
                        /*  Job id */
    );
#endif

#pragma section ems_utcb_init_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short EMS_UTCB_INIT_ (
    short _ptr32 *,     /* IN/OUT  */
                        /*  usage threshold control block */
    float ,             /* IN */
                        /*  configured high usage level */
    float ,             /* IN */
                        /*  configured low  usage level */
    short               /* IN  */
                        /*  utilization level unit */
    );
#else
_tal _extensible short EMS_UTCB_INIT_ (
    short _far *,       /* IN/OUT  */
                        /*  usage threshold control block */
    float ,             /* IN */
                        /*  configured high usage level */
    float ,             /* IN */
                        /*  configured low  usage level */
    short               /* IN  */
                        /*  utilization level unit */
    );
#endif

#pragma section endtransaction
_tal short ENDTRANSACTION (
    void);

#pragma section enformfinish
#if (_TANDEM_ARCH_ > 1)
_tal void ENFORMFINISH (
    short _ptr32 *       /* IN/OUT  */
                         /* CONTROL BLK: GLOBAL STORAGE */
                         /* BETWEEN CALLS */
    );
#else
_tal void ENFORMFINISH (
    short _near *       /* IN/OUT  */
                        /* CONTROL BLK: GLOBAL STORAGE */
                        /* BETWEEN CALLS */
    );
#endif

#pragma section enformreceive
/* This procedure cannot be used from a C program.  The following syntax is
   illegal; it will cause an error if this section is explicitly included. */
#ifndef WHOLE_CEXTDECS_INCLUDED__
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal short & _cc_status ENFORMRECEIVE (
    short _ptr32 *,     /* IN/OUT  */
                        /* CONTROL BLK: GLOBAL STORAGE */
                        /* BETWEEN CALLS */
    short _ptr32 *      /* IN/OUT  */
                        /* USER'S RECORD RECEIVING BUFFER */
    );
#else
_tal short & _cc_status ENFORMRECEIVE (
    short _near *,      /* IN/OUT  */
                        /* CONTROL BLK: GLOBAL STORAGE */
                        /* BETWEEN CALLS */
    short _near *       /* IN/OUT  */
                        /* USER'S RECORD RECEIVING BUFFER */
    );
#endif
#endif

#pragma section enformstart
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status ENFORMSTART (
    short _ptr32 *,     /* IN/OUT  */
                        /* CONTROL BLK: GLOBAL STORAGE */
                        /* BETWEEN CALLS */
    short _ptr32 *,     /* IN/OUT  */
                        /* NAME OF FILE CONTAINING COMPILED */
                        /* REQUEST */
    short ,             /* IN/OUT  */
                        /* LENGTH OF ENFORMRECEIVE BUFFER */
                        /* (BYTES) */
    short _ptr32 *,     /* IN/OUT  */
                        /* PLACE TO RETURN ERROR CODE */
    short ,             /* IN/OUT  */
                        /* <> 0 ==> RESTART QP ON NEW REQUEST */
    short _ptr32 *,     /* IN/OUT  */
                        /* "CI" PARAMETER MESSAGE */
    short _ptr32 *,     /* IN/OUT  */
                        /* TABLE OF "CI" ASSIGN MSGS */
    short _ptr32 *,     /* IN/OUT  */
                        /* PROCESS NAME OF SERVER QP */
    short ,             /* IN/OUT  */
                        /* CPU IN WHICH TO RUN PRIVATE QP */
    short ,             /* IN/OUT  */
                        /* PRIORITY AT WHICH TO RUN PRIVATE QP */
    __int32_t ,         /* IN/OUT  */
                        /* TIMEOUT FOR QP TO START PROCESSING */
                        /* REQUEST */
    short _ptr32 *      /* IN/OUT  */
                        /* "RESERVED FOR EXPANSION" */
    );
#else
_tal _variable _cc_status ENFORMSTART (
    short _near *,      /* IN/OUT  */
                        /* CONTROL BLK: GLOBAL STORAGE */
                        /* BETWEEN CALLS */
    short _near *,      /* IN/OUT  */
                        /* NAME OF FILE CONTAINING COMPILED */
                        /* REQUEST */
    short ,             /* IN/OUT  */
                        /* LENGTH OF ENFORMRECEIVE BUFFER */
                        /* (BYTES) */
    short _near *,      /* IN/OUT  */
                        /* PLACE TO RETURN ERROR CODE */
    short ,             /* IN/OUT  */
                        /* <> 0 ==> RESTART QP ON NEW REQUEST */
    short _near *,      /* IN/OUT  */
                        /* "CI" PARAMETER MESSAGE */
    short _near *,      /* IN/OUT  */
                        /* TABLE OF "CI" ASSIGN MSGS */
    short _near *,      /* IN/OUT  */
                        /* PROCESS NAME OF SERVER QP */
    short ,             /* IN/OUT  */
                        /* CPU IN WHICH TO RUN PRIVATE QP */
    short ,             /* IN/OUT  */
                        /* PRIORITY AT WHICH TO RUN PRIVATE QP */
    __int32_t ,         /* IN/OUT  */
                        /* TIMEOUT FOR QP TO START PROCESSING */
                        /* REQUEST */
    short _near *       /* IN/OUT  */
                        /* "RESERVED FOR EXPANSION" */
    );
#endif

#pragma section execsql
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void EXECSQL (
    char _ptr32 *,      /* IN  */
                        /* SQLIN^STRUCT (required) */
    char _ptr32 *,      /* IN/OUT  */
                        /* SQLCA^STRUCT (optional) */
    short _ptr32 *      /* OUT  */
                        /* return code  (optional) */
                        /* =sqlca.sqlcode */
    );
#else
_tal _extensible void EXECSQL (
    char _far *,        /* IN  */
                        /* SQLIN^STRUCT (required) */
    char _far *,        /* IN/OUT  */
                        /* SQLCA^STRUCT (optional) */
    short _far *        /* OUT  */
                        /* return code  (optional) */
                        /* =sqlca.sqlcode */
    );
#endif

#pragma section extendedit
#include <tnsint.h>
_tal _extensible short EXTENDEDIT (
    short _far *,       /* IN/OUT  */
                        /*  open file number  */
    __int32_t ,         /* IN  */
                        /*  new line number of first line  */
    __int32_t ,         /* IN  */
                        /*  new line number increment  */
    short (*)(
    )                   /* IN OPTIONAL  */
                        /*  proc for UNDO capability  */
    );

#pragma section externaltotandem
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short EXTERNALTOTANDEM (
    __int32_t _ptr32 *,  /* IN/OUT OPTIONAL  */
    __int32_t _ptr32 *,  /* IN/OUT OPTIONAL  */
    short ,              /* IN  */
    short _ptr32 *,      /* IN/OUT  */
    short ,              /* IN OPTIONAL  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    char _ptr32 *,       /* IN OPTIONAL  */
    char _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _variable short EXTERNALTOTANDEM (
    __int32_t _near *,  /* IN/OUT OPTIONAL  */
    __int32_t _near *,  /* IN/OUT OPTIONAL  */
    short ,             /* IN  */
    short _near *,      /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    char _near *,       /* IN OPTIONAL  */
    char _near *        /* IN OPTIONAL  */
    );
#endif

#pragma section fileerror
_tal short FILEERROR (
    short               /* IN  */
    );

#pragma section fileinfo
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status FILEINFO (
    short ,              /* IN OPTIONAL  */
                         /* FILE NUMBER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* STATUS OF LAST OPERATION */
    short _ptr32 *,      /* IN/OUT OPTIONAL  */
                         /* FILE NAME */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* LOGICAL DEVICE NUMBER(S) */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* .<0>     DEMOUNTABLE */
                         /* .<4:9>   DEVICE TYPE */
                         /* .<10:15> DEVICE SUBTYPE */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* PHYSICAL RECORD SIZE (PRIMARY */
                         /* EXTENT SIZE FOR DISC FILES) */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* END OF FILE POINTER */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* NEXT RECORD POINTER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* LAST MODIFICATION TIMESTAMP */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILE CODE */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* SECONDARY EXTENT SIZE */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* CURRENT RECORD POINTER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* .<2>     UNSTRUCTURED ACCESS */
                         /* .<3:5>   ACCESS MODE */
                         /* .<6>     RESIDENT BUFFERS */
                         /* .<7>     RESERVED LCB'S */
                         /* .<8>     OPENED NOWAIT */
                         /* .<9:11>  EXCLUSION MODE */
                         /* .<12:15> NO-WAIT DEPTH */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* SUB-DEVICE NUMBER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILE OWNER */
    char _ptr32 *,       /* OUT OPTIONAL  */
                         /* SECURITY */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* NUMBER OF EXTS ALLOCATED */
    __int32_t _ptr32 *,  /* OUT OPTIONAL  */
                         /* FILE SIZE MAX */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* PARTITION SIZE */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* NUMBER OF PARTITIONS */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILE STRUCTURE */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* MAXEXTENTS VALUE             - DP2 ONLY */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* UNSTRUCTURED BUFFER SIZE     - DP2 ONLY */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILE ATTRIBUTES */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILE SYNC DEPTH */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* NEXT OPEN FILE NUMBER */
    );
#else
_tal _extensible _cc_status FILEINFO (
    short ,             /* IN OPTIONAL  */
                        /* FILE NUMBER */
    short _near *,      /* OUT OPTIONAL  */
                        /* STATUS OF LAST OPERATION */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* FILE NAME */
    short _near *,      /* OUT OPTIONAL  */
                        /* LOGICAL DEVICE NUMBER(S) */
    short _near *,      /* OUT OPTIONAL  */
                        /* .<0>     DEMOUNTABLE */
                        /* .<4:9>   DEVICE TYPE */
                        /* .<10:15> DEVICE SUBTYPE */
    short _near *,      /* OUT OPTIONAL  */
                        /* PHYSICAL RECORD SIZE (PRIMARY */
                        /* EXTENT SIZE FOR DISC FILES) */
    __int32_t _near *,  /* OUT OPTIONAL  */
                        /* END OF FILE POINTER */
    __int32_t _near *,  /* OUT OPTIONAL  */
                        /* NEXT RECORD POINTER */
    short _near *,      /* OUT OPTIONAL  */
                        /* LAST MODIFICATION TIMESTAMP */
    short _near *,      /* OUT OPTIONAL  */
                        /* FILE CODE */
    short _near *,      /* OUT OPTIONAL  */
                        /* SECONDARY EXTENT SIZE */
    __int32_t _near *,  /* OUT OPTIONAL  */
                        /* CURRENT RECORD POINTER */
    short _near *,      /* OUT OPTIONAL  */
                        /* .<2>     UNSTRUCTURED ACCESS */
                        /* .<3:5>   ACCESS MODE */
                        /* .<6>     RESIDENT BUFFERS */
                        /* .<7>     RESERVED LCB'S */
                        /* .<8>     OPENED NOWAIT */
                        /* .<9:11>  EXCLUSION MODE */
                        /* .<12:15> NO-WAIT DEPTH */
    short _near *,      /* OUT OPTIONAL  */
                        /* SUB-DEVICE NUMBER */
    short _near *,      /* OUT OPTIONAL  */
                        /* FILE OWNER */
    char _near *,       /* OUT OPTIONAL  */
                        /* SECURITY */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF EXTS ALLOCATED */
    __int32_t _near *,  /* OUT OPTIONAL  */
                        /* FILE SIZE MAX */
    short _near *,      /* OUT OPTIONAL  */
                        /* PARTITION SIZE */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF PARTITIONS */
    short _near *,      /* OUT OPTIONAL  */
                        /* FILE STRUCTURE */
    short _near *,      /* OUT OPTIONAL  */
                        /* MAXEXTENTS VALUE             - DP2 ONLY */
    short _near *,      /* OUT OPTIONAL  */
                        /* UNSTRUCTURED BUFFER SIZE     - DP2 ONLY */
    short _near *,      /* OUT OPTIONAL  */
                        /* FILE ATTRIBUTES */
    short _near *,      /* OUT OPTIONAL  */
                        /* FILE SYNC DEPTH */
    short _near *       /* OUT OPTIONAL  */
                        /* NEXT OPEN FILE NUMBER */
    );
 #endif

#pragma section fileinquire
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status FILEINQUIRE (
    short ,              /* IN OPTIONAL  */
    short _ptr32 *,      /* IN OPTIONAL  */
    short _ptr32 *,      /* IN  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *       /* OUT OPTIONAL  */
    );
#else
_tal _extensible _cc_status FILEINQUIRE (
    short ,             /* IN OPTIONAL  */
    short _near *,      /* IN OPTIONAL  */
    short _near *,      /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section filename_compare_
_tal _extensible short FILENAME_COMPARE_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short               /* IN  */
    );

#pragma section filename_decompose_
_tal _extensible short FILENAME_DECOMPOSE_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );


#pragma section filename_edit_
_tal _extensible short FILENAME_EDIT_ (
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section filename_findfinish_
_tal _extensible short FILENAME_FINDFINISH_ (
    short               /* IN  */
    );

#pragma section filename_findnext_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILENAME_FINDNEXT_ (
    short ,               /* IN  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* [0:4] */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short FILENAME_FINDNEXT_ (
    short ,             /* IN  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:4] */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section filename_findstart_
_tal _extensible short FILENAME_FINDSTART_ (
    short _far *,       /* OUT  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section filename_match_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILENAME_MATCH_ (
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short FILENAME_MATCH_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *        /* OUT OPTIONAL  */
    );
 #endif

#pragma section filename_resolve_
_tal _extensible short FILENAME_RESOLVE_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section filename_scan_
_tal _extensible short FILENAME_SCAN_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );


#pragma section filename_to_oldfilename_
_tal _extensible short FILENAME_TO_OLDFILENAME_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );

#pragma section filename_to_pathname_
_tal _extensible short FILENAME_TO_PATHNAME_ (
    const char _far *,  /* IN  */
                        /* FILENAME TO BE CONVERTED */
    short ,             /* IN  */
                        /* BYTE LENGTH OF FILENAME */
    char _far *,        /* OUT  */
                        /* BUFFER FOR RESULTING PATHNAME */
    short ,             /* IN  */
                        /* SIZE OF PATHNAME BUFFER */
    short _far *,       /* OUT  */
                        /* ACTUAL LENGTH OF PATHNAME (LESS NULL) */
    short ,             /* IN OPTIONAL  */
                        /* FEATURE CONTROLS */
    short _far *        /* IN/OUT OPTIONAL  */
    );

#pragma section filename_to_processhandle_
_tal _extensible short FILENAME_TO_PROCESSHANDLE_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *        /* OUT  */
                        /* [0:9] */
    );


#pragma section filename_unresolve_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILENAME_UNRESOLVE_ (
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN OPTIONAL  */
    const char _ptr32 *,  /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short FILENAME_UNRESOLVE_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section filerecinfo
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status FILERECINFO (
    short ,             /* IN OPTIONAL  */
                        /* FILE NUMBER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* CURRENT KEY TAG */
    char _ptr32 *,      /* OUT OPTIONAL  */
                        /* CURRENT KEY VALUE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* CURRENT KEY LENGTH */
    char _ptr32 *,      /* OUT OPTIONAL  */
                        /* CURRENT PRIMARY KEY VALUE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* CURRENT PRIMARY KEY LENGTH */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PARTITION WITH ERROR */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* TAG OF KEY WHICH CAUSED ERROR */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* .<11>    INDEX COMPRESSION */
                        /* .<12>    DATA COMPRESSION */
                        /* .<13:15> FILE TYPE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* LOGICAL RECORD LENGTH */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* BLOCK LENGTH */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* INDEXED SEQUENTIAL PARAMETERS */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* KEY ARRAY */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PARTITION PARAMETERS */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* FILE NAME */
    );
#else
_tal _extensible _cc_status FILERECINFO (
    short ,             /* IN OPTIONAL  */
                        /* FILE NUMBER */
    short _near *,      /* OUT OPTIONAL  */
                        /* CURRENT KEY TAG */
    char _near *,       /* OUT OPTIONAL  */
                        /* CURRENT KEY VALUE */
    short _near *,      /* OUT OPTIONAL  */
                        /* CURRENT KEY LENGTH */
    char _near *,       /* OUT OPTIONAL  */
                        /* CURRENT PRIMARY KEY VALUE */
    short _near *,      /* OUT OPTIONAL  */
                        /* CURRENT PRIMARY KEY LENGTH */
    short _near *,      /* OUT OPTIONAL  */
                        /* PARTITION WITH ERROR */
    short _near *,      /* OUT OPTIONAL  */
                        /* TAG OF KEY WHICH CAUSED ERROR */
    short _near *,      /* OUT OPTIONAL  */
                        /* .<11>    INDEX COMPRESSION */
                        /* .<12>    DATA COMPRESSION */
                        /* .<13:15> FILE TYPE */
    short _near *,      /* OUT OPTIONAL  */
                        /* LOGICAL RECORD LENGTH */
    short _near *,      /* OUT OPTIONAL  */
                        /* BLOCK LENGTH */
    short _near *,      /* OUT OPTIONAL  */
                        /* INDEXED SEQUENTIAL PARAMETERS */
    short _near *,      /* OUT OPTIONAL  */
                        /* KEY ARRAY */
    short _near *,      /* OUT OPTIONAL  */
                        /* PARTITION PARAMETERS */
    short _near *       /* IN OPTIONAL  */
                        /* FILE NAME */
    );
  #endif

#pragma section file_alterlist_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_ALTERLIST_ (
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* IN  */
    short ,               /* IN  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short FILE_ALTERLIST_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section file_awaitio64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
short _tal _extensible _callable FILE_AWAITIO64_(
    short     _ptr64 *,  /* IN/OUT       */
    long long _ptr64 *,  /* OUT OPTIONAL */
    __int32_t _ptr64 *,  /* OUT OPTIONAL */
    long long _ptr64 *,  /* OUT OPTIONAL */
    __int32_t         ,  /* IN OPTIONAL  */
    short     _ptr64 *   /* OUT OPTIONAL */
    );
#endif

#pragma section file_close_
_tal _extensible short FILE_CLOSE_ (
    short ,             /* IN  */
    short               /* IN OPTIONAL  */
    );

#pragma section file_close_chkpt_
_tal _extensible short FILE_CLOSE_CHKPT_ (
    short ,             /* IN  */
    short               /* IN OPTIONAL  */
    );

#pragma section file_complete_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_COMPLETE_ (
    short _ptr32 *,     /* OUT  */
                        /*   COMPLETION INFO FOR FILE COMPLETED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*   TIMOUT VALUE FOR WAIT FOR COMPLETION */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*   ARRAY OF FNUMS/FDS TO COMPLETE IF OVERRIDE */
    short ,             /* IN OPTIONAL  */
                        /*   NUMBER OF ELEMENTS IN COMPLETE_LIST */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /*   INDEX TO ELEMENT WITH ERROR IN COMPLETE_LIST */
    );
#else
_tal _extensible short FILE_COMPLETE_ (
    short _far *,       /* OUT  */
                        /*   COMPLETION INFO FOR FILE COMPLETED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*   TIMOUT VALUE FOR WAIT FOR COMPLETION */
    short _far *,       /* IN OPTIONAL  */
                        /*   ARRAY OF FNUMS/FDS TO COMPLETE IF OVERRIDE */
    short ,             /* IN OPTIONAL  */
                        /*   NUMBER OF ELEMENTS IN COMPLETE_LIST */
    short _far *        /* OUT OPTIONAL  */
                        /*   INDEX TO ELEMENT WITH ERROR IN COMPLETE_LIST */
    );
#endif



#pragma section file_completel_
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
_tal _extensible short FILE_COMPLETEL_ (
    short _far *,       /* OUT  */
                        /* COMPLETION INFO FOR FILE COMPLETED */
    __int32_t ,         /* IN OPTIONAL  */
                        /*   TIMOUT VALUE FOR WAIT FOR COMPLETION */
    short _far *,       /* IN OPTIONAL  */
                        /*   ARRAY OF FNUMS/FDS TO COMPLETE IF OVERRIDE */
    short ,             /* IN OPTIONAL  */
                        /*   NUMBER OF ELEMENTS IN COMPLETE_LIST */
    short _far *        /* OUT OPTIONAL  */
                        /*   INDEX TO ELEMENT WITH ERROR IN COMPLETE_LIST */
    );
#endif

#pragma section file_complete_getinfo_
_tal _extensible short FILE_COMPLETE_GETINFO_ (
    short _far *,       /* OUT  */
                        /*   ARRAY OF FDS/FNUMS SET */
    short ,             /* IN  */
                        /*   MAXIMUM NUMBER OF ELEMENTS TO BE RETURNED */
    short _far *        /* OUT OPTIONAL  */
                        /*   NUMBER OF ELEMENTS RETURNED IN INFO_LIST */
    );

#pragma section file_complete_set_
_tal _extensible short FILE_COMPLETE_SET_ (
    short _far *,       /* IN  */
                        /*  ARRAY OF FDS/FNUMS TO SET */
    short ,             /* IN  */
                        /*  NUMBER OF ELEMENTS */
    short _far *        /* OUT OPTIONAL  */
                        /*  INDEX OF BAD ELEMENT IF ERROR */
    );

#pragma section file_control64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_CONTROL64_ (
     short ,             /* IN  */
                         /* FILE NUMBER */
     short ,             /* IN  */
                         /* CONTROL NUMBER */
     short ,             /* IN  OPTIONAL */
                         /* PARAMETER */
     long long           /* IN OPTIONAL  */
                         /* NO-WAIT REQUEST TAG */);
#endif

#pragma section file_controlbuf64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_CONTROLBUF64_ (
     short ,             /* IN  */
                         /* FILE NUMBER */
     short ,             /* IN  */
                         /* CONTROL NUMBER */
     short _ptr64 *,     /* IN  */
                         /* CONTROL BUFFER */
     short ,             /* IN  */
                         /* NUMBER OF BYTES IN CONTROL BUFFER */
     short _ptr64 *,     /* OUT OPTIONAL  */
                         /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
     long long           /* IN OPTIONAL  */
                         /* NO-WAIT REQUEST TAG */);
#endif

#pragma section file_createlist_
_tal _extensible short FILE_CREATELIST_ (
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    unsigned short ,    /* IN  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section file_create_
_tal _extensible short FILE_CREATE_ (
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    unsigned short ,    /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section file_fdgettype_
#if ( (_TANDEM_ARCH_ == 2 && __J_Series_RVU >= 622) || \
      (_TANDEM_ARCH_ == 3 && __L_Series_RVU >= 1802) )
_tal _callable int FILE_FDGETTYPE_ (
    int                 /* IN */
                        /* FILE DESCRIPTOR */
    );
#endif

#pragma section filename_findnext64_
#if (_TANDEM_ARCH_ > 1 )
_tal _extensible short FILENAME_FINDNEXT64_ (
    short ,               /* IN  */
    char _ptr64 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* [0:4] */
    long long             /* IN OPTIONAL  */
    );
#endif

#pragma section file_getinfobyname_
#include <tnsint.h>
_tal _extensible short FILE_GETINFOBYNAME_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:4] */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t,          /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL */
    );

#pragma section file_getinfolistbyname_
_tal _extensible short FILE_GETINFOLISTBYNAME_ (
    const char _far *,       /* IN  */
    short ,                  /* IN  */
    short _far *,            /* IN  */
    short ,                  /* IN  */
    short _far *,            /* OUT  */
    unsigned short ,         /* IN  */
    unsigned short _far *,   /* OUT OPTIONAL  */
    short _far *             /* OUT OPTIONAL  */
    );

#pragma section file_getinfolist_
_tal _extensible short FILE_GETINFOLIST_ (
    short ,                  /* IN  */
    short _far *,            /* IN  */
    short ,                  /* IN  */
    short _far *,            /* OUT  */
    unsigned short ,         /* IN  */
    unsigned short _far *,   /* OUT OPTIONAL  */
    short _far *             /* OUT OPTIONAL  */
    );

#pragma section file_getinfo_
_tal _extensible short FILE_GETINFO_ (
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:4] */
    short _far *        /* out optional, new in oss */
    );

#pragma section file_getlockinfo_
_tal _extensible short FILE_GETLOCKINFO_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* IN OPTIONAL  */
    short _far *,       /* IN/OUT  */
                        /* [0:9] */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );


#pragma section file_getopeninfo_
#if ( _TANDEM_ARCH_ > 1 )
    _tal _extensible short FILE_GETOPENINFO_ (
    const char _ptr32 *,   /* IN  */
    short ,                /* IN  */
    long long _ptr32 *,    /* IN/OUT  */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* [0:9] */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* [0:9] */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    char _ptr32 *,         /* OUT OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short _ptr32 *         /* OUT OPTIONAL  */
    );
 #else
    _tal _extensible short FILE_GETOPENINFO_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    long  long _far *,  /* IN/OUT  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char  _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
  #endif

#pragma section file_getreceiveinfo_
_tal _extensible short FILE_GETRECEIVEINFO_ (
    short _far *,       /* OUT  */
    short _far *        /* OUT  */
    );

#pragma section file_getreceiveinfol_
#if (_TANDEM_ARCH_ != 1)
_tal _extensible short FILE_GETRECEIVEINFOL_ (
    short _far *        /* OUT  */
    );
#endif

#pragma section file_getsyncinfo_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_GETSYNCINFO_ (
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short FILE_GETSYNCINFO_ (
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section file_lockfile64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_LOCKFILE64_(
    short      /*filenum*/,
    long long  /*tag*/);
#endif

#pragma section file_lockrec64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_LOCKREC64_(
    short      /*filenum*/,
    long long  /*tag*/);
#endif

#pragma section file_open_
#include <tnsint.h>
_tal _extensible short FILE_OPEN_ (
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    __int32_t           /* IN OPTIONAL  */
    );

#pragma section file_open_chkpt_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_OPEN_CHKPT_ (
    short ,               /* IN  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short FILE_OPEN_CHKPT_ (
    short ,             /* IN  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section file_purge_
_tal _extensible short FILE_PURGE_ (
    const char _far *,  /* IN  */
    short               /* IN  */
    );

#pragma section file_read64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_READ64_ (
     short ,                /* IN  */
     char _ptr64 *,         /* OUT  */
     __int32_t,             /* IN  */
     __int32_t  _ptr64 *,   /* OUT OPTIONAL  */
     long long              /* IN OPTIONAL  */
     );
#endif

#pragma section file_readlock64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1 )
_tal _resident _variable _callable
short FILE_READLOCK64_(
    short              /*filenum*/,
    char      _ptr64 * /*buffer*/,
    __int32_t          /*count*/,
    __int32_t _ptr64 * /*countxfered*/,
    long long          /*tag*/);
#endif

#pragma section file_readupdate64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1 )
_tal _extensible _callable
short FILE_READUPDATE64_ (
     short ,                /* IN  */
     char _ptr64 *,         /* OUT  */
     __int32_t ,            /* IN  */
     __int32_t  _ptr64 *,   /* OUT OPTIONAL  */
     long long              /* IN OPTIONAL  */
     );
#endif

#pragma section file_readupdatelock64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_READUPDATELOCK64_(
     short ,                /* IN  */
     char _ptr64 *,         /* OUT  */
     __int32_t ,            /* IN  */
     __int32_t  _ptr64 *,   /* OUT OPTIONAL  */
     long long              /* IN OPTIONAL  */
     );
#endif


#pragma section file_rename_
_tal _extensible short FILE_RENAME_ (
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short               /* IN  */
    );

#pragma section file_reply64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_REPLY64_ (
      const char _ptr64 *, /* IN OPTIONAL  */
      __int32_t,           /* IN OPTIONAL  */
      __int32_t _ptr64 *,  /* OUT OPTIONAL  */
      short,               /* IN OPTIONAL  */
      short                /* IN OPTIONAL  */
      );
#endif

#pragma section file_restoreposition_
_tal _extensible short FILE_RESTOREPOSITION_ (
    short ,               /* IN  */
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *,       /* IN  */
#else
    short _far *,         /* IN  */
#endif
    short                 /* IN  */
    );

#pragma section file_saveposition_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_SAVEPOSITION_ (
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short FILE_SAVEPOSITION_ (
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section file_setkey_
_tal _extensible short FILE_SETKEY_ (
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section file_setlasterror_
#if (_TANDEM_ARCH_ != 1)
_tal _extensible short FILE_SETLASTERROR_ (
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
);
#endif

#pragma section file_setmodenowait64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_SETMODENOWAIT64_(
     short ,             /* IN  */
                         /* FILE NUMBER */
     short ,             /* IN  */
                         /* NUMBER OF CHARACTERISTIC TO BE CHANGED */
     short ,             /* IN OPTIONAL  */
                         /* FIRST PARAMETER */
     short ,             /* IN OPTIONAL  */
                         /* SECOND PARAMETER */
     short _ptr64 *,     /* OUT OPTIONAL  */
                         /* ARRAY FOR RETURNING OLD VALUE */
     long long           /* IN OPTIONAL  */
                         /* SPECIFIED TAG FOR NOWAIT REQUESTS */
     );
#endif

#pragma section file_setposition_
_tal _extensible short FILE_SETPOSITION_ (
    short ,             /* IN  */
    long long           /* IN  */
    );

#pragma section file_setsyncinfo_
_tal _extensible short FILE_SETSYNCINFO_ (
    short ,               /* IN  */
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *,       /* IN  */
#else
    short _far *,         /* IN  */
#endif
    short                 /* IN  */
    );

#pragma section file_unlockfile64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_UNLOCKFILE64_(
    short      /*filenum*/,
    long long  /*tag*/);
#endif

#pragma section file_unlockrec64_
#if (_TANDEM_ARCH_ > 1)
_tal _variable _callable
short FILE_UNLOCKREC64_(
    short      /*filenum*/,
    long long  /*tag*/);
#endif

#pragma section file_write64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_WRITE64_(
     short ,              /* IN  */
     const char _ptr64 *, /* IN  */
     __int32_t,           /* IN  */
     __int32_t _ptr64 *,  /* OUT OPTIONAL  */
     long long            /* IN OPTIONAL  */
     );
#endif

#pragma section file_writeread_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FILE_WRITEREAD_ (
    short ,             /* IN  */
    char _ptr32 *,      /* IN  */
    char _ptr32 *,      /* OUT */
    __int32_t,          /* IN */
    __int32_t,          /* IN */
    __int32_t _ptr32 *, /* OUT OPTIONAL */
    __int32_t           /* IN OPTIONAL */
    );
#else
_tal _extensible short FILE_WRITEREAD_ (
    short ,             /* IN  */
    char _far *,        /* IN  */
    char _far *,        /* OUT */
    __int32_t,          /* IN */
    __int32_t,          /* IN */
    __int32_t _far *,   /* OUT OPTIONAL */
    __int32_t           /* IN OPTIONAL */
    );
#endif

#pragma section file_writeread64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_WRITEREAD64_(
     short ,                  /* IN  */
     const char _ptr64 *,     /* IN  */
     char _ptr64 *,           /* OUT, OPTIONAL*/
     __int32_t,               /* IN  */
     __int32_t,               /* IN  */
     __int32_t _ptr64 *,      /* OUT OPTIONAL  */
     long long                /* IN OPTIONAL  */);
#endif

#pragma section file_writeupdate64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_WRITEUPDATE64_(
     short ,             /* IN  */
     const char _ptr64 *,/* IN  */
     __int32_t,          /* IN  */
     __int32_t _ptr64 *, /* OUT OPTIONAL  */
     long long           /* IN OPTIONAL  */
     );
#endif

#pragma section file_writeupdateunlock64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _callable
short FILE_WRITEUPDATEUNLOCK64_(
     short ,             /* IN  */
     const char _ptr64 *,/* IN  */
     __int32_t,          /* IN  */
     __int32_t _ptr64 *, /* OUT OPTIONAL  */
     long long           /* IN OPTIONAL  */
     );
#endif

#pragma section fixstring
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status FIXSTRING (
    char _ptr32 *,      /* IN  */
                        /* STRING OF COMMANDS */
    short ,             /* IN  */
                        /* LENGTH OF COMMAND STRING */
    char _ptr32 *,      /* IN/OUT  */
                        /* STRING TO BE FIXED */
    short _ptr32 *,     /* IN/OUT  */
                        /* LENGTH OF STRING TO BE FIXED */
    short ,             /* IN OPTIONAL  */
                        /* MAX ALLOWABLE LENGTH OF DATA */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* RETURNS 1 IF DATA HAS BEEN MODIFIED */
    );
#else
_tal _variable _cc_status FIXSTRING (
    char _near *,       /* IN  */
                        /* STRING OF COMMANDS */
    short ,             /* IN  */
                        /* LENGTH OF COMMAND STRING */
    char _near *,       /* IN/OUT  */
                        /* STRING TO BE FIXED */
    short _near *,      /* IN/OUT  */
                        /* LENGTH OF STRING TO BE FIXED */
    short ,             /* IN OPTIONAL  */
                        /* MAX ALLOWABLE LENGTH OF DATA */
    short _near *       /* OUT OPTIONAL  */
                        /* RETURNS 1 IF DATA HAS BEEN MODIFIED */
    );
#endif

#pragma section fname32collapse
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FNAME32COLLAPSE (
    const char _ptr32 *,  /* IN  */
    char _ptr32 *         /* OUT  */
    );
#else
_tal _extensible short FNAME32COLLAPSE (
    const char _far *,  /* IN  */
    char _far *         /* OUT  */
    );
#endif

#pragma section fname32expand
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FNAME32EXPAND (
    const char _ptr32 *,  /* IN  */
    char _ptr32 *,        /* OUT  */
    const char _ptr32 *   /* IN  */
    );
#else
_tal _extensible short FNAME32EXPAND (
    const char _far *,  /* IN  */
    char _far *,        /* OUT  */
    const char _far *   /* IN  */
    );
 #endif

#pragma section fname32tofname
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FNAME32TOFNAME (
    const char _ptr32 *,  /* IN  */
    char _ptr32 *         /* OUT  */
    );
#else
_tal _extensible short FNAME32TOFNAME (
    const char _far *,  /* IN  */
    char _far *         /* OUT  */
    );
#endif

#pragma section fnamecollapse
_tal short FNAMECOLLAPSE (
    short _near *,      /* IN  */
                        /* INTERNAL FORM OF NAME. */
    char _near *        /* OUT  */
                        /* EXTERNAL FORM OF NAME. */
    );

#pragma section fnamecompare
#if (_TANDEM_ARCH_ > 1)
_tal short FNAMECOMPARE (
    short _ptr32 *,      /* IN  */
                         /* 1ST FILE NAME TO COMPARE */
    short _ptr32 *       /* IN  */
                         /* 2ND FILE NAME TO COMPARE */
    );
#else
_tal short FNAMECOMPARE (
    short _near *,      /* IN  */
                        /* 1ST FILE NAME TO COMPARE */
    short _near *       /* IN  */
                        /* 2ND FILE NAME TO COMPARE */
    );
#endif

#pragma section fnameexpand
_tal short FNAMEEXPAND (
    char _near *,       /* IN  */
    short _near *,      /* OUT  */
    short _near *       /* IN  */
    );

#pragma section fnametofname32
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FNAMETOFNAME32 (
    const char _ptr32 *,  /* IN  */
    char _ptr32 *         /* OUT  */
    );
#else
_tal _extensible short FNAMETOFNAME32 (
    const char _far *,  /* IN  */
    char _far *         /* OUT  */
    );
#endif

#pragma section formatconvert
#if (_TANDEM_ARCH_ > 1)
_tal short FORMATCONVERT (
    char _ptr32 *,      /* OUT  */
                        /* RESULTANT INTERNAL FORMAT PLACED HERE */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    char _ptr32 *,      /* IN  */
                        /* FORMAT IN EXTERNAL (ASCII) FORM */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    short _ptr32 *,     /* OUT  */
                        /* ARRAY OF SCALE VALUES */
    short _ptr32 *,     /* IN/OUT  */
                        /* ON CALL:  MAXIMUM # OF SCALE VALUES */
                        /* ON RETURN:  NUMBER OF DATA EDITORS */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#else
_tal short FORMATCONVERT (
    char _near *,       /* OUT  */
                        /* RESULTANT INTERNAL FORMAT PLACED HERE */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    char _near *,       /* IN  */
                        /* FORMAT IN EXTERNAL (ASCII) FORM */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    short _near *,      /* OUT  */
                        /* ARRAY OF SCALE VALUES */
    short _near *,      /* IN/OUT  */
                        /* ON CALL:  MAXIMUM # OF SCALE VALUES */
                        /* ON RETURN:  NUMBER OF DATA EDITORS */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#endif

#pragma section formatconvertx
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FORMATCONVERTX (
    char _ptr32 *,        /* OUT  */
                          /* RESULTANT INTERNAL FORMAT PLACED HERE */
    short ,               /* IN  */
                          /* SIZE OF ABOVE IN BYTES */
    const char _ptr32 *,  /* IN  */
                          /* FORMAT IN EXTERNAL (ASCII) FORM */
    short ,               /* IN  */
                          /* SIZE OF ABOVE IN BYTES */
    short _ptr32 *,       /* OUT  */
                          /* ARRAY OF SCALE VALUES */
    short _ptr32 *,       /* IN/OUT  */
                          /* ON CALL:  MAXIMUM # OF SCALE VALUES */
                          /* ON RETURN:  NUMBER OF DATA EDITORS */
    short                 /* IN  */
                          /* VARIOUS OPTION FLAGS */
    );
#else
_tal _extensible short FORMATCONVERTX (
    char _far *,        /* OUT  */
                        /* RESULTANT INTERNAL FORMAT PLACED HERE */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    const char _far *,  /* IN  */
                        /* FORMAT IN EXTERNAL (ASCII) FORM */
    short ,             /* IN  */
                        /* SIZE OF ABOVE IN BYTES */
    short _far *,       /* OUT  */
                        /* ARRAY OF SCALE VALUES */
    short _far *,       /* IN/OUT  */
                        /* ON CALL:  MAXIMUM # OF SCALE VALUES */
                        /* ON RETURN:  NUMBER OF DATA EDITORS */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#endif

#pragma section formatcrtfield
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short FORMATCRTFIELD (
    __int32_t _ptr32 *,  /* IN/OUT  */
    __int32_t _ptr32 *,  /* IN/OUT  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT  */
    short _ptr32 *,      /* OUT  */
    char _ptr32 *,       /* IN OPTIONAL  */
    char _ptr32 *,       /* IN OPTIONAL  */
    short                /* IN OPTIONAL  */
    );
#else
_tal _variable short FORMATCRTFIELD (
    __int32_t _near *,  /* IN/OUT  */
    __int32_t _near *,  /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _near *,      /* OUT  */
    short _near *,      /* OUT  */
    char _near *,       /* IN OPTIONAL  */
    char _near *,       /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section formatdata
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ FORMATDATA;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal short FORMATDATA (
    char _near *,       /* IN/OUT  */
                        /* RESULT/SOURCE BUFFERS */
    short ,             /* IN  */
                        /* LENGTH OF EACH OF ABOVE */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short _near *,      /* OUT  */
                        /* HIGH WATER MARK IN DESTINATION BUFFERS */
    short _near *,      /* IN  */
                        /* CONVERTED FORMAT, WORD ALINED */
    short _near *,      /* IN  */
                        /* 4 OR 5 WORD DESCRIPTIONS OF DATA ITEMS */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section formatdatax
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FORMATDATAX (
    char _ptr32 *,      /* IN/OUT  */
                        /* RESULT/SOURCE BUFFERS */
    short ,             /* IN  */
                        /* LENGTH OF EACH OF THE ABOVE */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short _ptr32 *,     /* OUT  */
                        /* HIGH WATER MARK IN DESTINATION BUFFERS */
    short _ptr32 *,     /* IN  */
                        /* CONVERTED FORMAT, WORD ALIGNED */
    short _ptr32 *,     /* IN  */
                        /* 5 OR 7 WORD DESCRIPTIONS OF DATA ITEMS */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#else
_tal _extensible short FORMATDATAX (
    char _far *,        /* IN/OUT  */
                        /* RESULT/SOURCE BUFFERS */
    short ,             /* IN  */
                        /* LENGTH OF EACH OF THE ABOVE */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short _far *,       /* OUT  */
                        /* HIGH WATER MARK IN DESTINATION BUFFERS */
    short _far *,       /* IN  */
                        /* CONVERTED FORMAT, WORD ALIGNED */
    short _far *,       /* IN  */
                        /* 5 OR 7 WORD DESCRIPTIONS OF DATA ITEMS */
    short ,             /* IN  */
                        /* # OF OCCURANCES OF ABOVE */
    short               /* IN  */
                        /* VARIOUS OPTION FLAGS */
    );
#endif

#pragma section formatitibuffer
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short FORMATITIBUFFER (
    __int32_t _ptr32 *,  /* IN/OUT  */
    __int32_t _ptr32 *,  /* IN/OUT  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT  */
    short _ptr32 *,      /* OUT  */
    char _ptr32 *,       /* IN OPTIONAL  */
    char _ptr32 *,       /* IN OPTIONAL  */
    short                /* IN OPTIONAL  */
    );
#else
_tal _variable short FORMATITIBUFFER (
    __int32_t _near *,  /* IN/OUT  */
    __int32_t _near *,  /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _near *,      /* OUT  */
    short _near *,      /* OUT  */
    char _near *,       /* IN OPTIONAL  */
    char _near *,       /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section formatter
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short FORMATTER (
    short ,              /* IN  */
                         /* # OF BYTES IN EXTERNAL FORMAT */
    short _ptr32 *,      /* IN  */
                         /* REQUESTOR INFORMATION FOR $RECV READ */
    __int32_t ,          /* IN  */
                         /* MAX WAIT TIME (TERMINAL, $RECV) */
    char _ptr32 *,       /* IN  */
                         /* FOR WRITEREADS (TERMINAL, PROCESS)\_ */
    /* INT     MESSAGENUMBER;       ? FOR QUEUED REPLYS (WRITE $RECV)   / */
    short ,              /* IN  */
                         /* LENGTH OF ABOVE                  \_ */
    /* INT     REPLYCODE;           ? SETS FS ERROR CODE (WRITE $RECV) / */
    char _ptr32 *,       /* IN/OUT  */
                         /* DESTINATION STRING */
    short ,              /* IN/OUT  */
                         /* LENGTH OF ABOVE */
    short ,              /* IN/OUT  */
                         /* # OF OCCURANCES OF ABOVE */
    short _ptr32 *,      /* IN/OUT  */
                         /* LENGTH OF READ / HIGH WATER ON WRITE */
    short _ptr32 *,      /* IN/OUT  */
                         /* FORMAT IN INTERNAL FORM  \_ */
    /* STRING .EXTFORMAT;           ? FORMAT IN EXTERNAL FORM  / */
    short ,              /* IN/OUT  */
                         /* FORTRAN UNIT # */
    short ,              /* IN/OUT  */
                         /* OPTION SELECTION */
    short _ptr32 *,      /* IN/OUT  */
                         /* "OWN" STORAGE FOR OPEN ACCESS */
    short _ptr32 *,      /* IN/OUT  */
                         /* 4 WORD ENTRIES FOR EACH ELEMENT */
    short                /* IN/OUT  */
                         /* # OF ENTRIES OF ABOVE */
    );
#else
_tal _variable short FORMATTER (
    short ,             /* IN  */
                        /* # OF BYTES IN EXTERNAL FORMAT */
    short _near *,      /* IN  */
                        /* REQUESTOR INFORMATION FOR $RECV READ */
    __int32_t ,         /* IN  */
                        /* MAX WAIT TIME (TERMINAL, $RECV) */
    char _near *,       /* IN  */
                        /* FOR WRITEREADS (TERMINAL, PROCESS)\_ */
    /* INT     MESSAGENUMBER;       ? FOR QUEUED REPLYS (WRITE $RECV)   / */
    short ,             /* IN  */
                        /* LENGTH OF ABOVE                  \_ */
    /* INT     REPLYCODE;           ? SETS FS ERROR CODE (WRITE $RECV) / */
    char _near *,       /* IN/OUT  */
                        /* DESTINATION STRING */
    short ,             /* IN/OUT  */
                        /* LENGTH OF ABOVE */
    short ,             /* IN/OUT  */
                        /* # OF OCCURANCES OF ABOVE */
    short _near *,      /* IN/OUT  */
                        /* LENGTH OF READ / HIGH WATER ON WRITE */
    short _near *,      /* IN/OUT  */
                        /* FORMAT IN INTERNAL FORM  \_ */
    /* STRING .EXTFORMAT;           ? FORMAT IN EXTERNAL FORM  / */
    short ,             /* IN/OUT  */
                        /* FORTRAN UNIT # */
    short ,             /* IN/OUT  */
                        /* OPTION SELECTION */
    short _near *,      /* IN/OUT  */
                        /* "OWN" STORAGE FOR OPEN ACCESS */
    short _near *,      /* IN/OUT  */
                        /* 4 WORD ENTRIES FOR EACH ELEMENT */
    short               /* IN/OUT  */
                        /* # OF ENTRIES OF ABOVE */
    );
#endif

#pragma section formatterx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FORMATTERX (
    short ,               /* IN  */
                          /* # OF BYTES IN EXTERNAL FORMAT */
    short _ptr32 *,       /* IN  */
                          /* REQUESTOR INFORMATION FOR $RECV READ */
    __int32_t ,           /* IN  */
                          /* MAX WAIT TIME (TERMINAL, $RECV) */
    char _ptr32 *,        /* IN  */
                          /* FOR WRITEREADS (TERMINAL, PROCESS)\_ */
    /* INT         MESSAGENUMBER;   ? FOR QUEUED REPLYS (WRITE $RECV)   / */
    short ,               /* IN  */
                          /* LENGTH OF ABOVE                  \_ */
    /* INT         REPLYCODE;       ? SETS FS ERROR CODE (WRITE $RECV) / */
    char _ptr32 *,        /* IN/OUT  */
                          /* DESTINATION STRING */
    short ,               /* IN/OUT  */
                          /* LENGTH OF ABOVE */
    short ,               /* IN/OUT  */
                          /* # OF OCCURANCES OF ABOVE */
    short _ptr32 *,       /* IN/OUT  */
                          /* LENGTH OF READ / HIGH WATER ON WRITE */
    short _ptr32 *,       /* IN/OUT  */
                          /* FORMAT IN INTERNAL FORM (P REL) \_ */
    /* STRING .ext EXTFORMAT;       ? FORMAT IN EXTERNAL FORM (G REL) / */
    short ,               /* IN/OUT  */
                          /* FORTRAN UNIT # */
    short ,               /* IN/OUT  */
                          /* OPTION SELECTION */
    short _ptr32 *,       /* IN/OUT  */
                          /* "OWN" STORAGE FOR OPEN ACCESS */
    short _ptr32 *,       /* IN/OUT  */
                          /* 5 OR 7 WORD ENTRY FOR EACH ITEM */
    short                 /* IN/OUT  */
                          /* # OF ENTRIES OF ABOVE */
    );
#else
_tal _extensible short FORMATTERX (
    short ,             /* IN  */
                        /* # OF BYTES IN EXTERNAL FORMAT */
    short _far *,       /* IN  */
                        /* REQUESTOR INFORMATION FOR $RECV READ */
    __int32_t ,         /* IN  */
                        /* MAX WAIT TIME (TERMINAL, $RECV) */
    char _far *,        /* IN  */
                        /* FOR WRITEREADS (TERMINAL, PROCESS)\_ */
    /* INT         MESSAGENUMBER;   ? FOR QUEUED REPLYS (WRITE $RECV)   / */
    short ,             /* IN  */
                        /* LENGTH OF ABOVE                  \_ */
    /* INT         REPLYCODE;       ? SETS FS ERROR CODE (WRITE $RECV) / */
    char _far *,        /* IN/OUT  */
                        /* DESTINATION STRING */
    short ,             /* IN/OUT  */
                        /* LENGTH OF ABOVE */
    short ,             /* IN/OUT  */
                        /* # OF OCCURANCES OF ABOVE */
    short _far *,       /* IN/OUT  */
                        /* LENGTH OF READ / HIGH WATER ON WRITE */
    short _far *,       /* IN/OUT  */
                        /* FORMAT IN INTERNAL FORM (P REL) \_ */
    /* STRING .ext EXTFORMAT;       ? FORMAT IN EXTERNAL FORM (G REL) / */
    short ,             /* IN/OUT  */
                        /* FORTRAN UNIT # */
    short ,             /* IN/OUT  */
                        /* OPTION SELECTION */
    short _far *,       /* IN/OUT  */
                        /* "OWN" STORAGE FOR OPEN ACCESS */
    short _far *,       /* IN/OUT  */
                        /* 5 OR 7 WORD ENTRY FOR EACH ITEM */
    short               /* IN/OUT  */
                        /* # OF ENTRIES OF ABOVE */
    );
#endif

#pragma section ftm_begin_group_req_
#include <tnsint.h>
_tal _extensible short FTM_BEGIN_GROUP_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
                        /*  grouping threshold */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_cancel_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CANCEL_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_CANCEL_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_cancel_ind_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CANCEL_IND_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_CANCEL_IND_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_cancel_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CANCEL_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
    /*  summarizes info available in diagnostic parameter */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_CANCEL_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
    /*  summarizes info available in diagnostic parameter */
    short _far *,       /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_cancel_rsp_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CANCEL_RSP_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
    /*  summarizes info available in diagnostic parameter */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_CANCEL_RSP_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
    /*  summarizes info available in diagnostic parameter */
    short _far *,       /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_change_attrib_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CHANGE_ATTRIB_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                        /*  contains the new values for the file */
                        /*  attributes that were changed. */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    short _ptr32 *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_CHANGE_ATTRIB_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  contains the new values for the file */
                        /*  attributes that were changed. */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_change_attrib_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CHANGE_ATTRIB_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  contains the file attributes to be changed */
                        /*  and the new values for the attributes */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_CHANGE_ATTRIB_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  contains the file attributes to be changed */
                        /*  and the new values for the attributes */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_close_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CLOSE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_CLOSE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_close_req_
#include <tnsint.h>
_tal _extensible short FTM_CLOSE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_create_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CREATE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  indicates if the Responder established the */
                          /*  File Selection regime as requested. */
                          /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                          /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  defines the file attributes associated with */
                          /*  the created file. */
                          /*  (ZFTM-DDL-CREATE-ATTRIB) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_CREATE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  File Selection regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  defines the file attributes associated with the */
                        /*  created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_create_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_CREATE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  defines the file attributes associated with the */
                        /*  created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB) */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  defines the action taken if the named file */
                        /*  already exists. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  password of the user defined by the initiator */
                        /*  id parameter on FTM_INITIALIZE_REQ_ call. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  following file creation, this parameter */
                        /*  establishes the access available in the select */
                        /*  regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the account to which costs incurred */
                        /*  during the regime being established are to be */
                        /*  charged. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_CREATE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  defines the file attributes associated with the */
                        /*  created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB) */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  defines the action taken if the named file */
                        /*  already exists. */
    short _far *,       /* IN OPTIONAL  */
                        /*  password of the user defined by the initiator */
                        /*  id parameter on FTM_INITIALIZE_REQ_ call. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _far *,       /* IN OPTIONAL  */
                        /*  following file creation, this parameter */
                        /*  establishes the access available in the select */
                        /*  regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the account to which costs incurred */
                        /*  during the regime being established are to be */
                        /*  charged. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_data_end_ind_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DATA_END_IND_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_DATA_END_IND_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_data_end_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DATA_END_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN OPTIONAL  */
    /*  summarizes info available in diagnostic parameter */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_DATA_END_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN OPTIONAL  */
    /*  summarizes info available in diagnostic parameter */
    short _far *,       /* IN OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_data_ind_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DATA_IND_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t ,           /* IN  */
    /*  specifies the size, in octets, of the buffer used */
                          /*  in retrieving data^value. */
    char _ptr32 *,        /* OUT OPTIONAL  */
                          /*  contains the data sent to or returned from the */
                          /*  remote responder. */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  indicates that more data is available. */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  specifies the offset of the next octet to be */
                          /*  returned from MAP's internal data area. */
    __int32_t             /* IN OPTIONAL  */
                          /*  specifies the start position, in octets, of */
                          /*  the first octet to be returned by */
                          /*  FTM_DATA_IND_. */
    );
#else
_tal _extensible short FTM_DATA_IND_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
    /*  specifies the size, in octets, of the buffer used */
                        /*  in retrieving data^value. */
    char _far *,        /* OUT OPTIONAL  */
                        /*  contains the data sent to or returned from the */
                        /*  remote responder. */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates that more data is available. */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  specifies the offset of the next octet to be */
                        /*  returned from MAP's internal data area. */
    __int32_t           /* IN OPTIONAL  */
                        /*  specifies the start position, in octets, of the */
                        /*  first octet to be returned by FTM_DATA_IND_. */
    );
#endif

#pragma section ftm_data_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DATA_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    char _ptr32 *,      /* IN  */
                        /*  contains the data to be sent to the */
                        /*  remote responder. */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_DATA_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    char _far *,        /* IN  */
                        /*  contains the data to be sent to the */
                        /*  remote responder. */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_delete_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DELETE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  conveys info on the costs attributed to the */
                          /*  account during the regime which is being */
                          /*  released. */
                          /*  (ZFTM-DDL-CHARGING) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_DELETE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  conveys info on the costs attributed to the */
                        /*  account during the regime which is being */
                        /*  released. */
                        /*  (ZFTM-DDL-CHARGING) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_delete_req_
#include <tnsint.h>
_tal _extensible short FTM_DELETE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_deselect_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_DESELECT_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  conveys info on the costs attributed to the */
                          /*  account during the regime which is being */
                          /*  released. */
                          /*  (ZFTM-DDL-CHARGING) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_DESELECT_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  conveys info on the costs attributed to the */
                        /*  account during the regime which is being */
                        /*  released. */
                        /*  (ZFTM-DDL-CHARGING) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_deselect_req_
#include <tnsint.h>
_tal _extensible short FTM_DESELECT_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_end_group_req_
#include <tnsint.h>
_tal _extensible short FTM_END_GROUP_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_erase_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_ERASE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_ERASE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_erase_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_ERASE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_ERASE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_file_change_attrib_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_FILE_CHANGE_ATTRIB_ (
    short _ptr32 *,     /* IN  */
                        /*  the Guardian process name of the Application */
    /*  Manager to use when establishing the association */
                        /*  (ZAPS-DDL-FILENAME) */
    short _ptr32 *,     /* IN  */
                        /*  name of the file whose attributes are to be */
                        /*  changed. */
                        /*  (ZAPS-DDL-CHAR128) */
    short _ptr32 *,     /* IN/OUT  */
                        /*  contains the file attributes to be changed and */
                        /*  the new values they are to be changed to. */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  common name and/or OSI address of the remote */
                        /*  application entity. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /*  optional paramters used when accessing the */
                        /*  remote responder. */
                        /*  (ZFTM-DDL-FILE-PARAMS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  CEPI of the connection used for this service. */
    short ,             /* IN OPTIONAL  */
                        /*  sets whether the connection operates in wait */
                        /*  or nowaited mode. */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_FILE_CHANGE_ATTRIB_ (
    short _far *,       /* IN  */
                        /*  the Guardian process name of the Application */
    /*  Manager to use when establishing the association */
                        /*  (ZAPS-DDL-FILENAME) */
    short _far *,       /* IN  */
                        /*  name of the file whose attributes are to be */
                        /*  changed. */
                        /*  (ZAPS-DDL-CHAR128) */
    short _far *,       /* IN/OUT  */
                        /*  contains the file attributes to be changed and */
                        /*  the new values they are to be changed to. */
                        /*  (ZFTM-DDL-CHANGE-ATTRIB) */
    short _far *,       /* IN OPTIONAL  */
                        /*  common name and/or OSI address of the remote */
                        /*  application entity. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    short _far *,       /* IN/OUT OPTIONAL  */
                        /*  optional paramters used when accessing the */
                        /*  remote responder. */
                        /*  (ZFTM-DDL-FILE-PARAMS) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  CEPI of the connection used for this service. */
    short ,             /* IN OPTIONAL  */
                        /*  sets whether the connection operates in wait */
                        /*  or nowaited mode. */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_file_close_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_FILE_CLOSE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  conveys info on the costs attributed to the */
                          /*  account during the regime which is being */
                          /*  released. */
                          /*  (ZFTM-DDL-CHARGING) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_FILE_CLOSE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  conveys info on the costs attributed to the */
                        /*  account during the regime which is being */
                        /*  released. */
                        /*  (ZFTM-DDL-CHARGING) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_file_close_req_
#include <tnsint.h>
_tal _extensible short FTM_FILE_CLOSE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  indicates if the file should be deleted after */
                        /*  it is closed. */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_file_open_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_FILE_OPEN_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  indicates if the Responder established the */
                          /*  File Open regime as requested. */
                          /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                          /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  is the name of the opened file as returned by */
                          /*  the remote responder. */
                          /*  (ZAPS-DDL-CHAR128) */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  defines the file attributes associated with */
                          /*  the created file. */
                          /*  (ZFTM-DDL-CREATE-ATTRIB-HL) */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  returns the contents type of the file that was */
                          /*  opened. */
                          /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_FILE_OPEN_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  File Open regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  is the name of the opened file as returned by */
                        /*  the remote responder. */
                        /*  (ZAPS-DDL-CHAR128) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  defines the file attributes associated with */
                        /*  the created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB-HL) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the contents type of the file that was */
                        /*  opened. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_file_open_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_FILE_OPEN_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  is the name of the file to be opened. */
                        /*  (ZAPS-DDL-CHAR128) */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  defines if an existing file should be */
                        /*  selected or a new file created, and if new */
                        /*  file created, what the file attributes should */
                        /*  be. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  following the file creation, this parameter */
                        /*  establishes the access available in the */
                        /*  File Selection regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  defines the file attributes associated with */
                        /*  the created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB-HL) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  password of the user, defined by initiator ID */
                        /*  parameter of the FTM_INITIALIZE_REQ_, who has */
                        /*  permission to create files in the current */
                        /*  filestore. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  establishes a subset of the valid actions for */
                        /*  use within the File Open regime being */
                        /*  established. */
                        /*  (ZFTM-DDL-PROC-MODE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the abstract data type of the */
                        /*  contents of the file. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the account to which costs are to */
                        /*  be charged that are incurred during the */
                        /*  regime being established. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_FILE_OPEN_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  is the name of the file to be opened. */
                        /*  (ZAPS-DDL-CHAR128) */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  defines if an existing file should be */
                        /*  selected or a new file created, and if new */
                        /*  file created, what the file attributes should */
                        /*  be. */
    short _far *,       /* IN OPTIONAL  */
                        /*  following the file creation, this parameter */
                        /*  establishes the access available in the */
                        /*  File Selection regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  defines the file attributes associated with */
                        /*  the created file. */
                        /*  (ZFTM-DDL-CREATE-ATTRIB-HL) */
    short _far *,       /* IN OPTIONAL  */
                        /*  password of the user, defined by initiator ID */
                        /*  parameter of the FTM_INITIALIZE_REQ_, who has */
                        /*  permission to create files in the current */
                        /*  filestore. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _far *,       /* IN OPTIONAL  */
                        /*  establishes a subset of the valid actions for */
                        /*  use within the File Open regime being */
                        /*  established. */
                        /*  (ZFTM-DDL-PROC-MODE) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the abstract data type of the */
                        /*  contents of the file. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the account to which costs are to */
                        /*  be charged that are incurred during the */
                        /*  regime being established. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_initialize_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_INITIALIZE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  FTAM regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _ptr32 *, /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  identifies the common name and/or the */
                        /*  OSI address of the local initiator. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  identifies the common name and/or the */
                        /*  OSI address of the remote responder. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns the AE title of the local */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns the AE title of the responding */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns a single service class which is */
                        /*  the highest class proposed by the */
                        /*  INitiator that the remote responder can */
                        /*  support. */
                        /*  (ZFTM-DDL-SERVICE-CLASS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns the file service functional units */
                        /*  requested by the initiator and negotiated */
                        /*  by the remote responder. */
                        /*  (ZFTM-DDL-FUNC-UNITS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns the attribute groups proposed by */
                        /*  the initiator that the remote responder */
                        /*  will support. */
                        /*  (ZFTM-DDL-ATTRIB-GROUPS) */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /*  returns the list of document type names */
                        /*  and abstract syntax names proposed by the */
                        /*  INitiator that the remote responder and */
                        /*  service providers will support. */
                        /*  (ZFTM-DDL-CNTNT-LIST) */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the */
                        /*  failure of a requested action */
                        /*  or info which qualifies a */
                        /*  successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_INITIALIZE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  FTAM regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  identifies the common name and/or the */
                        /*  OSI address of the local initiator. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  identifies the common name and/or the */
                        /*  OSI address of the remote responder. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the AE title of the local */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the AE title of the responding */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns a single service class which is */
                        /*  the highest class proposed by the */
                        /*  INitiator that the remote responder can */
                        /*  support. */
                        /*  (ZFTM-DDL-SERVICE-CLASS) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the file service functional units */
                        /*  requested by the initiator and negotiated */
                        /*  by the remote responder. */
                        /*  (ZFTM-DDL-FUNC-UNITS) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the attribute groups proposed by */
                        /*  the initiator that the remote responder */
                        /*  will support. */
                        /*  (ZFTM-DDL-ATTRIB-GROUPS) */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the list of document type names */
                        /*  and abstract syntax names proposed by the */
                        /*  INitiator that the remote responder and */
                        /*  service providers will support. */
                        /*  (ZFTM-DDL-CNTNT-LIST) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the */
                        /*  failure of a requested action */
                        /*  or info which qualifies a */
                        /*  successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_initialize_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_INITIALIZE_REQ_ (
    short _ptr32 *,     /* OUT  */
                        /*  CEPI used to identify the specific */
                        /*  connection. */
    short _ptr32 *,     /* IN  */
                        /*  Guardian process name of the APLMGR used */
                        /*  when establishing the association. */
                        /*  (ZAPS-DDL-FILENAME) */
    short _ptr32 *,     /* IN  */
                        /*  specifies the common name and/or OSI address */
                        /*  of the FTAM responder. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short ,             /* IN OPTIONAL  */
                        /*  sets the association to waited or nowaited */
                        /*  mode. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the common name and/or OSI address */
                        /*  of the local initiator. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  specifies the AE title of the local */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  specifies the AE title of the remote */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  requests service classes to be negotiated by */
                        /*  the remote responder. */
                        /*  (ZFTM-DDL-SERVICE-CLASS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  requests the set of file service functional */
                        /*  units desired for the association. */
                        /*  (ZFTM-DDL-FUNC-UNITS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  requests the set of optional file attribute */
                        /*  groups desired for the association. */
                        /*  (ZFTM-DDL-ATTRIB-GROUPS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  requests the presentation contexts for the */
                        /*  association. */
                        /*  (ZFTM-DDL-CNTNT-LIST) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the calling application to the */
                        /*  responding application. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the account to which costs are to */
                        /*  be charged that are incurred during the */
                        /*  regime being established. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  conveys a password used by the responder to */
                        /*  authenticate the initiator ID. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_INITIALIZE_REQ_ (
    short _far *,       /* OUT  */
                        /*  CEPI used to identify the specific */
                        /*  connection. */
    short _far *,       /* IN  */
                        /*  Guardian process name of the APLMGR used */
                        /*  when establishing the association. */
                        /*  (ZAPS-DDL-FILENAME) */
    short _far *,       /* IN  */
                        /*  specifies the common name and/or OSI address */
                        /*  of the FTAM responder. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short ,             /* IN OPTIONAL  */
                        /*  sets the association to waited or nowaited */
                        /*  mode. */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the common name and/or OSI address */
                        /*  of the local initiator. */
                        /*  (ZAPS-DDL-APPL-ADDR) */
    short _far *,       /* IN OPTIONAL  */
                        /*  specifies the AE title of the local */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* IN OPTIONAL  */
                        /*  specifies the AE title of the remote */
                        /*  application. */
                        /*  (ZAPS-DDL-AE-TITLE) */
    short _far *,       /* IN OPTIONAL  */
                        /*  requests service classes to be negotiated by */
                        /*  the remote responder. */
                        /*  (ZFTM-DDL-SERVICE-CLASS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  requests the set of file service functional */
                        /*  units desired for the association. */
                        /*  (ZFTM-DDL-FUNC-UNITS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  requests the set of optional file attribute */
                        /*  groups desired for the association. */
                        /*  (ZFTM-DDL-ATTRIB-GROUPS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  requests the presentation contexts for the */
                        /*  association. */
                        /*  (ZFTM-DDL-CNTNT-LIST) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the calling application to the */
                        /*  responding application. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the account to which costs are to */
                        /*  be charged that are incurred during the */
                        /*  regime being established. */
                        /*  (ZAPS-DDL-CHAR32) */
    short _far *,       /* IN OPTIONAL  */
                        /*  conveys a password used by the responder to */
                        /*  authenticate the initiator ID. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_locate_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_LOCATE_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  returns the FADU identity. */
                          /*  (ZFTM-DDL-FADU-ID) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_LOCATE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the FADU identity. */
                        /*  (ZFTM-DDL-FADU-ID) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_locate_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_LOCATE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_LOCATE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_open_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_OPEN_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  indicates if the Responder established the */
                          /*  File Open regime as requested. */
                          /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                          /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  returns the contents type of the file that was */
                          /*  opened. */
                          /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_OPEN_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  File Open regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  returns the contents type of the file that was */
                        /*  opened. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_open_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_OPEN_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  establishes a subset of the valid actions for */
                        /*  use within the File Open regime being */
                        /*  established. */
                        /*  (ZFTM-DDL-PROC-MODE) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the abstract data type of the */
                        /*  contents of the file. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_OPEN_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN OPTIONAL  */
                        /*  establishes a subset of the valid actions for */
                        /*  use within the File Open regime being */
                        /*  established. */
                        /*  (ZFTM-DDL-PROC-MODE) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the abstract data type of the */
                        /*  contents of the file. */
                        /*  (ZFTM-DDL-CNTNT-TYPE) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_p_abort_ind_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_P_ABORT_IND_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys detailed info on the reason for the */
                          /*  abort. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_P_ABORT_IND_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys detailed info on the reason for the */
                        /*  abort. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_read_attrib_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_READ_ATTRIB_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  lists returned attribute values associated */
                          /*  with the file. */
                          /*  (ZFTM-DDL-READ-ATTRIB) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_READ_ATTRIB_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  lists returned attribute values associated */
                        /*  with the file. */
                        /*  (ZFTM-DDL-READ-ATTRIB) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_read_attrib_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_READ_ATTRIB_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  indicates which file attributes from the */
                        /*  kernel or negotiated attribute groups are */
                        /*  to be read. */
                        /*  (ZFTM-DDL-ATTRIB-NAMES) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_READ_ATTRIB_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  indicates which file attributes from the */
                        /*  kernel or negotiated attribute groups are */
                        /*  to be read. */
                        /*  (ZFTM-DDL-ATTRIB-NAMES) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_read_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_READ_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  specifies the target FADU. */
                        /*  (ZFTM-DDL-FADU-ID) */
    short _ptr32 *,     /* IN  */
                        /*  specifies a view of the file access structure */
                        /*  for read operations. */
                        /*  (ZFTM-DDL-ACCESS-CNTXT) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_READ_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  specifies the target FADU. */
                        /*  (ZFTM-DDL-FADU-ID) */
    short _far *,       /* IN  */
                        /*  specifies a view of the file access structure */
                        /*  for read operations. */
                        /*  (ZFTM-DDL-ACCESS-CNTXT) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_select_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_SELECT_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  indicates if the Responder established the */
                          /*  File Selection regime as requested. */
                          /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                          /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  is the name of the selected file as returned */
                          /*  from the remote responder. */
                          /*  (ZFTM-DDL-CHAR128) */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_SELECT_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  indicates if the Responder established the */
                        /*  File Selection regime as requested. */
                        /*  valid values are ZFTM-VAL-STATE-SUCCESS, */
                        /*                   ZFTM-VAL-STATE-FAILURE */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* OUT OPTIONAL  */
                        /*  is the name of the selected file as returned */
                        /*  from the remote responder. */
                        /*  (ZFTM-DDL-CHAR128) */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_select_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_SELECT_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *,     /* IN  */
                        /*  is the name of the file to be selected. */
                        /*  (ZAPS-DDL-CHAR128) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  following file creation, this parameter */
                        /*  establishes the access available in the select */
                        /*  regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  identifies the account to which costs incurred */
                        /*  during the regime being established are to be */
                        /*  charged. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_SELECT_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *,       /* IN  */
                        /*  is the name of the file to be selected. */
                        /*  (ZAPS-DDL-CHAR128) */
    short _far *,       /* IN OPTIONAL  */
                        /*  following file creation, this parameter */
                        /*  establishes the access available in the select */
                        /*  regime. */
                        /*  (ZFTM-DDL-REQUESTED-ACCESS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  authenticates the actions requested in the */
                        /*  requested access parameter. */
                        /*  (ZFTM-DDL-ACCESS-PASSWORDS) */
    short _far *,       /* IN OPTIONAL  */
                        /*  identifies the account to which costs incurred */
                        /*  during the regime being established are to be */
                        /*  charged. */
                        /*  (ZAPS-DDL-CHAR32) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_terminate_cnf_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_TERMINATE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /*  conveys info on the costs attributed to the */
                        /*  account during the regime which is being */
                        /*  released. */
                        /*  (ZFTM-DDL-CHARGING) */
    );
#else
_tal _extensible short FTM_TERMINATE_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys info on the costs attributed to the */
                        /*  account during the regime which is being */
                        /*  released. */
                        /*  (ZFTM-DDL-CHARGING) */
    );
#endif

#pragma section ftm_terminate_req_
#include <tnsint.h>
_tal _extensible short FTM_TERMINATE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_transfer_end_cnf_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_TRANSFER_END_CNF_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys either detailed info on the failure */
                          /*  of a requested action or info which qualifies */
                          /*  a successful action. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_TRANSFER_END_CNF_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys either detailed info on the failure */
                        /*  of a requested action or info which qualifies */
                        /*  a successful action. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_transfer_end_req_
#include <tnsint.h>
_tal _extensible short FTM_TRANSFER_END_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );

#pragma section ftm_u_abort_ind_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_U_ABORT_IND_ (
    short ,               /* IN  */
                          /*  CEPI of the referenced connection */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /*  summarizes info in diagnostic parameter. */
                          /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                          /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /*  conveys detailed info on the the */
                          /*  reason for the abort. */
                          /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#else
_tal _extensible short FTM_U_ABORT_IND_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *        /* OUT OPTIONAL  */
                        /*  conveys detailed info on the the */
                        /*  reason for the abort. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    );
#endif

#pragma section ftm_u_abort_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_U_ABORT_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /*  conveys detailed info on the reason */
                        /*  for the abort. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_U_ABORT_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN OPTIONAL  */
                        /*  summarizes info in diagnostic parameter. */
                        /*  valid values are ZFTM-VAL-ACTION-SUCCESS, */
                        /*                   ZFTM-VAL-ACTION-FAILURE */
    short _far *,       /* IN OPTIONAL  */
                        /*  conveys detailed info on the reason */
                        /*  for the abort. */
                        /*  (ZFTM-DDL-DIAGNOSTIC) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section ftm_write_req_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short FTM_WRITE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
                        /*  indicates the action to be taken by the remote */
                        /*  responder upon receipt of the data. */
    short _ptr32 *,     /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#else
_tal _extensible short FTM_WRITE_REQ_ (
    short ,             /* IN  */
                        /*  CEPI of the referenced connection */
    __int32_t ,         /* IN  */
                        /*  indicates the action to be taken by the remote */
                        /*  responder upon receipt of the data. */
    short _far *,       /* IN  */
                        /*  specifies the target FADU */
                        /*  (ZFTM-DDL-FADU-ID) */
    __int32_t           /* IN OPTIONAL  */
                        /*  user-supplied tag */
    );
#endif

#pragma section getcpcbinfo
_tal _extensible void GETCPCBINFO (
    short ,             /* IN  */
                        /* THE TYPE OF INFO REQUESTED */
    short _near *,      /* OUT  */
                        /* THE INFO IS RETURNED IN THIS BUFFER */
    short ,             /* IN  */
                        /* # OF BYTES IN INFO BUFFER */
    short _near *,      /* OUT  */
                        /* # OF BYTES RETURNED IN INFO BUFFER */
    short _near *       /* OUT  */
                        /* RESULTING ERROR NUMBER */
    );

#pragma section getcrtpid
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status GETCRTPID (
    short ,             /* IN  */
                        /* PROCESS I.D. */
    short _ptr32 *      /* OUT  */
                        /* CREATIONID-PID RETURNED HERE */
    );
#else
_tal _cc_status GETCRTPID (
    short ,             /* IN  */
                        /* PROCESS I.D. */
    short _near *       /* OUT  */
                        /* CREATIONID-PID RETURNED HERE */
    );
#endif

#pragma section getdevname
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short GETDEVNAME (
    short _ptr32 *,     /* IN/OUT  */
                        /* LOGICAL DEVICE NUMBER */
    short _ptr32 *,     /* OUT  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* DEVICE TYPE */
    short               /* IN OPTIONAL  */
                        /* DEVICE SUBTYPE */
    );
#else
_tal _extensible short GETDEVNAME (
    short _near *,      /* IN/OUT  */
                        /* LOGICAL DEVICE NUMBER */
    short _near *,      /* OUT  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* DEVICE TYPE */
    short               /* IN OPTIONAL  */
                        /* DEVICE SUBTYPE */
    );
#endif

#pragma section getincrementedit
#include <tnsint.h>
_tal _extensible __int32_t GETINCREMENTEDIT (
    short               /* IN  */
                        /*  open file number  */
    );

#pragma section getpool
#include <tnsint.h>
/* This procedure cannot be used from a C program.  The following syntax is
   illegal; it will cause an error if this section is explicitly included. */
#ifndef WHOLE_CEXTDECS_INCLUDED__
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t & _cc_status GETPOOL (
    short _ptr32 *,       /* IN/OUT  */
    __int32_t             /* IN  */
    );
#else
_tal __int32_t & _cc_status GETPOOL (
    short _far *,       /* IN/OUT  */
    __int32_t           /* IN  */
    );
#endif
#endif

#pragma section getpositionedit
#include <tnsint.h>
_tal _extensible __int32_t GETPOSITIONEDIT (
    short               /* IN  */
                        /*   open file number  */
    );

#pragma section getppdentry
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status GETPPDENTRY (
    short ,             /* IN  */
                        /* ENTRY NUMBER */
    short ,             /* IN  */
                        /* SYSTEM NUMBER */
    short _ptr32 *      /* OUT  */
                        /* ENTRY RETURNED HERE */
    );
#else
_tal _cc_status GETPPDENTRY (
    short ,             /* IN  */
                        /* ENTRY NUMBER */
    short ,             /* IN  */
                        /* SYSTEM NUMBER */
    short _near *       /* OUT  */
                        /* ENTRY RETURNED HERE */
    );
#endif

#pragma section getremotecrtpid
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status GETREMOTECRTPID (
    short ,             /* IN  */
                        /* PROCESS I.D. */
    short _ptr32 *,     /* OUT  */
                        /* CREATIONID-PID RETURNED HERE */
    short               /* IN  */
                        /* SYSTEM WHERE PROCESS IS */
    );
#else
_tal _cc_status GETREMOTECRTPID (
    short ,             /* IN  */
                        /* PROCESS I.D. */
    short _near *,      /* OUT  */
                        /* CREATIONID-PID RETURNED HERE */
    short               /* IN  */
                        /* SYSTEM WHERE PROCESS IS */
    );
#endif

#pragma section getruntimedata
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short GETRUNTIMEDATA (
    __int32_t ,           /* IN  */
    char _ptr32 *,        /* IN  */
    char _ptr32 *,        /* IN/OUT  */
    __int32_t ,           /* IN/OUT OPTIONAL  */
    __int32_t ,           /* IN/OUT  */
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
    short                 /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short GETRUNTIMEDATA (
    __int32_t ,         /* IN  */
    char _far *,        /* IN  */
    char _far *,        /* IN/OUT  */
    __int32_t ,         /* IN/OUT OPTIONAL  */
    __int32_t ,         /* IN/OUT  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    short               /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section getsyncinfo
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status GETSYNCINFO (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _ptr32 *,     /* OUT  */
                        /* ARRAY FOR SYNCHRONIZATION INFORMATION */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* SIZE OF SYNCINFO ARRAY */
    );
#else
_tal _variable _cc_status GETSYNCINFO (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _near *,      /* OUT  */
                        /* ARRAY FOR SYNCHRONIZATION INFORMATION */
    short _near *       /* OUT OPTIONAL  */
                        /* SIZE OF SYNCINFO ARRAY */
    );
#endif

#pragma section getsystemname
#if (_TANDEM_ARCH_ > 1)
_tal short GETSYSTEMNAME (
    short ,              /* IN  */
    short _ptr32 *       /* OUT  */
    );
#else
_tal short GETSYSTEMNAME (
    short ,             /* IN  */
    short _near *       /* OUT  */
    );
#endif

#pragma section getsystemserialnumber
_tal _extensible short GETSYSTEMSERIALNUMBER (
    char _far *,        /* OUT  */
                        /* String buffer */
    short ,             /* IN  */
                        /* Max buffer length */
    short _far *        /* OUT  */
                        /* String length */
    );

#pragma section gettmpname
#if ( _TANDEM_ARCH_ >= 2 )
_tal short GETTMPNAME (
    short _ptr64 *       /* OUT  */
                         /* 12-WORD ARRAY TO WHICH TMP NAME IS RETURNED */
    );
#else
_tal short GETTMPNAME (
    short _near *       /* OUT  */
                        /* 12-WORD ARRAY TO WHICH TMP NAME IS RETURNED */
    );
#endif


#pragma section gettransactiondetails
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short GETTRANSACTIONDETAILS (
     short,                   /* IN */
                              /* InputID : Indicates whether */
                              /* TransID or TXID or TxHandle or */
                              /* none of these is being passed as input. */
     long long  _ptr64*,      /* IN/OUT OPTIONAL*/
                              /* Transaction ID */
     long long  _ptr64*,      /* IN/OUT OPTIONAL */
                              /* TXID */
     short  _ptr64*,          /* IN/OUT OPTIONAL */
                              /* TxHandle */
     long long  _ptr64*,      /* OUT OPTIONAL */
                              /* type flags */
     short  _ptr64*,          /* OUT OPTIONAL */
                              /* process handle */
     __int32_t  _ptr64*       /* OUT OPTIONAL */
                              /* beginner tag */
     );
#else
_tal _extensible short GETTRANSACTIONDETAILS (
     short,                   /* IN */
                              /* InputID : Indicates whether */
                              /* TransID or TXID or TxHandle or */
                              /* none of these is being passed as input. */
     long long  _far*,        /* IN/OUT OPTIONAL */
                              /* Transaction ID */
     long long  _far*,        /* IN/OUT OPTIONAL */
                              /* TXID */
     short  _far*,            /* IN/OUT OPTIONAL */
                              /* TxHandle */
     long long  _far*,        /* OUT OPTIONAL */
                              /* type flags */
     short  _far*,            /* OUT OPTIONAL */
                              /* process handle */
     __int32_t  _far*         /* OUT OPTIONAL */
                              /* beginner tag */
     );
#endif


#pragma section gettransid
#if ( _TANDEM_ARCH_ >= 2 )
_tal short GETTRANSID (
    short _ptr64 *       /* OUT  */
                         /* ARRAY TO WHICH TRANSID IS RETURNED */
    );
#else
_tal short GETTRANSID (
    short _near *       /* OUT  */
                        /* ARRAY TO WHICH TRANSID IS RETURNED */
    );
#endif


#pragma section gettransinfo
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short GETTRANSINFO (
    long long _ptr64 *,   /* OUT ARRAY TO WHICH TRANSID IS RETURNED */
    long long _ptr64 *    /* OUT */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short GETTRANSINFO (
    long long _far *,   /* OUT ARRAY TO WHICH TRANSID IS RETURNED */
    long long _far *    /* OUT */
    );
#endif

#pragma section gettsmpversion
#include <tnsint.h>
_tal _extensible short GETTSMPVERSION (
   void);


#pragma section give_break
#if (_TANDEM_ARCH_ > 1)
_tal _alias ("GIVE^BREAK") short GIVE_BREAK (
    short _ptr32 *       /* IN  */
                         /* FCB OF FILE TO GIVE BREAK STATUS FROM */
    );
#else
_tal _alias ("GIVE^BREAK") short GIVE_BREAK (
    short _near *       /* IN  */
                        /* FCB OF FILE TO GIVE BREAK STATUS FROM */
    );
#endif

#pragma section groupidtogroupname
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status GROUPIDTOGROUPNAME (
    short _ptr32 *       /* IN/OUT  */
    );
#else
_tal _cc_status GROUPIDTOGROUPNAME (
    short _near *       /* IN/OUT  */
    );
#endif

#pragma section groupmember_getnext_
#include <tnsint.h>
_tal _extensible short GROUPMEMBER_GETNEXT_ (
    __int32_t ,         /* IN  */
                        /* GROUP ID OF THE GROUP */
    char _far *,        /* IN/OUT  */
                        /* NAME OF USER */
    short ,             /* IN  */
                        /* MAXIMUM LENGTH OF USER_NAME BUFFER */
    short _far *        /* IN/OUT  */
                        /* LENGTH OF USER NAME */
    );

#pragma section groupnametogroupid
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status GROUPNAMETOGROUPID (
    short _ptr32 *       /* IN/OUT  */
    );
#else
_tal _cc_status GROUPNAMETOGROUPID (
    short _near *       /* IN/OUT  */
    );
#endif

#pragma section group_getinfo_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short GROUP_GETINFO_ (
    char _ptr64 *,      /* IN/OUT OPTIONAL  */
                        /* NAME OF GROUP */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF GROUP_NAME BUFFER */
    short _ptr64 *,     /* IN/OUT OPTIONAL  */
                        /* LENGTH OF GROUP NAME */
    int _ptr64 *,       /* IN/OUT OPTIONAL  */
                        /* GROUP ID OF THE GROUP */
    short _ptr64 *,     /* OUT OPTIONAL  */
                        /* WHETHER GROUP IS DELETED WHEN IT HAS NO MEMBERS */
    char _ptr64 *,      /* OUT OPTIONAL  */
                        /* TEXTUAL DESCRIPTION OF GROUP */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF DESCRIP BUFFER */
    short _ptr64 *      /* OUT OPTIONAL  */
                        /* LENGTH OF STRING RETURNED IN DESCRIP */
    );
#else
_tal _extensible short GROUP_GETINFO_ (
    char _far *,        /* IN/OUT OPTIONAL  */
                        /* NAME OF GROUP */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF GROUP_NAME BUFFER */
    short _far *,       /* IN/OUT OPTIONAL  */
                        /* LENGTH OF GROUP NAME */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
                        /* GROUP ID OF THE GROUP */
    short _far *,       /* OUT OPTIONAL  */
                        /* WHETHER GROUP IS DELETED WHEN IT HAS NO MEMBERS */
    char _far *,        /* OUT OPTIONAL  */
                        /* TEXTUAL DESCRIPTION OF GROUP */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF DESCRIP BUFFER */
    short _far *        /* OUT OPTIONAL  */
                        /* LENGTH OF STRING RETURNED IN DESCRIP */
    );
#endif


#pragma section group_getnext_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short GROUP_GETNEXT_ (
    char _ptr64 *,      /* IN/OUT  */
                        /* name of group */
    short ,             /* IN  */
                        /* maximum length of GROUP_NAME buffer */
    short _ptr64 *,     /* IN/OUT  */
                        /* length of group name */
    int _ptr64 *        /* OUT OPTIONAL  */
                        /* group id for returned group name */
    );
 #else
_tal _extensible short GROUP_GETNEXT_ (
    char _far *,        /* IN/OUT  */
                        /* name of group */
    short ,             /* IN  */
                        /* maximum length of GROUP_NAME buffer */
    short _far *,       /* IN/OUT  */
                        /* length of group name */
    __int32_t _far *    /* OUT OPTIONAL  */
                        /* group id for returned group name */
    );
#endif


#pragma section haltpoll
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status HALTPOLL (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
                        /* NOT USED */
    );

#pragma section headroom_ensure_
#include <tnsint.h>
#if _TANDEM_ARCH_ > 0   /* any native version */
_tal __int32_t HEADROOM_ENSURE_ (
    __int32_t           /* IN  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section heapsort
#if (_TANDEM_ARCH_ > 1)
_tal void HEAPSORT (
    short _ptr32 *,     /* IN/OUT  */
                        /* ELEMENTS TO BE SORTED */
    short ,             /* IN  */
                        /* NUMBER OF ELEMENTS */
    short ,             /* IN  */
                        /* ELEMENT SIZE IN WORDS */
    short (_ptr32 *)(
    )                   /* IN  */
                        /* COMPARISON PROCEDURE. */
                        /* CALLING SEQUENCE SHOULD BE: */
                        /* INT PROC COMPAREPROC ( A, B ); */
                        /* INT .A, .B; */
                        /* RETURNS NONZERO IF ELEMENT A SHOULD PRECEDE */
                        /* ELEMENT B. */
    );
#else
_tal void HEAPSORT (
    short _near *,      /* IN/OUT  */
                        /* ELEMENTS TO BE SORTED */
    short ,             /* IN  */
                        /* NUMBER OF ELEMENTS */
    short ,             /* IN  */
                        /* ELEMENT SIZE IN WORDS */
    short (*)(
    )                   /* IN  */
                        /* COMPARISON PROCEDURE. */
                        /* CALLING SEQUENCE SHOULD BE: */
                        /* INT PROC COMPAREPROC ( A, B ); */
                        /* INT .A, .B; */
                        /* RETURNS NONZERO IF ELEMENT A SHOULD PRECEDE */
                        /* ELEMENT B. */
    );
#endif

#pragma section heapsortx_
#if (_TANDEM_ARCH_ > 1)
#include <tnsint.h>
_tal _extensible short HEAPSORTX_ (
    short _ptr32 *,     /* IN/OUT  */
                        /* Data to be sorted */
    __int32_t ,         /* IN  */
                        /* Number of elements in ARRAY */
    short ,             /* IN  */
                        /* Size of one element in ARRAY */
    short (_ptr32 *)(
    ),                  /* IN  */
                        /* Proc to compare two elements */
    __int32_t _ptr32 *  /* IN OPTIONAL  */
                        /* Storage to hold pointers to optimize sort */
    );
#else
#include <tnsint.h>
_tal _extensible short HEAPSORTX_ (
    short _far *,       /* IN/OUT  */
                        /* Data to be sorted */
    __int32_t ,         /* IN  */
                        /* Number of elements in ARRAY */
    short ,             /* IN  */
                        /* Size of one element in ARRAY */
    short (*)(
    ),                  /* IN  */
                        /* Proc to compare two elements */
    __int32_t _far *    /* IN OPTIONAL  */
                        /* Storage to hold pointers to optimize sort */
    );
#endif

#pragma section incrementedit
#include <tnsint.h>
_tal _extensible void INCREMENTEDIT (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t           /* IN  */
                        /*   line number increment, times 1000  */
    );

#pragma section initializeedit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short INITIALIZEEDIT (
    short _ptr32 *,       /* IN OPTIONAL  */
                        /*   [0: 3]  Swapping disc volume name  */
    short ,             /* IN OPTIONAL  */
                        /*   maximum number of files allowed    */
    short ,             /* IN OPTIONAL  */
                        /*   abend if fatal error flag          */
    short               /* IN OPTIONAL  */
                        /*   selection of I/O buffering method  */
    );
#else
_tal _extensible short INITIALIZEEDIT (
    short _far *,       /* IN OPTIONAL  */
                        /*   [0: 3]  Swapping disc volume name  */
    short ,             /* IN OPTIONAL  */
                        /*   maximum number of files allowed    */
    short ,             /* IN OPTIONAL  */
                        /*   abend if fatal error flag          */
    short               /* IN OPTIONAL  */
                        /*   selection of I/O buffering method  */
    );
#endif

#pragma section initializer
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short INITIALIZER (
    short _ptr32 *,     /* IN  */
                        /* RUN UNIT CONTROL BLOCK */
    short _ptr32 *,     /* OUT  */
                        /* ARRAY PASSED TO PROCS  V */
    void (_ptr32 *)(
    ),                  /* IN  */
                        /* PROC CALLED W/ STARTUP MSG */
    void (_ptr32 *)(
    ),                  /* IN  */
                        /* PROC CALLED W/ PARAMS  MSG */
    void (_ptr32 *)(
    ),                  /* IN  */
                        /* PROC CALLED W/ ASSIGN  MSG */
    short ,             /* IN  */
                        /* CONTROLS VARIOUS OPTIONS */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TIME FOR WAIT ON MESSAGES (UNITS .01 SEC) */
    short ,             /* IN OPTIONAL */
                        /* NUMBER OF FCBS IN FCB^ARRAY */
    short _ptr32 *      /* IN OPTIONAL */
                        /* ARRAY OF FCBS TO SCAN AND EXPAND NAMES IN */
    );
#else
_tal _extensible short INITIALIZER (
    short _near *,      /* IN  */
                        /* RUN UNIT CONTROL BLOCK */
    short _near *,      /* OUT  */
                        /* ARRAY PASSED TO PROCS  V */
    void (*)(
    ),                  /* IN  */
                        /* PROC CALLED W/ STARTUP MSG */
    void (*)(
    ),                  /* IN  */
                        /* PROC CALLED W/ PARAMS  MSG */
    void (*)(
    ),                  /* IN  */
                        /* PROC CALLED W/ ASSIGN  MSG */
    short ,             /* IN  */
                        /* CONTROLS VARIOUS OPTIONS */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TIME FOR WAIT ON MESSAGES (UNITS .01 SEC) */
    short ,             /* IN OPTIONAL */
                        /* NUMBER OF FCBS IN FCB^ARRAY */
    short _near *       /* IN OPTIONAL */
                        /* ARRAY OF FCBS TO SCAN AND EXPAND NAMES IN */
    );
#endif

#pragma section interpretinterval
#include <tnsint.h>
_tal _extensible __int32_t INTERPRETINTERVAL (
    long long ,         /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );

#pragma section interpretjuliandayno
#include <tnsint.h>
_tal void INTERPRETJULIANDAYNO (
    __int32_t ,         /* IN  */
    short _near *,      /* OUT  */
    short _near *,      /* OUT  */
    short _near *       /* OUT  */
    );

#pragma section interprettimestamp
#include <tnsint.h>
_tal __int32_t INTERPRETTIMESTAMP (
    long long ,         /* IN  */
    short _near *       /* OUT  */
    );

#pragma section interprettransid
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short INTERPRETTRANSID (
    long long ,           /* IN  */
    __int32_t _ptr64 *,   /* OUT  */
    short _ptr64 *,       /* OUT  */
    __int32_t _ptr64 *,   /* OUT  */
    short _ptr64 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short INTERPRETTRANSID (
    long long ,         /* IN  */
    __int32_t _far *,   /* OUT  */
    short _far *,       /* OUT  */
    __int32_t _far *,   /* OUT  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif


#pragma section juliantimestamp
_tal _extensible long long JULIANTIMESTAMP (
    short ,             /* IN OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section keyposition
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status KEYPOSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
    char _ptr32 *,      /* IN  */
                        /* NEW VALUE OF KEY */
    short ,             /* IN OPTIONAL  */
                        /* KEY TAG  ( WHICH KEY ) */
    short ,             /* IN OPTIONAL  */
                        /* KEY LENGTH */
    short               /* IN OPTIONAL  */
                        /* 0 = APPROXIMATE */
                        /* 1  = GENERIC */
                        /* 2 = EXACT */
    );
#else
_tal _variable _cc_status KEYPOSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
    char _near *,       /* IN  */
                        /* NEW VALUE OF KEY */
    short ,             /* IN OPTIONAL  */
                        /* KEY TAG  ( WHICH KEY ) */
    short ,             /* IN OPTIONAL  */
                        /* KEY LENGTH */
    short               /* IN OPTIONAL  */
                        /* 0 = APPROXIMATE */
                        /* 1  = GENERIC */
                        /* 2 = EXACT */
    );
#endif


#pragma section keypositionx
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status KEYPOSITIONX (
    short ,                /* IN  */
    const char _ptr32 *,   /* IN  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short                  /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status KEYPOSITIONX (
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section labeledtapesupport
_tal _variable short LABELEDTAPESUPPORT (
    short               /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    );

#pragma section lastaddr
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ LASTADDR;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal short LASTADDR (
    void);
#endif /*  _TANDEM_ARCH_ check  */

#pragma section lastaddrx
#include <tnsint.h>
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ LASTADDRX;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal _extensible __int32_t LASTADDRX (
    short               /* IN  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section lastreceive
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status LASTRECEIVE (
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* PROCESSID OF PROCESS WHICH SENT LAST MESSAGE */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* REPLY NUMBER */
    );
#else
_tal _variable _cc_status LASTRECEIVE (
    short _near *,      /* OUT OPTIONAL  */
                        /* PROCESSID OF PROCESS WHICH SENT LAST MESSAGE */
    short _near *       /* OUT OPTIONAL  */
                        /* REPLY NUMBER */
    );
#endif


#pragma section locatesystem
#if (_TANDEM_ARCH_ > 1)
_tal _variable short LOCATESYSTEM (
    short _ptr32 *,      /* IN/OUT  */
    short _ptr32 *       /* IN OPTIONAL  */
    );
#else
_tal _variable short LOCATESYSTEM (
    short _near *,      /* IN/OUT  */
    short _near *       /* IN OPTIONAL  */
    );
#endif

#pragma section lockfile
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status LOCKFILE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );

#pragma section lockinfo
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short LOCKINFO (
    short ,             /* IN  */
                        /* Type of lock search (values are:  0, 1, 2 or 3) */
    short _ptr32 *,     /* IN  */
                        /* DP2 disk volume name [0:3] and search id [4:11] */
    short _ptr32 *,     /* IN/OUT  */
                        /* Saved "cursor" values (LCB words P4, P5 and P6) */
    short ,             /* IN  */
                        /* Size of user buffer (minimum value is 290 bytes) */
    char _ptr32 *       /* OUT  */
                        /* User buffer (size is <ubuflen> # of bytes) */
    );
#else
_tal _extensible short LOCKINFO (
    short ,             /* IN  */
                        /* Type of lock search (values are:  0, 1, 2 or 3) */
    short _far *,       /* IN  */
                        /* DP2 disk volume name [0:3] and search id [4:11] */
    short _far *,       /* IN/OUT  */
                        /* Saved "cursor" values (LCB words P4, P5 and P6) */
    short ,             /* IN  */
                        /* Size of user buffer (minimum value is 290 bytes) */
    char _far *         /* OUT  */
                        /* User buffer (size is <ubuflen> # of bytes) */
    );
#endif


#pragma section lockmemory
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short LOCKMEMORY (
    char _ptr32 *,      /* IN  */
    __int32_t ,         /* IN  */
    __int32_t ,         /* IN  */
    short ,             /* IN  */
    __int32_t           /* IN  */
    );
#else
_tal _variable short LOCKMEMORY (
    char _far *,        /* IN  */
    __int32_t ,         /* IN  */
    __int32_t ,         /* IN  */
    short ,             /* IN  */
    __int32_t           /* IN  */
    );
#endif

#pragma section lockrec
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status LOCKREC (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );

#pragma section lookupprocessname
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status LOOKUPPROCESSNAME (
    short _ptr32 *       /* IN/OUT  */
                         /* PROCESS NAME OR ENTRY INDEX */
    );
#else
_tal _cc_status LOOKUPPROCESSNAME (
    short _near *       /* IN/OUT  */
                        /* PROCESS NAME OR ENTRY INDEX */
    );
#endif

#pragma section mbcs_any_katakana_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_ANY_KATAKANA_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short MBCS_ANY_KATAKANA_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section mbcs_charsize_
_tal _extensible short MBCS_CHARSIZE_ (
    short               /* IN OPTIONAL  */
    );

#pragma section mbcs_charstring_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_CHARSTRING_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short MBCS_CHARSTRING_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section mbcs_char_
_tal _extensible short MBCS_CHAR_ (
    char _far *,        /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN/OUT OPTIONAL  */
    );

#pragma section mbcs_codesets_supported_
#include <tnsint.h>
_tal _extensible __int32_t MBCS_CODESETS_SUPPORTED_ (
    void);

#pragma section mbcs_defaultcharset_
_tal _extensible short MBCS_DEFAULTCHARSET_ (
    void);

#pragma section mbcs_external_to_tandem_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_EXTERNAL_TO_TANDEM_ (
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
    short ,               /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    char _ptr32 *         /* IN OPTIONAL  */
    );
#else
_tal _extensible short MBCS_EXTERNAL_TO_TANDEM_ (
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    char _far *         /* IN OPTIONAL  */
    );
#endif

#pragma section mbcs_format_crt_field_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_FORMAT_CRT_FIELD_ (
    __int32_t _ptr32 *,   /* IN/OUT  */
    __int32_t _ptr32 *,   /* IN/OUT  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* IN OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short MBCS_FORMAT_CRT_FIELD_ (
    __int32_t _far *,   /* IN/OUT  */
    __int32_t _far *,   /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT  */
    char _far *,        /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section mbcs_format_iti_buffer_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_FORMAT_ITI_BUFFER_ (
    __int32_t _ptr32 *,   /* IN/OUT  */
    __int32_t _ptr32 *,   /* IN/OUT  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* IN OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short MBCS_FORMAT_ITI_BUFFER_ (
    __int32_t _far *,   /* IN/OUT  */
    __int32_t _far *,   /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT  */
    char _far *,        /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section mbcs_mb_to_sb_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void MBCS_MB_TO_SB_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible void MBCS_MB_TO_SB_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section mbcs_replaceblank_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void MBCS_REPLACEBLANK_ (
    char _ptr32 *,      /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _extensible void MBCS_REPLACEBLANK_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section mbcs_sb_to_mb_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void MBCS_SB_TO_MB_ (
    char _ptr32 *,      /* IN  */
    short ,             /* IN  */
    char _ptr32 *,      /* IN  */
    short ,             /* IN  */
    short _ptr32 *,     /* OUT  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _extensible void MBCS_SB_TO_MB_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section mbcs_shiftstring_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void MBCS_SHIFTSTRING_ (
    char _ptr32 *,      /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _extensible void MBCS_SHIFTSTRING_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section mbcs_tandem_to_external_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MBCS_TANDEM_TO_EXTERNAL_ (
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
    short ,               /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    char _ptr32 *         /* IN OPTIONAL  */
    );
#else
_tal _extensible short MBCS_TANDEM_TO_EXTERNAL_ (
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    char _far *         /* IN OPTIONAL  */
    );
#endif

#pragma section mbcs_testbyte_
_tal _extensible short MBCS_TESTBYTE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section mbcs_trimfragment_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void MBCS_TRIMFRAGMENT_ (
    char _ptr32 *,        /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible void MBCS_TRIMFRAGMENT_ (
    char _far *,        /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section meas_adjustzmsrecord_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_ADJUSTZMSRECORD_ (
    short _ptr32 *,     /* IN  */
                        /* ZMS-STYLE MEAS EXTERNAL REC, INITIAL FORMAT */
    short _ptr32 *,     /* OUT  */
                        /* ZMS-STYLE MEAS EXTERNAL REC, ADJUSTED FORMAT */
    long long           /* IN  */
                        /* TEMPLATE-VERSION constant as found in MEASDDLS, */
                        /* specifying format for adjusted record */
    );
#else
_tal _extensible short MEAS_ADJUSTZMSRECORD_ (
    short _far *,       /* IN  */
                        /* ZMS-STYLE MEAS EXTERNAL REC, INITIAL FORMAT */
    short _far *,       /* OUT  */
                        /* ZMS-STYLE MEAS EXTERNAL REC, ADJUSTED FORMAT */
    long long           /* IN  */
                        /* TEMPLATE-VERSION constant as found in MEASDDLS, */
                        /* specifying format for adjusted record */
    );
#endif

#pragma section meas_getdescinfo_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_GETDESCINFO_ (
    short,                /* IN OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* OUT  */
    long long _ptr32 *,   /* IN/OUT OPTIONAL */
    __int32_t _ptr32 *    /* IN OPTIONAL */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short MEAS_GETDESCINFO_ (
    short,              /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT  */
    long long _far *,   /* IN/OUT OPTIONAL */
    __int32_t _far *    /* IN OPTIONAL */
    );
#endif

#pragma section meas_allocate_timercells_
#if (_TANDEM_ARCH_ > 1)
_tal short MEAS_ALLOCATE_TIMERCELLS_ (
    short ,               /* IN */
                          /* NUMBER OF TIMER CELLS TO ALLOCATE */
    short _ptr32 *,       /* IN */
                          /* ARRAY OF COUNTER TYPES FOR EACH INDEX */
                          /* COUNTER TYPES CAN BE ONE OF THESE */
                          /* 6=TCELLBUSY, 7=TCELLQUEUE, 8=TCELLQBUSY */
    short _ptr32 *        /* OUT */
                          /* ARRAY OF INDEX VALUES FOR EACH CELL */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal short MEAS_ALLOCATE_TIMERCELLS_ (
    short ,               /* IN */
                          /* NUMBER OF TIMER CELLS TO ALLOCATE */
    short _far *,         /* IN */
                          /* ARRAY OF COUNTER TYPES FOR EACH INDEX */
                          /* COUNTER TYPES CAN BE ONE OF THESE */
                          /* 6=TCELLBUSY, 7=TCELLQUEUE, 8=TCELLQBUSY */
    short _far *          /* OUT */
                          /* ARRAY OF INDEX VALUES FOR EACH CELL */
    );
#endif /* _TANDEM_ARCH_ check  */

#pragma section meas_bump_timercell_
#if (_TANDEM_ARCH_ != 1)
_tal _variable short MEAS_BUMP_TIMERCELL_ (
    short ,               /* IN */
                          /* CELL TO BE MODIFIED */
    short ,               /* IN */
                          /* OPERATION TO BE DONE */
                          /* 3=SETBUSY, 4=RESETBUSY, 5=INCQUEUE */
                          /* 6=DECQUEUE, 7=INCQBUSY, 8=DECQBUSY */
    short                 /* IN OPTIONAL */
                          /* COUNT FOR INC/DEC MANY OPERATION  */
    );
#endif /* _TANDEM_ARCH_ check  */

#pragma section meas_coderangename_demangle_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_CODERANGENAME_DEMANGLE_ (
   char _ptr32 *,   /* IN */
                    /* MANGLED PROC NAME BUFFER */
   short,           /* IN */
                    /* LENGTH OF MANGLED PROC NAME STRING */
   char _ptr32 *,   /* OUT */
                    /* DEMANGLED PROC NAME BUFFER */
   short,           /* IN */
                    /* LENGTH OF DEMANGLED NAME BUFFER */
   short _ptr32 *,  /* OUT */
                    /* LENGTH OF DEMANGLED NAME STRING */
   short _ptr32 *   /* OUT */
                    /* NAME TYPE (1 C OR TAL, 2 CPP) */
   );
#else
_tal _extensible short MEAS_CODERANGENAME_DEMANGLE_ (
   char _far *,   /* IN */
                  /* MANGLED PROC NAME BUFFER */
   short,         /* IN */
                  /* LENGTH OF MANGLED PROC NAME STRING */
   char _far *,   /* OUT */
                  /* DEMANGLED PROC NAME BUFFER */
   short,         /* IN */
                  /* LENGTH OF DEMANGLED NAME BUFFER */
   short _far *,  /* OUT */
                  /* LENGTH OF DEMANGLED NAME STRING */
   short _far *   /* OUT */
                  /* NAME TYPE (1 C OR TAL, 2 CPP) */
   );
#endif

#pragma section meas_deallocate_timercells_
#if (_TANDEM_ARCH_ > 1)
_tal short MEAS_DEALLOCATE_TIMERCELLS_ (
    short ,               /* IN */
                          /* NUMBER OF TIMER CELLS TO DEALLOCATE */
    short _ptr32 *        /* IN/OUT */
                          /* IN: ARRAY OF INDEX VALUES OF CELLS TO */
                          /* DEALLOCATE */
                          /* OUT: VALUE IS -1 IF CELL DEALLOCATED */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal short MEAS_DEALLOCATE_TIMERCELLS_ (
    short ,               /* IN */
                          /* NUMBER OF TIMER CELLS TO DEALLOCATE */
    short _far *          /* IN/OUT */
                          /* IN: ARRAY OF INDEX VALUES OF CELLS TO*/
                          /* DEALLOCATE */
                          /* OUT: VALUE IS -1 IF CELL DEALLOCATED */
    );
#endif /* _TANDEM_ARCH_ check  */

#pragma section meas_retrieve_timercells_
#if (_TANDEM_ARCH_ > 1)
_tal short MEAS_RETRIEVE_TIMERCELLS_ (
    short ,                 /* IN  */
                            /* NUMBER OF TIMER CELLS TO RETRIEVE */
    short _ptr32 *,         /* IN  */
                            /* ARRAY OF INDEX VALUES FOR EACH CELL */
    long long _ptr32 *      /* IN,OUT */
                            /* ARRAY OF TIMER VALUES FOR EACH CELL */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal short MEAS_RETRIEVE_TIMERCELLS_ (
    short ,               /* IN  */
                          /* NUMBER OF TIMER CELLS TO RETRIEVE */
    short _near *,        /* IN  */
                          /* ARRAY OF INDEX VALUES FOR EACH CELL */
    long long _far *      /* IN,OUT */
                          /* ARRAY OF TIMER VALUES FOR EACH CELL */
    );
#endif /* _TANDEM_ARCH_ check  */

#pragma section meas_sqlname_compare_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_SQLNAME_COMPARE_ (
    char _ptr32 *,          /* IN */
    short,                  /* IN */
    char _ptr32 *,          /* IN */
    short                   /* IN */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short MEAS_SQLNAME_COMPARE_ (
    char _far *,          /* IN */
    short,                /* IN */
    char _far *,          /* IN */
    short                 /* IN */
    );
#endif

#pragma section meas_sqlname_resolve_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_SQLNAME_RESOLVE_ (
    char _ptr32 *,          /* OUT */
    short,                  /* IN */
    short _ptr32 *,         /* OUT */
    char _ptr32 *,          /* IN */
    short,                  /* IN */
    char _ptr32 *,          /* IN OPTIONAL */
    short,                  /* IN OPTIONAL */
    char _ptr32 *,          /* IN OPTIONAL */
    short                   /* IN OPTIONAL */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short MEAS_SQLNAME_RESOLVE_ (
    char _far *,          /* OUT */
    short,                /* IN */
    short _near *,        /* OUT */
    char _far *,          /* IN */
    short,                /* IN */
    char _far *,          /* IN OPTIONAL */
    short,                /* IN OPTIONAL */
    char _far *,          /* IN OPTIONAL */
    short                 /* IN OPTIONAL */
    );
#endif

#pragma section meas_sqlname_scan_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_SQLNAME_SCAN_ (
    char _ptr32 *,          /* IN */
    short                   /* IN */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short MEAS_SQLNAME_SCAN_ (
    char _far *,          /* IN */
    short                 /* IN */
    );
#endif

#pragma section meas_sql_map_init_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal short MEAS_SQL_MAP_INIT_ (
    __int32_t _ptr32 *    /* IN/OUT  */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal short MEAS_SQL_MAP_INIT_ (
    __int32_t _far *    /* IN/OUT  */
    );
#endif

#pragma section meas_sql_map_stop_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal short MEAS_SQL_MAP_STOP_ (
    __int32_t _ptr32 *    /* IN  */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal short MEAS_SQL_MAP_STOP_ (
    __int32_t _far *    /* IN  */
    );
#endif

#pragma section measclose
_tal _extensible short MEASCLOSE (
    short               /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    );

#pragma section measconfigure
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASCONFIGURE (
    short _ptr32 *,     /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,     /* OUT  */
                        /* MEASUREMENT NUMBER */
    short _ptr32 *,     /* IN  */
                        /* CONTAB CONTAINS ENTITY */
                        /* DESCRIPTORS OF ENTITIES TO BE MEASURED */
    long long _ptr32 *  /* OUT OPTIONAL  */
     /* CONTAINS ERROR INFO FOR ERR^BADDESC */
);
#else
_tal _extensible short MEASCONFIGURE (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _near *,      /* OUT  */
                        /* MEASUREMENT NUMBER */
    short _far *,       /* IN  */
                        /* CONTAB CONTAINS ENTITY */
                        /* DESCRIPTORS OF ENTITIES TO BE MEASURED */
    long long _far *    /* OUT OPTIONAL  */
     /* CONTAINS ERROR INFO FOR ERR^BADDESC */
    );
#endif

#pragma section meascontrol
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASCONTROL (
    short _ptr32 *,     /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* MEASUREMENT NUMBER */
    long long ,         /* IN OPTIONAL  */
                        /* START TIME OF MEASUREMENT */
    long long ,         /* IN OPTIONAL  */
                        /* STOP TIME OF MEASUREMENT */
    long long           /* IN OPTIONAL  */
                        /* COPY COUNTERS AT TIME INTERVAL */
    );
#else
_tal _extensible short MEASCONTROL (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* MEASUREMENT NUMBER */
    long long ,         /* IN OPTIONAL  */
                        /* START TIME OF MEASUREMENT */
    long long ,         /* IN OPTIONAL  */
                        /* STOP TIME OF MEASUREMENT */
    long long           /* IN OPTIONAL  */
                        /* COPY COUNTERS AT TIME INTERVAL */
    );
#endif

#pragma section meascounterbump
#include <tnsint.h>
_tal _extensible short MEASCOUNTERBUMP (
    short ,                /* IN  */
                           /* OFFSET OF COUNTER, RETURNED BY A CALL TO */
                           /* MEASCOUNTERBUMPINIT. IT IS = # OF UDEF  */
                           /* COUNTERS BEFORE THIS COUNTER IN THE */
                           /*  UDEF-COUNTER RECORD. */
    short ,                /* IN  */
                           /* 1=INC, 2=ADD, 3=SET BUSY, */
                           /* 4=RESET BUSY, 5=INC QUEUE, 6=DEC QUEUE */
                           /* 7=INC QBUSY, 8=DEC QBUSY */
    short ,                /* IN OPTIONAL  */
                           /* ADD THIS TO COUNTER IF BUMPTYPE=2 */
    short ,                /* IN OPTIONAL  */
                           /* SELECTS ONE COUNTER IN AN ARRAY */
    __int32_t              /* IN OPTIONAL */
                           /* VALUE TO ADD TO COUNTER IF BUMPTYPE=2 */
                           /* SET COUNTER TO THIS IF BUMPTYPE=9 */
                           /*  SNAPSHOT or ACCUM */
#if (_TANDEM_ARCH_ != 1)   /* H-series and later */
  , long long              /* IN OPTIONAL */
                           /* VALUE TO ADD TO COUNTER IF BUMPTYPE=2 */
                           /* SET COUNTER TO THIS IF BUMPTYPE=9 */
                           /*  FSNAPSHOT or FACCUM */
#endif /* _TANDEM_ARCH_ != 1 */
    );

#pragma section meascounterbumpinit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASCOUNTERBUMPINIT (
    short _ptr32 *,      /* IN  */
                         /* COUNTER NAME */
    short _ptr32 *       /* OUT  */
                         /* OFFSET OF COUNTER */
#if _TANDEM_ARCH_ > 1    /* H-series only */
  , short                /* IN OPTIONAL */
                         /* SUBSYSTEM INSTRUMENTATION VERSION */
#endif /* _TANDEM_ARCH_ > 1 */
    );
#else
_tal _extensible short MEASCOUNTERBUMPINIT (
    short _near *,         /* IN  */
                           /* COUNTER NAME */
    short _near *          /* OUT  */
                           /* OFFSET OF COUNTER */
#if (_TANDEM_ARCH_ != 1)   /* H-series only */
  , short                  /* IN OPTIONAL */
                           /* SUBSYSTEM INSTRUMENTATION VERSION */
#endif /* _TANDEM_ARCH_ != 1 */
    );
#endif

#pragma section measgetversion
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASGETVERSION (
    short _ptr32 *,     /* IN  */
                        /* data file name in internal format (12 words) */
    short ,             /* IN  */
                        /* data file access number (i.e. MEASFH'S fnum) */
    short _ptr32 *,     /* OUT  */
                        /* <0:7>=system level, <8:15>= revision number */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* buffer where lengths of records are returned */
    short ,             /* IN OPTIONAL  */
                        /* length of BUFFER passed */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* System name where the data file is from */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* Array [0:1], For future use. */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* CPU type where data file was collected */
    , char _ptr32 *,    /* OUT OPTIONAL  */
                        /* buffer where System Serial Number is returned */
    short,              /* IN OPTIONAL  */
                        /* length of SYSIDBUF, required if SYSIDBUF present */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* length of SSN, required if SYSIDBUF is present */
    );
#else
_tal _extensible short MEASGETVERSION (
    short _far *,       /* IN  */
                        /* data file name in internal format (12 words) */
    short ,             /* IN  */
                        /* data file access number (i.e. MEASFH'S fnum) */
    short _near *,      /* OUT  */
                        /* <0:7>=system level, <8:15>= revision number */
    short _far *,       /* OUT OPTIONAL  */
                        /* buffer where lengths of records are returned */
    short ,             /* IN OPTIONAL  */
                        /* length of BUFFER passed */
    short _far *,       /* OUT OPTIONAL  */
                        /* System name where the data file is from */
    short _far *,       /* OUT OPTIONAL  */
                        /* Array [0:1], For future use. */
    short _far *        /* OUT OPTIONAL  */
                        /* CPU type where data file was collected */
#if (_TANDEM_ARCH_ != 1)
    , char _far *,      /* OUT OPTIONAL  */
                        /* buffer where System Serial Number is returned */
    short,              /* IN OPTIONAL  */
                        /* length of SYSIDBUF, required if SYSIDBUF present */
    short _far *        /* OUT OPTIONAL  */
                        /* length of SSN, required if SYSIDBUF is present */
#endif
    );
#endif

#pragma section measinfo
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASINFO (
    short _ptr32 *,       /* IN  */
                          /* data file name, 12 word format */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* configuration table */
    short ,               /* IN  */
                          /* size of the contab buffer in bytes */
    short _ptr32 *,       /* OUT  */
                          /* byte size of contab returned */
    long long _ptr32 *,   /* OUT OPTIONAL  */
                          /* measurement starttime */
    long long _ptr32 *,   /* OUT OPTIONAL  */
                          /* measurement stoptime */
    long long _ptr32 *,   /* OUT OPTIONAL  */
                          /* measurement counter copy interval */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* array containing the max # of entities under */
                          /* concurrent measurement, in entity type order */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* array containing the maximum # of words */
                          /* of counter space used, in entity type order */
    short ,               /* IN  */
                          /* : byte length of each array: ENTITIES,CTRSPACE */
    short _ptr32 *        /* OUT OPTIONAL  */

    );
#else
_tal _extensible short MEASINFO (
    short _far *,       /* IN  */
                        /* data file name, 12 word format */
    short _far *,       /* OUT OPTIONAL  */
                        /* configuration table */
    short ,             /* IN  */
                        /* size of the contab buffer in bytes */
    short _near *,      /* OUT  */
                        /* byte size of contab returned */
    long long _near *,  /* OUT OPTIONAL  */
                        /* measurement starttime */
    long long _near *,  /* OUT OPTIONAL  */
                        /* measurement stoptime */
    long long _near *,  /* OUT OPTIONAL  */
                        /* measurement counter copy interval */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* array containing the max # of entities under */
                        /* concurrent measurement, in entity type order */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* array containing the maximum # of words */
                        /* of counter space used, in entity type order */
    short ,             /* IN  */
                        /* : byte length of each array: ENTITIES,CTRSPACE */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section measlistconfig
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTCONFIG (
    short ,             /* IN  */
                        /* CPU NUMBER */
    short ,             /* IN  */
                        /* ENTITY TYPE */
    short _ptr32 *,     /* OUT  */
                        /* DESTINATION OF ENTITY DESCRIPTORS */
    short ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
    short _ptr32 *,     /* OUT  */
                        /* BYTE SIZE OF RECORD RETURNED */
    long long _ptr32 *  /* IN/OUT  */
                        /* FIRST CALL FLAG */
    );
#else
_tal _extensible short MEASLISTCONFIG (
    short ,             /* IN  */
                        /* CPU NUMBER */
    short ,             /* IN  */
                        /* ENTITY TYPE */
    short _far *,       /* OUT  */
                        /* DESTINATION OF ENTITY DESCRIPTORS */
    short ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
    short _near *,      /* OUT  */
                        /* BYTE SIZE OF RECORD RETURNED */
    long long _near *   /* IN/OUT  */
                        /* FIRST CALL FLAG */
    );
#endif

#pragma section measlistename
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTENAME (
    short ,              /* IN */
                         /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,      /* IN */
                         /* FILENAME IN INTERNAL FORMAT OR PATHID */
    short _ptr32 *,      /* IN OPTIONAL*/
                         /* EXPAND SYSTEM NAME OF THE FILE */
    short _ptr32 *,      /* IN OPTIONAL*/
                         /* CREATION VIRTUAL SEQUENCE NUMBER OF THE
                           FILE */
    short _ptr32 *,      /* OUT OPTIONAL*/
                         /* OSS OR SQL PATHID */
    char _ptr32 *,       /* OUT OPTIONAL*/
                         /* OSS PATHNAME OR ANSI SQL NAME BUFFER */
    short ,              /* IN OPTIONAL*/
                         /* MAXIMUM BYTE LENGTH OF FILENAME BUFFER */
    short _ptr32 *,      /* OUT OPTIONAL*/
                         /* ACTUAL BYTE LENGHT OF OSS OR ANSI SQL NAME */
    long long _ptr32 *,  /* IN/OUT OPTIONAL*/
                         /* CONTEXT VALUE FOR ITERATIVE CALLS */
    short _ptr32 *,      /* OUT OPTIONAL*/
                         /* TYPE OF EXTNAME FOR GUARDIAN FILENAME OR MID */
    short _ptr32 *,      /* OUT OPTIONAL*/
                         /* CREATION VIRTUAL SEQUENCE NUMBER OF THE FILE */
    short ,              /* IN OPTIONAL */
                         /* Missing parameter/parameter value = 0
                               OSS file    => full OSS pathname
                               SQL/MX file => SQL/MX partition name
                           Parameter Value = 1
                               OSS file    => full OSS pathname
                               SQL/MX file => SQL/MX object name */
    short ,              /* IN OPTIONAL */
                                 /*  Required parameter if the data is
                                    is an ANS UID, else it is optional */
    __int32_t _ptr32 *   /* IN OPTIONAL */
    );

#else
_tal _extensible short MEASLISTENAME (
    short ,             /* IN */
                        /* DATA FILE ACCESS NUMBER */
    short _far *,       /* IN */
                        /* FILENAME IN INTERNAL FORMAT OR PATHID */
    short _far *,       /* IN OPTIONAL*/
                        /* EXPAND SYSTEM NAME OF THE FILE */
    short _far *,       /* IN OPTIONAL*/
                        /* CREATION VIRTUAL SEQUENCE NUMBER OF THE
                           FILE */
    short _far *,       /* OUT OPTIONAL*/
                        /* OSS OR SQL PATHID */
    char _far *,        /* OUT OPTIONAL*/
                        /* OSS PATHNAME OR ANSI SQL NAME BUFFER */
    short ,             /* IN OPTIONAL*/
                        /* MAXIMUM BYTE LENGTH OF FILENAME BUFFER */
    short _near *,      /* OUT OPTIONAL*/
                        /* ACTUAL BYTE LENGHT OF OSS OR ANSI SQL NAME */
    long long _near *,  /* IN/OUT OPTIONAL*/
                        /* CONTEXT VALUE FOR ITERATIVE CALLS */
    short _near *,      /* OUT OPTIONAL*/
                        /* TYPE OF EXTNAME FOR GUARDIAN FILENAME OR MID */
    short _near *,      /* OUT OPTIONAL*/
                        /* CREATION VIRTUAL SEQUENCE NUMBER OF THE FILE */
    short ,             /* IN OPTIONAL */
                        /* Missing parameter/parameter value = 0
                               OSS file    => full OSS pathname
                               SQL/MX file => SQL/MX partition name
                           Parameter Value = 1
                               OSS file    => full OSS pathname
                               SQL/MX file => SQL/MX object name */
    short ,             /* IN OPTIONAL */
                                 /*  Required parameter if the data is
                                    is an ANS UID, else it is optional */
    __int32_t _far *    /* IN OPTIONAL */
    );
#endif

#pragma section measlistextnames
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTEXTNAMES (
    short ,             /* IN */
                        /* DATA FILE ACCESS NUMBER */
    short _ptr32 *      /* IN */
                        /* VOLUME AND SUBVOLUME FOR STRUCTURED FILE */
    );
#else
_tal _extensible short MEASLISTEXTNAMES (
    short ,             /* IN */
                        /* DATA FILE ACCESS NUMBER */
    short _far *        /* IN */
                        /* VOLUME AND SUBVOLUME FOR STRUCTURED FILE */
    );
#endif

#pragma section measlistgname
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTGNAME (
    short ,              /* IN OPTIONAL  */
                         /* DATA FILE ACCESS NUMBER */
    char _ptr32 *,       /* IN  */
                         /* OSS PATHNAME TO TRANSLATE */
    short ,              /* IN  */
                         /* LENGTH OF THE PATHNAME */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* FILENAME IN INTERNAL FORMAT */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* EXPAND SYSTEM NAME OF THE FILE */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* OSS PATHID */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* CREATION VOLUME SEQUENCE NUMBER */
    char _ptr32 *,       /* OUT OPTIONAL  */
                         /* OSS CHILDNAME BUFFER RETURNED */
    short ,              /* IN OPTIONAL  */
                         /* MAX LENGTH OF CHILDNAME BUFFER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* LENGTH OF THE CHILDNAME RETURNED */
    long long _ptr32 *,  /* IN/OUT OPTIONAL  */
                         /* CONTEXT FOR ITERATIVE CALLING */
    short ,              /* IN OPTIONAL */
                                 /*  MEAS_OSS_PATHNAME = 1 OR */
                                 /*  MEAS_ANSI_SQL_NAME = 2   */
    __int32_t _ptr32 *   /* IN OPTIONAL */
    );
#else
_tal _extensible short MEASLISTGNAME (
    short ,             /* IN OPTIONAL  */
                        /* DATA FILE ACCESS NUMBER */
    char _far *,        /* IN  */
                        /* OSS PATHNAME TO TRANSLATE */
    short ,             /* IN  */
                        /* LENGTH OF THE PATHNAME */
    short _far *,       /* OUT OPTIONAL  */
                        /* FILENAME IN INTERNAL FORMAT */
    short _far *,       /* OUT OPTIONAL  */
                        /* EXPAND SYSTEM NAME OF THE FILE */
    short _far *,       /* OUT OPTIONAL  */
                        /* OSS PATHID */
    short _far *,       /* OUT OPTIONAL  */
                        /* CREATION VOLUME SEQUENCE NUMBER */
    char _far *,        /* OUT OPTIONAL  */
                        /* OSS CHILDNAME BUFFER RETURNED */
    short ,             /* IN OPTIONAL  */
                        /* MAX LENGTH OF CHILDNAME BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* LENGTH OF THE CHILDNAME RETURNED */
    long long _near *,  /* IN/OUT OPTIONAL  */
                        /* CONTEXT FOR ITERATIVE CALLING */
    short ,             /* IN OPTIONAL */
                                 /*  MEAS_OSS_PATHNAME = 1 OR */
                                 /*  MEAS_ANSI_SQL_NAME = 2   */
    __int32_t _far *    /* IN OPTIONAL */
    );
#endif

#pragma section measlistossnames
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTOSSNAMES (
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _ptr32 *      /* IN  */
                        /* VOLUME AND SUBVOLUME FOR THE STRUCTURED FILE */
    );
#else
_tal _extensible short MEASLISTOSSNAMES (
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _far *        /* IN  */
                        /* VOLUME AND SUBVOLUME FOR THE STRUCTURED FILE */
    );
#endif

#pragma section measlistpname
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASLISTPNAME (
    short ,               /* IN OPTIONAL  */
                          /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,       /* IN  */
                          /* FILENAME IN INTERNAL FORMAT OR PATHID */
    short _ptr32 *,       /* IN OPTIONAL  */
                          /* EXPAND SYSTEM NAME OF THE FILE */
    short _ptr32 *,       /* IN OPTIONAL  */
                          /* CREATION VIRTUAL SEQUENCE NUMBER */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* OSS PATHID OF OSS FILE PATHNAME */
    char _ptr32 *,        /* OUT OPTIONAL  */
                          /* OSS FILE PATHNAME BUFFER */
    short ,               /* IN OPTIONAL  */
                          /* MAX LENGTH OSS FILE PATHNAME BUFFER */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* LENGTH OF THE ACTUAL PATHNAME */
    long long _ptr32 *    /* IN/OUT OPTIONAL  */
                          /* CONTEXT VALUE FOR ITERATIVE CALLS */
    );
#else
_tal _extensible short MEASLISTPNAME (
    short ,             /* IN OPTIONAL  */
                        /* DATA FILE ACCESS NUMBER */
    short _far *,       /* IN  */
                        /* FILENAME IN INTERNAL FORMAT OR PATHID */
    short _far *,       /* IN OPTIONAL  */
                        /* EXPAND SYSTEM NAME OF THE FILE */
    short _far *,       /* IN OPTIONAL  */
                        /* CREATION VIRTUAL SEQUENCE NUMBER */
    short _far *,       /* OUT OPTIONAL  */
                        /* OSS PATHID OF OSS FILE PATHNAME */
    char _far *,        /* OUT OPTIONAL  */
                        /* OSS FILE PATHNAME BUFFER */
    short ,             /* IN OPTIONAL  */
                        /* MAX LENGTH OSS FILE PATHNAME BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* LENGTH OF THE ACTUAL PATHNAME */
    long long _near *   /* IN/OUT OPTIONAL  */
                        /* CONTEXT VALUE FOR ITERATIVE CALLS */
    );
#endif

#pragma section measmoncontrol
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASMONCONTROL (
    short _ptr32 *,     /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* TRUE MEANS START MEASURE, ELSE STOP IT */
    short ,             /* IN OPTIONAL  */
                        /* START ONE MEASCTL IN CPU NUMBER */
    short _ptr32 *      /* OUT OPTIONAL */
                        /* ERROR DETAIL RETURNED FROM PROCESS_CREATE*/
    );
#else
_tal _extensible short MEASMONCONTROL (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* TRUE MEANS START MEASURE, ELSE STOP IT */
    short ,             /* IN OPTIONAL  */
                        /* START ONE MEASCTL IN CPU NUMBER */
    short _near *       /* OUT OPTIONAL */
                        /* ERROR DETAIL RETURNED FROM PROCESS_CREATE*/
    );
#endif

#pragma section measmonstatus
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASMONSTATUS (
    short _ptr32 *,      /* IN/OUT  */
                         /* MEASURE CONTROL BLOCK */
    short _ptr32 *,      /* OUT  */
                         /* NUMBER CURRENTLY ACTIVE MEASUREMENTS */
    short _ptr32 *,      /* OUT  */
                         /* LIST OF CURRENTLY ACTIVE MEASUREMENT */
                         /* DATA FILE NAMES; EACH ENTRY IS IN 12 WORD */
                         /* FORMAT; THEY ARE ORDERED BY MEASNUM */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* FLAGS IDENTIFYING CURRENT SETTING OF */
                         /* MEASURE SUBSYSTEM DEFINES */
    );
#else
_tal _extensible short MEASMONSTATUS (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short _near *,      /* OUT  */
                        /* NUMBER CURRENTLY ACTIVE MEASUREMENTS */
    short _far *,       /* OUT  */
                        /* LIST OF CURRENTLY ACTIVE MEASUREMENT */
                        /* DATA FILE NAMES; EACH ENTRY IS IN 12 WORD */
                        /* FORMAT; THEY ARE ORDERED BY MEASNUM */
    short _near *       /* OUT OPTIONAL  */
                        /* FLAGS IDENTIFYING CURRENT SETTING OF */
                        /* MEASURE SUBSYSTEM DEFINES */
    );
#endif

#pragma section measopen
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASOPEN (
    short _ptr32 *,      /* IN  */
                         /* DATA FILE NAME, 12 WORD FORMAT */
    short _ptr32 *,      /* OUT  */
                         /* DATA FILE ACCESS NUMBER */
    short ,              /* IN  */
                         /* TRUE => INITIALIZE FOR NEW MEASUREMENT */
    short ,              /* IN  */
                         /* TRUE => PROVIDE READ ACCESS */
    short _ptr32 *,      /* IN OPTIONAL  */
                         /* MEASFH PROGRAM FILE NAME */
    short _ptr32 *,      /* IN OPTIONAL  */
                         /* VOLUME FOR MEASFH'S WORK FILES, 4 WORDS */
    short ,              /* IN OPTIONAL  */
                         /* CPU IN WHICH TO CREATE MEASFH process */
    short ,              /* IN OPTIONAL  */
                         /* ARRAY OF FLAGS QUALIFYING THE OPEN REQUEST */
    long long            /* IN OPTIONAL  */
                         /* Desired File Size in Bytes */
    );

#else
_tal _extensible short MEASOPEN (
    short _near *,      /* IN  */
                        /* DATA FILE NAME, 12 WORD FORMAT */
    short _near *,      /* OUT  */
                        /* DATA FILE ACCESS NUMBER */
    short ,             /* IN  */
                        /* TRUE => INITIALIZE FOR NEW MEASUREMENT */
    short ,             /* IN  */
                        /* TRUE => PROVIDE READ ACCESS */
    short _near *,      /* IN OPTIONAL  */
                        /* MEASFH PROGRAM FILE NAME */
    short _near *,      /* IN OPTIONAL  */
                        /* VOLUME FOR MEASFH'S WORK FILES, 4 WORDS */
    short ,             /* IN OPTIONAL  */
                        /* CPU IN WHICH TO CREATE MEASFH process */
    short ,             /* IN OPTIONAL  */
                        /* ARRAY OF FLAGS QUALIFYING THE OPEN REQUEST */
    long long           /* IN OPTIONAL  */
                        /* Desired File Size in Bytes */
    );
#endif

#pragma section measread
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASREAD (
    short ,               /* IN  */
                          /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,       /* IN  */
                          /* ENTITY DESCRIPTOR */
    short _ptr32 *,       /* OUT  */
                          /* DESTINATION OF COUNTER RECORD */
    short ,               /* IN  */
                          /* BYTE SIZE OF DESTINATION BUFFER */
    short _ptr32 *,       /* OUT  */
                          /* BYTE SIZE OF RECORD(S) RETURNED */
    long long _ptr32 *,   /* IN/OUT  */
                          /* SET TO 0 ON FIRST CALL, SAVE */
                          /* RETURNED VALUE FOR SUBSEQUENT CALLS */
                          /* WITH SAME ENTITY ID */
    long long ,           /* IN OPTIONAL  */
                          /* NOMINAL TIME OF COUNTER DATA */
    long long ,           /* IN OPTIONAL  */
                          /* TIME TOLERACE OF COUNTER DATA */
    short,                /* IN OPTIONAL  */
                          /* Current version of the Data File. */
    long long             /* IN OPTIONAL  */
                          /* TEMPLATE-VERSION constant found in MEASDDLS, */
                          /* specifying format for returned records */
    );
#else
_tal _extensible short MEASREAD (
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _near *,      /* IN  */
                        /* ENTITY DESCRIPTOR */
    short _far *,       /* OUT  */
                        /* DESTINATION OF COUNTER RECORD */
    short ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
    short _near *,      /* OUT  */
                        /* BYTE SIZE OF RECORD(S) RETURNED */
    long long _near *,  /* IN/OUT  */
                        /* SET TO 0 ON FIRST CALL, SAVE */
                        /* RETURNED VALUE FOR SUBSEQUENT CALLS */
                        /* WITH SAME ENTITY ID */
    long long ,         /* IN OPTIONAL  */
                        /* NOMINAL TIME OF COUNTER DATA */
    long long ,         /* IN OPTIONAL  */
                        /* TIME TOLERACE OF COUNTER DATA */
    short,              /* IN OPTIONAL  */
                        /* Current version of the Data File. */
    long long           /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
                        /* specifying format for returned records */
    );
#endif

#pragma section measreadactive
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASREADACTIVE (
    short _ptr32 *,      /* IN/OUT  */
                         /* MEASURE CONTROL BLOCK */
    short ,              /* IN  */
                         /* MEASUREMENT NUMBER */
    short _ptr32 *,      /* IN  */
                         /* ENTITY DESCRIPTOR */
    short _ptr32 *,      /* OUT  */
                         /* DESTINATION OF COUNTER RECORD */
    short ,              /* IN  */
                         /* BYTE SIZE OF DESTINATION BUFFER */
    short _ptr32 *,      /* OUT  */
                         /* BYTE SIZE OF RECORD RETURNED */
    long long _ptr32 *,  /* IN/OUT OPTIONAL  */
                         /* REQUIRED PARAMETER FOR DISKFILE ENTITY */
                         /* INDEX TO INTERNAL ENTITY TABLE */
                         /* SET TO -1F FOR FIRST CALL */
                         /* SAVE RETURNED VALUE FOR SUBSEQUENT */
                         /* CALLS WITH SAME ENTITY DESCRIPTOR */
    long long            /* IN OPTIONAL  */
                         /* TEMPLATE-VERSION constant found in MEASDDLS, */
                         /* specifying format for returned records */
    );
#else
_tal _extensible short MEASREADACTIVE (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* MEASUREMENT NUMBER */
    short _near *,      /* IN  */
                        /* ENTITY DESCRIPTOR */
    short _far *,       /* OUT  */
                        /* DESTINATION OF COUNTER RECORD */
    short ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
    short _near *,      /* OUT  */
                        /* BYTE SIZE OF RECORD RETURNED */
    long long _near *,  /* IN/OUT OPTIONAL  */
                        /* REQUIRED PARAMETER FOR DISKFILE ENTITY */
                        /* INDEX TO INTERNAL ENTITY TABLE */
                        /* SET TO -1F FOR FIRST CALL */
                        /* SAVE RETURNED VALUE FOR SUBSEQUENT */
                        /* CALLS WITH SAME ENTITY DESCRIPTOR */
    long long           /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
                        /* specifying format for returned records */
    );
#endif

#pragma section meas_readactive_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
 _tal _extensible short MEAS_READACTIVE_ (
     short _ptr32 *,      /* IN/OUT  */
                          /* MEASURE CONTROL BLOCK */
     short ,              /* IN  */
                          /* MEASUREMENT NUMBER */
     short _ptr32 *,      /* IN  */
                          /* ENTITY DESCRIPTOR */
     short _ptr32 *,      /* OUT  */
                          /* DESTINATION OF COUNTER RECORD */
     __int32_t ,          /* IN  */
                          /* BYTE SIZE OF DESTINATION BUFFER */
     __int32_t _ptr32 *,  /* OUT  */
                          /* BYTE SIZE OF RECORD RETURNED */
     long long _ptr32 *,  /* IN/OUT OPTIONAL  */
                          /* REQUIRED PARAMETER FOR DISKFILE ENTITY */
                          /* INDEX TO INTERNAL ENTITY TABLE */
                          /* SET TO -1F FOR FIRST CALL */
                          /* SAVE RETURNED VALUE FOR SUBSEQUENT */
                          /* CALLS WITH SAME ENTITY DESCRIPTOR */
     long long            /* IN OPTIONAL  */
                          /* TEMPLATE-VERSION constant found in MEASDDLS, */
    );                    /* specifying format for returned records */
#else
 _tal _extensible short MEAS_READACTIVE_ (
     short _near *,     /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
     short ,            /* IN  */
                        /* MEASUREMENT NUMBER */
     short _near *,     /* IN  */
                        /* ENTITY DESCRIPTOR */
     short _far *,      /* OUT  */
                        /* DESTINATION OF COUNTER RECORD */
     __int32_t ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
     __int32_t _near *,      /* OUT  */
                        /* BYTE SIZE OF RECORD RETURNED */
     long long _near *, /* IN/OUT OPTIONAL  */
                        /* REQUIRED PARAMETER FOR DISKFILE ENTITY */
                        /* INDEX TO INTERNAL ENTITY TABLE */
                        /* SET TO -1F FOR FIRST CALL */
                        /* SAVE RETURNED VALUE FOR SUBSEQUENT */
                        /* CALLS WITH SAME ENTITY DESCRIPTOR */
     long long          /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
    );                  /* specifying format for returned records */
#endif

#pragma section meas_readactive_many_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEAS_READACTIVE_MANY_ (
      short ,              /* IN  */
                           /* MEASUREMENT NUMBER */
      short ,              /* IN  */
                           /* MODE */
      short  _ptr32 *,     /* IN  */
                           /* ENTITY DESCRIPTOR */
      short  _ptr32 *,     /* IN  */
                           /* DESTINATION OF COUNTER RECORD */
      __int32_t ,          /* IN  */
                           /* BYTE SIZE OF DESTINATION BUFFER */
      short  _ptr32 *,     /* OUT  */
                           /* NUMBER OF RECORDS RETURNED */
      long long _ptr32 *,  /* IN/OUT  */
                           /* CONTEXT */
                           /* SET TO -1F OR 0F FOR FIRST CALL */
                           /* CHECK FOR 0F RETURN FOR END-OF-ENTITIES */
                           /* INDICATOR */
                           /* IF -1F IS RETURNED, THEN CHECK ERROR  */
                           /* IF RETURN NOT -1F OR 0F, AND NO ERROR, */
                           /* AND MODE IS LIST OR */
                           /* CHANGE-RECORDS */
                           /* THEN CALL THIS PROCEDURE ITERATIVELY, */
                           /* UNTIL 0F OR ERROR */
                           /* IF MODE IS EXACT, THEN CALL WITH THE */
                           /* RETURNED CONTEXT, FOR */
                           /* SAME ENTITY DESCRIPTOR */
      long long            /* IN OPTIONAL  */
                           /* TEMPLATE-VERSION constant found in */
                           /* MEASDDLS, */
     );                    /* specifying format for returned records */
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short MEAS_READACTIVE_MANY_ (
      short ,            /* IN  */
                         /* MEASUREMENT NUMBER */
      short ,            /* IN  */
                         /* MODE */
      short  _far *,     /* IN  */
                         /* ENTITY DESCRIPTOR */
      short  _far *,     /* IN  */
                         /* DESTINATION OF COUNTER RECORD */
      __int32_t ,        /* IN  */
                         /* BYTE SIZE OF DESTINATION BUFFER */
      short  _far *,     /* OUT  */
                         /* NUMBER OF RECORDS RETURNED */
      long long _far *,  /* IN/OUT  */
                         /* CONTEXT */
                         /* SET TO -1F OR 0F FOR FIRST CALL */
                         /* CHECK FOR 0F RETURN FOR END-OF-ENTITIES */
                         /* INDICATOR */
                         /* IF -1F IS RETURNED, THEN CHECK ERROR  */
                         /* IF RETURN NOT -1F OR 0F, AND NO ERROR, */
                         /* AND MODE IS LIST OR */
                         /* CHANGE-RECORDS */
                         /* THEN CALL THIS PROCEDURE ITERATIVELY, */
                         /* UNTIL 0F OR ERROR */
                         /* IF MODE IS EXACT, THEN CALL WITH THE */
                         /* RETURNED CONTEXT, FOR */
                         /* SAME ENTITY DESCRIPTOR */
      long long          /* IN OPTIONAL  */
                         /* TEMPLATE-VERSION constant found in */
                         /* MEASDDLS, */
     );                  /* specifying format for returned records */
#endif


#pragma section measreadconf
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASREADCONF (
    short ,              /* IN  */
                         /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* CONTAB */
    short ,              /* IN OPTIONAL  */
                         /* BYTE SIZE OF CONTAB DESTINATION BUFFER */
    short _ptr32 *,      /* OUT  OPTIONAL*/
                         /* BYTE SIZE OF CONTAB RETURNED */
    long long _ptr32 *,  /* OUT  OPTIONAL */
                         /* START TIME OF MEASUREMENT */
    long long _ptr32 *,  /* OUT  OPTIONAL */
                         /* STOP TIME OF MEASUREMENT */
    long long _ptr32 *,  /* OUT  OPTIONAL */
                         /* COPY COUNTERS AT TIME INTERVAL */
    __int32_t _ptr32 *,  /* OUT  OPTIONAL */
                         /* ARRAY CONTAINING THE MAXIMUM NUMBER OF */
                         /* ENTITIES UNDER CONCURRENT MEASUREMENT, IN */
                         /* ENTITY TYPE ORDER */
    __int32_t _ptr32 *,  /* OUT  OPTIONAL */
                         /* ARRAY CONTAINING THE MAXIMUM NUMBER OF */
                         /* WORDS OF COUNTER SPACE USED, IN ENTITY */
                         /* TYPE ORDER */
    short ,              /* IN  OPTIONAL */
                         /* VERSION OF THE DATA FILE DFNUM */
    short ,              /* IN OPTIONAL  */
                         /* MAX # OF ENTITIES THE CALLER ASSUMED */
    short _ptr32 *       /* OUT OPTIONAL  */
    );
#else
_tal _extensible short MEASREADCONF (
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _far *,       /* OUT OPTIONAL  */
                        /* CONTAB */
    short ,             /* IN OPTIONAL  */
                        /* BYTE SIZE OF CONTAB DESTINATION BUFFER */
    short _near *,      /* OUT  OPTIONAL*/
                        /* BYTE SIZE OF CONTAB RETURNED */
    long long _near *,  /* OUT  OPTIONAL */
                        /* START TIME OF MEASUREMENT */
    long long _near *,  /* OUT  OPTIONAL */
                        /* STOP TIME OF MEASUREMENT */
    long long _near *,  /* OUT  OPTIONAL */
                        /* COPY COUNTERS AT TIME INTERVAL */
    __int32_t _near *,  /* OUT  OPTIONAL */
                        /* ARRAY CONTAINING THE MAXIMUM NUMBER OF */
                        /* ENTITIES UNDER CONCURRENT MEASUREMENT, IN */
                        /* ENTITY TYPE ORDER */
    __int32_t _near *,  /* OUT  OPTIONAL */
                        /* ARRAY CONTAINING THE MAXIMUM NUMBER OF */
                        /* WORDS OF COUNTER SPACE USED, IN ENTITY */
                        /* TYPE ORDER */
    short ,             /* IN  OPTIONAL */
                        /* VERSION OF THE DATA FILE DFNUM */
    short ,             /* IN OPTIONAL  */
                        /* MAX # OF ENTITIES THE CALLER ASSUMED */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section measread_diff_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASREAD_DIFF_ (
    short ,               /* IN  */
                          /* DATA FILE ACCESS NUMBER */
    short _ptr32 *,       /* IN  */
                          /* ENTITY DESCRIPTOR */
    short _ptr32 *,       /* OUT  */
                          /* DESTINATION OF COUNTER RECORD */
    short ,               /* IN  */
                          /* BYTE SIZE OF DESTINATION BUFFER */
    short _ptr32 *,       /* OUT  */
                          /* BYTE SIZE OF RECORD(S) RETURNED */
    long long _ptr32 *,   /* IN/OUT  */
                          /* SET TO 0 ON FIRST CALL, SAVE */
                          /* RETURNED VALUE FOR SUBSEQUENT CALLS */
                          /* WITH SAME ENTITY ID */
    long long ,           /* IN  */
                          /* From Time of the Counter Data */
    long long ,           /* IN  */
                          /* To Time of the COUNTER DATA */
    long long ,           /* IN OPTIONAL  */
                          /* TIME TOLERACE OF COUNTER DATA */
    short ,               /* IN OPTIONAL  */
                          /* Current version of the Data File */
    short ,               /* IN OPTIONAL  */
                          /* True if all interval recs are to requested */
    short ,               /* IN OPTIONAL  */
                          /* 0 --> if zero-reports include */
                          /* : 1 --> if zero-reports exclude */
    short ,               /* IN OPTIONAL  */
                          /* 0 --> Totals report exclude */
                          /* : 1 --> Totals report include */
                          /* : 2 --> Totals report only */
    short _ptr32 *,       /* IN OPTIONAL  */
                          /* Array [0:3] holding the load ID for */
                          /* the records */
    short _ptr32 *,       /* IN OPTIONAL  */
                          /* Struct type If^Item^Def */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* Holds the number of totals records */
    long long             /* IN OPTIONAL  */
                          /* TEMPLATE-VERSION constant found in MEASDDLS, */
                          /* specifying format for returned records */
    );
#else
_tal _extensible short MEASREAD_DIFF_ (
    short ,             /* IN  */
                        /* DATA FILE ACCESS NUMBER */
    short _far *,       /* IN  */
                        /* ENTITY DESCRIPTOR */
    short _far *,       /* OUT  */
                        /* DESTINATION OF COUNTER RECORD */
    short ,             /* IN  */
                        /* BYTE SIZE OF DESTINATION BUFFER */
    short _far *,       /* OUT  */
                        /* BYTE SIZE OF RECORD(S) RETURNED */
    long long _far *,   /* IN/OUT  */
                        /* SET TO 0 ON FIRST CALL, SAVE */
                        /* RETURNED VALUE FOR SUBSEQUENT CALLS */
                        /* WITH SAME ENTITY ID */
    long long ,         /* IN  */
                        /* From Time of the Counter Data */
    long long ,         /* IN  */
                        /* To Time of the COUNTER DATA */
    long long ,         /* IN OPTIONAL  */
                        /* TIME TOLERACE OF COUNTER DATA */
    short ,             /* IN OPTIONAL  */
                        /* Current version of the Data File */
    short ,             /* IN OPTIONAL  */
                        /* True if all interval recs are to requested */
    short ,             /* IN OPTIONAL  */
                        /* 0 --> if zero-reports include */
                        /* : 1 --> if zero-reports exclude */
    short ,             /* IN OPTIONAL  */
                        /* 0 --> Totals report exclude */
                        /* : 1 --> Totals report include */
                        /* : 2 --> Totals report only */
    short _far *,       /* IN OPTIONAL  */
                        /* Array [0:3] holding the load ID for */
                        /* the records */
    short _far *,       /* IN OPTIONAL  */
                        /* Struct type If^Item^Def */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* Holds the number of totals records */
    long long           /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
                        /* specifying format for returned records */
    );
#endif

#pragma section measstatus
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASSTATUS (
    short _ptr32 *,      /* IN/OUT  */
                         /* MEASURE CONTROL BLOCK */
    short ,              /* IN  */
                         /* MEASUREMENT NUMBER */
    short _ptr32 *,      /* OUT  */
                         /* BITS SHOW CPUS USED FOR MEASUREMENT */
    long long _ptr32 *,  /* OUT  */
                         /* START TIME OF MEASUREMENT */
    long long _ptr32 *,  /* OUT  */
                         /* STOP TIME OF MEASUREMENT */
    long long _ptr32 *,  /* OUT  */
                         /* COPY COUNTERS AT TIME INTERVAL */
    __int32_t _ptr32 *,  /* OUT  */
                         /* ARRAY CONTAINING THE NUMBER OF */
                         /* ENTITIES UNDER MEASUREMENT, IN ENTITY */
                         /* TYPE ORDER */
    __int32_t _ptr32 *,  /* OUT  */
                         /* ARRAY CONTAINING THE NUMBER OF WORDS */
                         /* OF CURRENT COUNTER SPACE INUSE, IN ENTITY */
                         /* TYPE ORDER */
    short ,              /* IN OPTIONAL  */
                         /* MAXIMUM NUMBER OF ENTITIES THE CALLER USES */
    short _ptr32 *       /* OUT OPTIONAL  */
    );
#else
_tal _extensible short MEASSTATUS (
    short _near *,      /* IN/OUT  */
                        /* MEASURE CONTROL BLOCK */
    short ,             /* IN  */
                        /* MEASUREMENT NUMBER */
    short _near *,      /* OUT  */
                        /* BITS SHOW CPUS USED FOR MEASUREMENT */
    long long _near *,  /* OUT  */
                        /* START TIME OF MEASUREMENT */
    long long _near *,  /* OUT  */
                        /* STOP TIME OF MEASUREMENT */
    long long _near *,  /* OUT  */
                        /* COPY COUNTERS AT TIME INTERVAL */
    __int32_t _near *,  /* OUT  */
                        /* ARRAY CONTAINING THE NUMBER OF */
                        /* ENTITIES UNDER MEASUREMENT, IN ENTITY */
                        /* TYPE ORDER */
    __int32_t _near *,  /* OUT  */
                        /* ARRAY CONTAINING THE NUMBER OF WORDS */
                        /* OF CURRENT COUNTER SPACE INUSE, IN ENTITY */
                        /* TYPE ORDER */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM NUMBER OF ENTITIES THE CALLER USES */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section measwrite_diff_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MEASWRITE_DIFF_ (
    short ,             /* IN  */
                        /* Datafile Number */
    short _ptr32 *,     /* IN  */
                        /* Entity Descriptor */
    short _ptr32 *,     /* IN  */
                        /* Volume & SubVolume for the Structured file */
    long long ,         /* IN  OPTIONAL */
                        /* Start time of the window */
    long long ,         /* IN  OPTIONAL */
                        /* Stop time of the window */
    long long ,         /* IN  OPTIONAL */
                        /* Interval tolerance */
    short ,             /* IN  OPTIONAL */
                        /* Version of the Datafile */
    short ,             /* IN  OPTIONAL */
                        /* Every Interval in the window */
    short ,             /* IN OPTIONAL  */
                        /* Zero Reports option (on/off) */
    short ,             /* IN OPTIONAL  */
                        /* : 0 --> exclude */
                        /* : 1 --> include */
                        /* : 2 --> only */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* Load^Id for interval records, array [0:3] */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* struct IF^ITEM^DEF */
    long long           /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
                        /* specifying format for returned records */
    );
#else
_tal _extensible short MEASWRITE_DIFF_ (
    short ,             /* IN  */
                        /* Datafile Number */
    short _far *,       /* IN  */
                        /* Entity Descriptor */
    short _far *,       /* IN  */
                        /* Volume & SubVolume for the Structured file */
    long long ,         /* IN  OPTIONAL */
                        /* Start time of the window */
    long long ,         /* IN  OPTIONAL */
                        /* Stop time of the window */
    long long ,         /* IN  OPTIONAL */
                        /* Interval tolerance */
    short ,             /* IN  OPTIONAL */
                        /* Version of the Datafile */
    short ,             /* IN  OPTIONAL */
                        /* Every Interval in the window */
    short ,             /* IN OPTIONAL  */
                        /* Zero Reports option (on/off) */
    short ,             /* IN OPTIONAL  */
                        /* : 0 --> exclude */
                        /* : 1 --> include */
                        /* : 2 --> only */
    short _far *,       /* IN OPTIONAL  */
                        /* Load^Id for interval records, array [0:3] */
    short _far *,       /* IN OPTIONAL  */
                        /* struct IF^ITEM^DEF */
    long long           /* IN OPTIONAL  */
                        /* TEMPLATE-VERSION constant found in MEASDDLS, */
                        /* specifying format for returned records */
    );
#endif

#pragma section messagestatus
_tal _extensible short MESSAGESTATUS (
    short               /* IN OPTIONAL  */
    );

#pragma section messagesysteminfo
_tal _extensible short MESSAGESYSTEMINFO (
    short ,             /* IN  */
    short _far *        /* OUT  */
    );

#pragma section mfm_awaitiox_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status MFM_AWAITIOX_ (
    short _ptr32 *,       /* OUT  */
                          /* status returned (for pseudofiles only) */
    short _ptr32 *,       /* IN/OUT  */
                          /* (pseudo)file number */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* buffer address associated with completion */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* bytes transferred */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* application-defined tag */
    __int32_t ,           /* IN OPTIONAL  */
                          /* time limit for wait */
    short _ptr32 *        /* OUT OPTIONAL  */
                          /* segment id of buffer^addr */
    );
#else
_tal _extensible _cc_status MFM_AWAITIOX_ (
    short _far *,       /* OUT  */
                        /* status returned (for pseudofiles only) */
    short _far *,       /* IN/OUT  */
                        /* (pseudo)file number */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* buffer address associated with completion */
    short _far *,       /* OUT OPTIONAL  */
                        /* bytes transferred */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* application-defined tag */
    __int32_t ,         /* IN OPTIONAL  */
                        /* time limit for wait */
    short _far *        /* OUT OPTIONAL  */
                        /* segment id of buffer^addr */
    );
#endif

#pragma section mfm_cancelreq_
#include <tnsint.h>
_tal _extensible short MFM_CANCELREQ_ (
    short ,             /* IN  */
    __int32_t           /* IN OPTIONAL  */
    );

#pragma section mom
#if (_TANDEM_ARCH_ > 1)
_tal void MOM (
    short _ptr32 *       /* OUT  */
    );
#else
_tal void MOM (
    short _near *        /* OUT  */
    );
#endif

#pragma section monitorcpus
_tal void MONITORCPUS (
    short               /* IN  */
    );

#pragma section monitornet
_tal void MONITORNET (
    short               /* IN  */
    );

#pragma section monitornew
_tal void MONITORNEW (
    short               /* IN  */
    );

#pragma section movex
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short MOVEX (
    short ,               /* IN OPTIONAL  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN OPTIONAL  */
    char _ptr32 *,        /* IN  */
    __int32_t             /* IN  */
    );
#else
_tal _extensible short MOVEX (
    short ,             /* IN OPTIONAL  */
    char _far *,        /* IN  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* IN  */
    __int32_t           /* IN  */
    );
#endif

#pragma section mygmom
#if (_TANDEM_ARCH_ > 1)
_tal void MYGMOM (
    short _ptr32 *       /* OUT  */
                         /* creationid-pid of GMOM returned here */
    );
#else
_tal void MYGMOM (
    short _near *       /* OUT  */
                        /* creationid-pid of GMOM returned here */
    );
#endif

#pragma section mypid
_tal short MYPID (
    void);

#pragma section myprocesstime
_tal _extensible long long MYPROCESSTIME (
    void);

#pragma section mysystemnumber
_tal short MYSYSTEMNUMBER (
    void);

#pragma section myterm
#if (_TANDEM_ARCH_ > 1)
_tal void MYTERM (
    short _ptr32 *       /* OUT  */
                         /* TERMINAL NAME RETURNED HERE. */
    );
#else
_tal void MYTERM (
    short _near *       /* OUT  */
                        /* TERMINAL NAME RETURNED HERE. */
    );
#endif

#pragma section newprocess
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void NEWPROCESS (
    short _ptr32 *,     /* IN  */
                        /* FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* PRIORITY IN PRIF, DEBUG FLAG IN <0> */
    short ,             /* IN OPTIONAL  */
                        /* # OF DATA PAGES */
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR # */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* CREATIONID RETURNED HERE, 0 IF HARD ERROR. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* ERROR NUMBER RETURNED HERE. THE ERROR IS IN */
                        /* <0:7>, AND THE FILE SYSTEM ERROR # IS */
                        /* RETURNED IN <8:15> AS REQUIRED. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PROCESS PAIR NAME */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* HOME TERMINAL NAME */
    short ,             /* IN OPTIONAL  */
                        /* <15> = 1, WANTS INSPECT */
                        /* <14> = 1, SAVE ABEND FILE */
    short ,             /* IN OPTIONAL  */
                        /* A JOB NUMBER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* This is a replacement for the ERROR */
                        /* parameter. ERRINFO[0] will contain the */
                        /* newprocess error number and ERRINFO[1] */
                        /* will contain the file system or NEWPROCESS */
                        /* sub-error number as needed. */
    __int32_t           /* IN OPTIONAL  */
    );
#else
_tal _extensible void NEWPROCESS (
    short _near *,      /* IN  */
                        /* FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* PRIORITY IN PRIF, DEBUG FLAG IN <0> */
    short ,             /* IN OPTIONAL  */
                        /* # OF DATA PAGES */
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR # */
    short _near *,      /* OUT OPTIONAL  */
                        /* CREATIONID RETURNED HERE, 0 IF HARD ERROR. */
    short _near *,      /* OUT OPTIONAL  */
                        /* ERROR NUMBER RETURNED HERE. THE ERROR IS IN */
                        /* <0:7>, AND THE FILE SYSTEM ERROR # IS */
                        /* RETURNED IN <8:15> AS REQUIRED. */
    short _near *,      /* IN OPTIONAL  */
                        /* PROCESS PAIR NAME */
    short _near *,      /* IN OPTIONAL  */
                        /* HOME TERMINAL NAME */
    short ,             /* IN OPTIONAL  */
                        /* <15> = 1, WANTS INSPECT */
                        /* <14> = 1, SAVE ABEND FILE */
    short ,             /* IN OPTIONAL  */
                        /* A JOB NUMBER */
    short _far *,       /* OUT OPTIONAL  */
                        /* This is a replacement for the ERROR */
                        /* parameter. ERRINFO[0] will contain the */
                        /* newprocess error number and ERRINFO[1] */
                        /* will contain the file system or NEWPROCESS */
                        /* sub-error number as needed. */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section newprocessnowait
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void NEWPROCESSNOWAIT (
    short _ptr32 *,     /* IN  */
                        /* FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* PRIORITY IN PRIF, DEBUG FLAG IN <0> */
    short ,             /* IN OPTIONAL  */
                        /* # OF DATA PAGES */
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR # */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* CREATIONID RETURNED HERE, 0 IF HARD ERROR. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* ERROR NUMBER RETURNED HERE. THE ERROR IS IN */
                        /* <0:7>, AND THE FILE SYSTEM ERROR # IS */
                        /* RETURNED IN <8:15> AS REQUIRED. */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* PROCESS PAIR NAME */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* HOME TERMINAL NAME */
    short ,             /* IN OPTIONAL  */
                        /* <15> = 1, WANTS INSPECT */
                        /* <14> = 1, SAVE ABEND FILE */
    short ,             /* IN OPTIONAL  */
                        /* A JOB NUMBER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* This is a replacement for the ERROR */
                        /* parameter. ERRINFO[0] will contain the */
                        /* newprocess error number and ERRINFO[1] */
                        /* will contain the file system or NEWPROCESS */
                        /* sub-error number as needed. */
    __int32_t           /* IN OPTIONAL  */
    );
#else
_tal _extensible void NEWPROCESSNOWAIT (
    short _near *,      /* IN  */
                        /* FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* PRIORITY IN PRIF, DEBUG FLAG IN <0> */
    short ,             /* IN OPTIONAL  */
                        /* # OF DATA PAGES */
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR # */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* CREATIONID RETURNED HERE, 0 IF HARD ERROR. */
    short _near *,      /* OUT OPTIONAL  */
                        /* ERROR NUMBER RETURNED HERE. THE ERROR IS IN */
                        /* <0:7>, AND THE FILE SYSTEM ERROR # IS */
                        /* RETURNED IN <8:15> AS REQUIRED. */
    short _near *,      /* IN OPTIONAL  */
                        /* PROCESS PAIR NAME */
    short _near *,      /* IN OPTIONAL  */
                        /* HOME TERMINAL NAME */
    short ,             /* IN OPTIONAL  */
                        /* <15> = 1, WANTS INSPECT */
                        /* <14> = 1, SAVE ABEND FILE */
    short ,             /* IN OPTIONAL  */
                        /* A JOB NUMBER */
    short _far *,       /* OUT OPTIONAL  */
                        /* This is a replacement for the ERROR */
                        /* parameter. ERRINFO[0] will contain the */
                        /* newprocess error number and ERRINFO[1] */
                        /* will contain the file system or NEWPROCESS */
                        /* sub-error number as needed. */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section nextfilename
#if (_TANDEM_ARCH_ > 1)
_tal short NEXTFILENAME (
    short _ptr32 *       /* IN/OUT  */
                         /* FILE NAME */
    );
#else
_tal short NEXTFILENAME (
    short _near *       /* IN/OUT  */
                        /* FILE NAME */
    );
#endif


#pragma section nodename_to_nodenumber_
#include <tnsint.h>
_tal _extensible short NODENAME_TO_NODENUMBER_ (
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t _far *,   /* OUT  */
    __int32_t _far *    /* OUT  */
    );

#pragma section nodenumber_to_nodename_
#include <tnsint.h>
_tal _extensible short NODENUMBER_TO_NODENAME_ (
    __int32_t ,         /* IN OPTIONAL  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    __int32_t _far *    /* OUT  */
    );

#pragma section node_getcoldloadinfo_
_tal _extensible short NODE_GETCOLDLOADINFO_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    const char _far *,  /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section no_error
#if (_TANDEM_ARCH_ > 1)
_tal _alias ("NO^ERROR") short NO_ERROR (
    short ,              /* IN  */
                         /* WHETHER OPERATION WAS SUCCESSFUL */
    short _ptr32 *,      /* IN  */
                         /* FCB OF FILE OPERATION WAS DONE ON */
    short _ptr32 *,      /* IN  */
                         /* LIST OF ERRORS THAT ARE ACCEPTABLE */
    short                /* IN  */
                         /* WHETHER OPERATION CAN BE RETRIED */
    );
#else
_tal _alias ("NO^ERROR") short NO_ERROR (
    short ,             /* IN  */
                        /* WHETHER OPERATION WAS SUCCESSFUL */
    short _near *,      /* IN  */
                        /* FCB OF FILE OPERATION WAS DONE ON */
    short _near *,      /* IN  */
                        /* LIST OF ERRORS THAT ARE ACCEPTABLE */
    short               /* IN  */
                        /* WHETHER OPERATION CAN BE RETRIED */
    );
#endif

#pragma section numberedit
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1 )
_tal _extensible short NUMBEREDIT (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t ,         /* IN  */
                        /*   first line to be renumbered  */
    __int32_t ,         /* IN  */
                        /*   last  line to be renumbered  */
    __int32_t ,         /* IN  */
                        /*   new line number of first line  */
    __int32_t ,         /* IN  */
                        /*   new line number increment  */
    short (_ptr32 *)(
    )                   /* IN OPTIONAL  */
                        /*  proc for UNDO capability  */
    );
#else
_tal _extensible short NUMBEREDIT (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t ,         /* IN  */
                        /*   first line to be renumbered  */
    __int32_t ,         /* IN  */
                        /*   last  line to be renumbered  */
    __int32_t ,         /* IN  */
                        /*   new line number of first line  */
    __int32_t ,         /* IN  */
                        /*   new line number increment  */
    short (*)(
    )                   /* IN OPTIONAL  */
                        /*  proc for UNDO capability  */
    );
#endif

#pragma section numin
#include <tnsint.h>
#if _TANDEM_ARCH_ > 0   /* any native version */
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t NUMIN (
    char _ptr32 *,       /* IN  */
                         /* STRING WHERE NUMBER STARTS */
    short _ptr32 *,      /* OUT  */
                         /* NUMERIC VALUE RETURNED HERE */
    short ,              /* IN  */
                         /* DEFAULT CONVERSION BASE, A % FORCES 8 */
    short _ptr32 *       /* OUT  */
                         /* 1: STR DOES NOT LOOK LIKE A NUMBER */
                         /* 0: LEGAL NUMBER */
                         /* -1: ILLEGAL NUMBER */
    );
#else
_tal __int32_t NUMIN (
    char _near *,       /* IN  */
                        /* STRING WHERE NUMBER STARTS */
    short _near *,      /* OUT  */
                        /* NUMERIC VALUE RETURNED HERE */
    short ,             /* IN  */
                        /* DEFAULT CONVERSION BASE, A % FORCES 8 */
    short _near *       /* OUT  */
                        /* 1: STR DOES NOT LOOK LIKE A NUMBER */
                        /* 0: LEGAL NUMBER */
                        /* -1: ILLEGAL NUMBER */
    );
 #endif
#else /*   not native  */
_tal char _near * NUMIN (
    char _near *,       /* IN  */
                        /* STRING WHERE NUMBER STARTS */
    short _near *,      /* OUT  */
                        /* NUMERIC VALUE RETURNED HERE */
    short ,             /* IN  */
                        /* DEFAULT CONVERSION BASE, A % FORCES 8 */
    short _near *       /* OUT  */
                        /* 1: STR DOES NOT LOOK LIKE A NUMBER */
                        /* 0: LEGAL NUMBER */
                        /* -1: ILLEGAL NUMBER */
    );
#endif

#pragma section numout
#if (_TANDEM_ARCH_ > 1)
_tal void NUMOUT (
    char _ptr32 *,      /* OUT  */
                        /* BYTE STRING FOR ASCII NUMBER */
    short ,             /* IN  */
                        /* LOGICAL 16 BIT NUMERIC VALUE */
    short ,             /* IN  */
                        /* CONVERSION BASE, 2-10 ALLOWED */
    short               /* IN  */
                        /* CONVERTED NUMBER WILL OCCUPY STR TO */
                        /* STR [ WIDTH - 1 ] */
    );
#else
_tal void NUMOUT (
    char _near *,       /* OUT  */
                        /* BYTE STRING FOR ASCII NUMBER */
    short ,             /* IN  */
                        /* LOGICAL 16 BIT NUMERIC VALUE */
    short ,             /* IN  */
                        /* CONVERSION BASE, 2-10 ALLOWED */
    short               /* IN  */
                        /* CONVERTED NUMBER WILL OCCUPY STR TO */
                        /* STR [ WIDTH - 1 ] */
    );
#endif

#pragma section objfile_getinfolist_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short OBJFILE_GETINFOLIST_ (
    short _ptr32 *,       /* IN  */
                          /*  array indicating which attributes should */
                          /*  have their values returned in V_LST */
    short ,               /* IN  */
                          /*  ATTR_COUNT is the number of items in */
                          /*  the list. */
    short _ptr32 *,       /* OUT  */
                          /*  array to contain returned data. */
    short ,               /* IN  */
                          /*  buffer size, in bytes, of V_LEN */
    short _ptr32 *,       /* OUT  */
                          /*  actual length, in bytes, filled in. */
    short ,               /* IN OPTIONAL  */
                          /*  Flag:  To return information on the code */
                          /*         or the user library object file. */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /*  may contain info to augment error. */
    const char _ptr32 *,  /* IN OPTIONAL  */
                          /*  name of the srl file to be matched */
    short                 /* IN OPTIONAL  */
                          /*  length of the srl file name supplied */
    );
#else
_tal _extensible short OBJFILE_GETINFOLIST_ (
    short _far *,       /* IN  */
                        /*  array indicating which attributes should */
                        /*  have their values returned in V_LST */
    short ,             /* IN  */
                        /*  ATTR_COUNT is the number of items in */
                        /*  the list. */
    short _far *,       /* OUT  */
                        /*  array to contain returned data. */
    short ,             /* IN  */
                        /*  buffer size, in bytes, of V_LEN */
    short _far *,       /* OUT  */
                        /*  actual length, in bytes, filled in. */
    short ,             /* IN OPTIONAL  */
                        /*  Flag:  To return information on the code */
                        /*         or the user library object file. */
    short _far *,       /* OUT OPTIONAL  */
                        /*  may contain info to augment error. */
    const char _far *,  /* IN OPTIONAL  */
                        /*  name of the srl file to be matched */
    short               /* IN OPTIONAL  */
                        /*  length of the srl file name supplied */
    );
#endif

#pragma section oldfilename_to_filename_
_tal _extensible short OLDFILENAME_TO_FILENAME_ (
    short _far *,       /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );

#pragma section oldsysmsg_to_newsysmsg_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short OLDSYSMSG_TO_NEWSYSMSG_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short OLDSYSMSG_TO_NEWSYSMSG_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section open
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status OPEN (
    short _near *,      /* IN  */
                        /* FILE NAME */
    short _near *,      /* OUT  */
                        /* RETURNED FILE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* .<12:15> MAX # OF OUTSTANDING NO-WAIT */
                        /* REQUESTS */
                        /* .<9:11>  OPEN TYPE: */
                        /* 0 = NORMAL */
                        /* 1 = EXCLUSIVE */
                        /* 3 = PROTECTED */
                        /* .<8>     OPENED NOWAIT */
                        /* .<7>     RESERVE LCB'S */
                        /* .<6>     RESIDENT BUFFERS */
                        /* .<3:5>   ACCESS MODE: */
                        /* 0 = READ/WRITE */
                        /* 1 = READ ONLY */
                        /* 2 = WRITE ONLY */
                        /* 3 = EXECUTE */
                        /* .<2>     TREAT AS UNSTRUCTURED FILE */
    short ,             /* IN OPTIONAL  */
                        /* # OF REQUESTS TO SAVE ( 0 = NON-FAILSAFE ) */
    short ,             /* IN OPTIONAL  */
                        /* FOR BACKUP OPEN, THE PRIMARY'S FILE NUMBER */
    short _near *,      /* IN OPTIONAL  */
                        /* FOR BACKUP OPEN, THE PRIMARY'S CRTPID */
    short _near *,      /* IN OPTIONAL  */
                        /* SEQUENTIAL BUFFER */
    short ,             /* IN OPTIONAL  */
                        /* SEQUENTIAL BUFFER LENGTH */
    short _near *       /* IN OPTIONAL  */
                        /* FOR BACKUP OPEN, NAME OF DEFINE USED IN PRIM. */
    );

#pragma section openedit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short OPENEDIT (
    short _ptr32 *,       /* IN  */
                          /*   [0: 11]  internal file name  */
    short _ptr32 *,       /* IN/OUT  */
                          /*   open file number  */
    short ,               /* IN OPTIONAL  */
                          /*   flags as in file system OPEN proc  */
    short ,               /* IN OPTIONAL  */
                          /*   checkpoint synchronization depth  */
    short ,               /* IN OPTIONAL  */
                          /*   unbuffered writing flag  */
    const char _ptr32 *   /* IN OPTIONAL  */
                          /*   VC tag ":pathname.version-num" */
                          /*   (internal only) */
    );
#else
_tal _extensible short OPENEDIT (
    short _far *,       /* IN  */
                        /*   [0: 11]  internal file name  */
    short _far *,       /* IN/OUT  */
                        /*   open file number  */
    short ,             /* IN OPTIONAL  */
                        /*   flags as in file system OPEN proc  */
    short ,             /* IN OPTIONAL  */
                        /*   checkpoint synchronization depth  */
    short ,             /* IN OPTIONAL  */
                        /*   unbuffered writing flag  */
    const char _far *   /* IN OPTIONAL  */
                        /*   VC tag ":pathname.version-num" (internal only) */
    );
#endif

#pragma section openedit_
_tal _extensible short OPENEDIT_ (
    const char _far *,  /* IN  */
                        /*   [0: Length-1]  EXTERNAL file name  */
    short ,             /* IN  */
                        /*   length of FileName  */
    short _far *,       /* IN/OUT  */
                        /*   open file number  */
    short ,             /* IN OPTIONAL  */
                        /*   read/write/readwrite access  */
    short ,             /* IN OPTIONAL  */
                        /*   shared/exclusive/protected mode  */
    short ,             /* IN OPTIONAL  */
                        /*   wait/nowait option  */
    short ,             /* IN OPTIONAL  */
                        /*   checkpoint synchronization depth  */
    short ,             /* IN OPTIONAL  */
                        /*   unbuffered writing flag  */
    const char _far *   /* IN OPTIONAL  */
                        /*   VC tag ":pathname.version-num" (internal only) */
    );

#pragma section opener_lost_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short OPENER_LOST_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN  */
    short                 /* IN  */
    );
#else
_tal _extensible short OPENER_LOST_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN  */
    short               /* IN  */
    );
#endif

#pragma section openinfo
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short OPENINFO (
    short _ptr32 *,      /* IN  */
    short _ptr32 *,      /* IN/OUT  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short _ptr32 *       /* OUT OPTIONAL  */
    );
#else
_tal _extensible short OPENINFO (
    short _near *,      /* IN  */
    short _near *,      /* IN/OUT  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section open_file
#include <tnsint.h>
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("OPEN^FILE") _extensible short OPEN_FILE (
    short _ptr32 *,      /* IN  */
                         /* THE COMMON FCB */
    short _ptr32 *,      /* IN  */
                         /* FCB OF FILE TO OPEN */
    short _ptr32 *,      /* IN OPTIONAL  */
                         /* BLOCK BUFFER FOR THE FILE */
    short ,              /* IN OPTIONAL  */
                         /* LENGTH IN BYTES OF BLOCKBUF */
    __int32_t ,          /* IN OPTIONAL  */
                         /* SPECIFY MISC FILE CHARACTERISTICS */
    __int32_t ,          /* IN OPTIONAL  */
                         /* WHICH FLAGS TO USE */
    short ,              /* IN OPTIONAL  */
                         /* MAX LENGTH FOR RECORDS IN THIS FILE */
    short ,              /* IN OPTIONAL  */
                         /* PROMPT CHAR FOR READING FROM A TERMINAL */
    short _ptr32 *       /* IN OPTIONAL  */
                         /* FCB OF A FILE TO WRITE ERROR MESSAGES TO */
    );
#elif (_TANDEM_ARCH_ == 1)
_tal _alias ("OPEN^FILE") _extensible short OPEN_FILE (
    short _near *,      /* IN  */
                        /* THE COMMON FCB */
    short _near *,      /* IN  */
                        /* FCB OF FILE TO OPEN */
    short _near *,      /* IN OPTIONAL  */
                        /* BLOCK BUFFER FOR THE FILE */
    short ,             /* IN OPTIONAL */
                        /*LENGTH IN BYTES OF BLOCKBUF */
    __int32_t ,         /* IN OPTIONAL  */
                        /* SPECIFY MISC FILE CHARACTERISTICS */
    __int32_t ,         /* IN OPTIONAL  */
                        /* WHICH FLAGS TO USE */
    short ,             /* IN OPTIONAL  */
                        /* MAX LENGTH FOR RECORDS IN THIS FILE */
    short ,             /* IN OPTIONAL  */
                        /* PROMPT CHAR FOR READING FROM A TERMINAL */
    short _near *       /* IN OPTIONAL  */
                        /* FCB OF A FILE TO WRITE ERROR MESSAGES TO */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("OPEN^FILE") _variable short OPEN_FILE (
    short _near *,      /* IN  */
                        /* THE COMMON FCB */
    short _near *,      /* IN  */
                        /* FCB OF FILE TO OPEN */
    short _near *,      /* IN OPTIONAL  */
                        /* BLOCK BUFFER FOR THE FILE */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH IN BYTES OF BLOCKBUF */
    __int32_t ,         /* IN OPTIONAL  */
                        /* SPECIFY MISC FILE CHARACTERISTICS */
    __int32_t ,         /* IN OPTIONAL  */
                        /* WHICH FLAGS TO USE */
    short ,             /* IN OPTIONAL  */
                        /* MAX LENGTH FOR RECORDS IN THIS FILE */
    short ,             /* IN OPTIONAL  */
                        /* PROMPT CHAR FOR READING FROM A TERMINAL */
    short _near *       /* IN OPTIONAL  */
                        /* FCB OF A FILE TO WRITE ERROR MESSAGES TO */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section oss_pid_null_
#include <tnsint.h>
_tal _extensible __int32_t OSS_PID_NULL_ (
    void);

#pragma section packedit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void PACKEDIT (
    char _ptr32 *,      /* IN  */
                        /*   unpacked line image  */
    short ,             /* IN  */
                        /*   byte length of FromLine  */
    char _ptr32 *,      /* OUT  */
                        /*   packed line image  */
    short ,             /* IN  */
                        /*   max byte length of ToLine  */
    short _ptr32 *,     /* OUT  */
                        /*   byte length of ToLine  */
    short               /* IN OPTIONAL  */
                        /*   retain trailing spaces option  */
    );
#else
_tal _extensible void PACKEDIT (
    char _far *,        /* IN  */
                        /*   unpacked line image  */
    short ,             /* IN  */
                        /*   byte length of FromLine  */
    char _far *,        /* OUT  */
                        /*   packed line image  */
    short ,             /* IN  */
                        /*   max byte length of ToLine  */
    short _far *,       /* OUT  */
                        /*   byte length of ToLine  */
    short               /* IN OPTIONAL  */
                        /*   retain trailing spaces option  */
    );
#endif

#pragma section pathname_to_filename_
_tal _extensible short PATHNAME_TO_FILENAME_ (
    const char _far *,  /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section pool_check_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_CHECK_ (
    short _ptr32 *,         /* IN  */
                            /* points to pool header */
    __int32_t _ptr32  *,    /* OUT OPTIONAL  */
                            /* address of corrupted word(s) */
    __int32_t _ptr32  *,    /* OUT OPTIONAL  */
                            /* address of nearest valid block */
                            /* preceding corruption */
    __int32_t _ptr32  *,    /* OUT OPTIONAL  */
                            /* size of block at <block-addr> */
    short _ptr32 *          /* OUT OPTIONAL  */
                            /* size of a tag in bytes */
    );
#else
_tal _extensible short POOL_CHECK_ (
    short _far *,         /* IN  */
                          /* points to pool header */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* address of corrupted word(s) */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* address of nearest valid block */
                          /* preceding corruption */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* size of block at <block-addr> */
    short _far *          /* OUT OPTIONAL  */
                          /* size of a tag in bytes */
    );
#endif

#pragma section pool_define_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_DEFINE_ (
    short _ptr32 *,     /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* max byte size of pool */
    short ,             /* IN OPTIONAL  */
                        /* either 4, 8, or 16-byte */
    short               /* IN OPTIONAL  */
                        /* if nonzero, then lock down header */
                        /* (for priv-callers only) */
    );
#else
_tal _extensible short POOL_DEFINE_ (
    short _far *,       /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* max byte size of pool */
    short ,             /* IN OPTIONAL  */
                        /* either 4, 8, or 16-byte */
    short               /* IN OPTIONAL  */
                        /* if nonzero, then lock down header */
                        /* (for priv-callers only) */
    );
#endif

#pragma section pool_getinfo_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_GETINFO_ (
    short _ptr32 *,        /* IN  */
                           /* points to pool header */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* position of parameter in error */
    __int32_t _ptr32  *,   /* OUT OPTIONAL  */
                           /* byte size of allocatable pool */
    __int32_t _ptr32  *,   /* OUT OPTIONAL  */
                           /* bytes currently allocated */
    __int32_t _ptr32  *,   /* OUT OPTIONAL  */
                           /* maximum bytes ever allocated */
    __int32_t _ptr32  *,   /* OUT OPTIONAL  */
                           /* byte size of last failed request */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* current number of free blocks */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* maximum number of free blocks */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* alignment of pool blocks */
    short _ptr32 *         /* OUT OPTIONAL  */
                           /* size of a tag in bytes */
    );
#else
_tal _extensible short POOL_GETINFO_ (
    short _far *,         /* IN  */
                          /* points to pool header */
    short _far *,         /* OUT OPTIONAL  */
                          /* position of parameter in error */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* byte size of allocatable pool */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* bytes currently allocated */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* maximum bytes ever allocated */
    __int32_t _far  *,    /* OUT OPTIONAL  */
                          /* byte size of last failed request */
    short _far *,         /* OUT OPTIONAL  */
                          /* current number of free blocks */
    short _far *,         /* OUT OPTIONAL  */
                          /* maximum number of free blocks */
    short _far *,         /* OUT OPTIONAL  */
                          /* alignment of pool blocks */
    short _far *          /* OUT OPTIONAL  */
                          /* size of a tag in bytes */
    );
#endif

#pragma section pool_getlockedspace_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible __int32_t POOL_GETLOCKEDSPACE_ (
    short _ptr32 *,     /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* error return code */
    );
#else
_tal _extensible __int32_t POOL_GETLOCKEDSPACE_ (
    short _far *,       /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _far *        /* OUT OPTIONAL  */
                        /* error return code */
    );
#endif

#pragma section pool_getspace_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible __int32_t POOL_GETSPACE_ (
    short _ptr32 *,     /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* error code */
    );
#else
_tal _extensible __int32_t POOL_GETSPACE_ (
    short _far *,       /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _far *        /* OUT OPTIONAL  */
                        /* error code */
    );
#endif

#pragma section pool_getspace_page_
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
#if (_TANDEM_ARCH_ != 0)
_tal _extensible __int32_t POOL_GETSPACE_PAGE_ (
    short _ptr32 *,     /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* error code */
    );
#else
_tal _extensible __int32_t POOL_GETSPACE_PAGE_ (
    short _far *,       /* IN  */
                        /* points to pool header */
    __int32_t ,         /* IN  */
                        /* byte size of block requested */
    short _far *        /* OUT OPTIONAL  */
                        /* error code */
    );
#endif
#endif

#pragma section pool_putlockedspace_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_PUTLOCKEDSPACE_ (
    short _ptr32  *,      /* IN  */
                          /* points to pool header */
    short _ptr32  *       /* IN  */
                          /* points to block to return */
    );
#else
_tal _extensible short POOL_PUTLOCKEDSPACE_ (
    short _far  *,      /* IN  */
                        /* points to pool header */
    short _far  *       /* IN  */
                        /* points to block to return */
    );
#endif

#pragma section pool_putspace_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_PUTSPACE_ (
    short _ptr32  *,      /* IN  */
                          /* points to pool header */
    short _ptr32  *       /* IN  */
                          /* points to block to return */
    );
#else
_tal _extensible short POOL_PUTSPACE_ (
    short _far  *,      /* IN  */
                        /* points to pool header */
    short _far  *       /* IN  */
                        /* points to block to return */
    );
#endif

#pragma section pool_resize_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short POOL_RESIZE_ (
    short _ptr32  *,    /* IN  */
                        /* points to pool header */
    __int32_t           /* IN  */
                        /* new pool size */
    );
#else
_tal _extensible short POOL_RESIZE_ (
    short _far  *,      /* IN  */
                        /* points to pool header */
    __int32_t           /* IN  */
                        /* new pool size */
    );
#endif

#pragma section position
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status POSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN  */
                        /* NEW VALUE OF LOGICAL DATA PTR */
                        /* (-1D TO SET TO EOF) */
    );

#pragma section positionedit
#include <tnsint.h>
_tal _extensible short POSITIONEDIT (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t           /* IN  */
                        /*   EDIT line number times 1000  */
    );

#pragma section printcomplete
#if (_TANDEM_ARCH_ > 1)
_tal short PRINTCOMPLETE (
    short ,              /* IN  */
                         /* FILE TO SPOOL SUPERVISOR */
    short _ptr32 *       /* OUT  */
                         /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal short PRINTCOMPLETE (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short _near *       /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section printcomplete2
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PRINTCOMPLETE2 (
    short ,              /* IN  */
                         /* FILE TO SPOOL SUPERVISOR */
    short _ptr32 *       /* OUT  */
                         /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal _extensible short PRINTCOMPLETE2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short _near *       /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section printinfo
#if (_TANDEM_ARCH_ > 1)
_tal _variable short PRINTINFO (
    short _ptr32 *,      /* IN  */
                         /* BLOCKING BUFFER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* NUMBER OF COPIES LEFT */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* PAGE NUMBER */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* LINE NUMBER */
    short _ptr32 *       /* OUT OPTIONAL  */
                         /* TOTAL LINES */
    );
#else
_tal _variable short PRINTINFO (
    short _near *,      /* IN  */
                        /* BLOCKING BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF COPIES LEFT */
    short _near *,      /* OUT OPTIONAL  */
                        /* PAGE NUMBER */
    short _near *,      /* OUT OPTIONAL  */
                        /* LINE NUMBER */
    short _near *       /* OUT OPTIONAL  */
                        /* TOTAL LINES */
    );
#endif

#pragma section printinit
#if (_TANDEM_ARCH_ > 1)
_tal short PRINTINIT (
    short ,              /* IN  */
                         /* FILE TO SPOOL SUPERVISOR */
    short _ptr32 *       /* IN/OUT  */
                         /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal short PRINTINIT (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short _near *       /* IN/OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section printinit2
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PRINTINIT2 (
    short ,              /* IN  */
                         /* FILE TO SPOOL SUPERVISOR */
    short _ptr32 *       /* IN/OUT  */
                         /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal _extensible short PRINTINIT2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short _near *       /* IN/OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section printread
#if (_TANDEM_ARCH_ > 1)
_tal _variable short PRINTREAD (
    short _ptr32 *,      /* IN/OUT  */
                         /* BLOCKING BUFFER */
    short _ptr32 *,      /* OUT  */
                         /* DATA LINE TO BE READ IN */
    short ,              /* IN  */
                         /* NUMBER OF BYTES TO READ */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* NUMBER OF BYTES ACTUALLY READ */
    short                /* IN OPTIONAL  */
                         /* SKIP PARAMETER */
    );
#else
_tal _variable short PRINTREAD (
    short _near *,      /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short _near *,      /* OUT  */
                        /* DATA LINE TO BE READ IN */
    short ,             /* IN  */
                        /* NUMBER OF BYTES TO READ */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES ACTUALLY READ */
    short               /* IN OPTIONAL  */
                        /* SKIP PARAMETER */
    );
#endif

#pragma section printreadcommand
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PRINTREADCOMMAND (
    short _ptr32 *,     /* IN  */
                        /* MESSAGE FROM SUPERVISOR PROCESS */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRINT PROCESS CONTROL NUMBER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DEVICE TO BE CONTROLLED */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DEVICE FLAGS */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DEVICE PARM */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* DEVICE WIDTH */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* SKIP PARAMETER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NAME OF DATA FILE FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* JOB NUMBER FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* LOCATION NAME FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* FORM NAME FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* REPORT NAME FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PAGE SIZE FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* BATCH NAME FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* BATCH ID FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* OWNER FOR SPOOLED JOB */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* CHARMAP (MBCS) VALUE */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* ADDITIONAL DEVICE FLAG WORD */
    );
#else
_tal _extensible short PRINTREADCOMMAND (
    short _near *,      /* IN  */
                        /* MESSAGE FROM SUPERVISOR PROCESS */
    short _near *,      /* OUT OPTIONAL  */
                        /* PRINT PROCESS CONTROL NUMBER */
    short _near *,      /* OUT OPTIONAL  */
                        /* DEVICE TO BE CONTROLLED */
    short _near *,      /* OUT OPTIONAL  */
                        /* DEVICE FLAGS */
    short _near *,      /* OUT OPTIONAL  */
                        /* DEVICE PARM */
    short _near *,      /* OUT OPTIONAL  */
                        /* DEVICE WIDTH */
    short _near *,      /* OUT OPTIONAL  */
                        /* SKIP PARAMETER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NAME OF DATA FILE FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* JOB NUMBER FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* LOCATION NAME FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* FORM NAME FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* REPORT NAME FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* PAGE SIZE FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* BATCH NAME FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* BATCH ID FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* OWNER FOR SPOOLED JOB */
    short _near *,      /* OUT OPTIONAL  */
                        /* CHARMAP (MBCS) VALUE */
    short _near *       /* OUT OPTIONAL  */
                        /* ADDITIONAL DEVICE FLAG WORD */
    );
#endif

#pragma section printstart
#if (_TANDEM_ARCH_ > 1)
_tal short PRINTSTART (
    short _ptr32 *,     /* OUT  */
                        /* BLOCKING BUFFER */
    short _ptr32 *,     /* IN  */
                        /* MESSAGE FROM SPOOL SUPERVISOR */
    short               /* IN  */
                        /* DATA FILE NUMBER */
    );
#else
_tal short PRINTSTART (
    short _near *,      /* OUT  */
                        /* BLOCKING BUFFER */
    short _near *,      /* IN  */
                        /* MESSAGE FROM SPOOL SUPERVISOR */
    short               /* IN  */
                        /* DATA FILE NUMBER */
    );
#endif

#pragma section printstart2
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PRINTSTART2 (
    short _ptr32 *,     /* OUT  */
                        /* BLOCKING BUFFER */
    short _ptr32 *,     /* IN  */
                        /* MESSAGE FROM SPOOL SUPERVISOR */
    short               /* IN  */
                        /* DATA FILE NUMBER */
    );
#else
_tal _extensible short PRINTSTART2 (
    short _near *,      /* OUT  */
                        /* BLOCKING BUFFER */
    short _near *,      /* IN  */
                        /* MESSAGE FROM SPOOL SUPERVISOR */
    short               /* IN  */
                        /* DATA FILE NUMBER */
    );
#endif

#pragma section printstatus
#if (_TANDEM_ARCH_ > 1)
_tal _variable short PRINTSTATUS (
    short ,             /* IN  */
                        /* FILE TO THE SPOOL SUPERVISOR */
    short _ptr32 *,     /* IN  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* TYPE OF STATUS */
    short _ptr32 *,     /* IN  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* ERROR */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COPIES LEFT */
    short ,             /* IN OPTIONAL  */
                        /* PAGE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* LINE NUMBER */
    short               /* IN OPTIONAL  */
                        /* TOTAL LINES */
    );
#else
_tal _variable short PRINTSTATUS (
    short ,             /* IN  */
                        /* FILE TO THE SPOOL SUPERVISOR */
    short _near *,      /* IN  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* TYPE OF STATUS */
    short _near *,      /* IN  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* ERROR */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COPIES LEFT */
    short ,             /* IN OPTIONAL  */
                        /* PAGE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* LINE NUMBER */
    short               /* IN OPTIONAL  */
                        /* TOTAL LINES */
    );
#endif

#pragma section printstatus2
#if (_TANDEM_ARCH_ > 1)
_tal _variable short PRINTSTATUS2 (
    short ,             /* IN  */
                        /* FILE TO THE SPOOL SUPERVISOR */
    short _ptr32 *,     /* IN  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* TYPE OF STATUS */
    short _ptr32 *,     /* IN  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* ERROR */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COPIES LEFT */
    short ,             /* IN OPTIONAL  */
                        /* PAGE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* LINE NUMBER */
    short               /* IN OPTIONAL  */
                        /* TOTAL LINES */
    );
#else
_tal _variable short PRINTSTATUS2 (
    short ,             /* IN  */
                        /* FILE TO THE SPOOL SUPERVISOR */
    short _near *,      /* IN  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* TYPE OF STATUS */
    short _near *,      /* IN  */
                        /* DEVICE NAME */
    short ,             /* IN OPTIONAL  */
                        /* ERROR */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COPIES LEFT */
    short ,             /* IN OPTIONAL  */
                        /* PAGE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* LINE NUMBER */
    short               /* IN OPTIONAL  */
                        /* TOTAL LINES */
    );
#endif

#pragma section priority
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PRIORITY (
    short ,             /* IN OPTIONAL  */
                        /* NEW PRIORITY */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* INITIAL PRIORITY */
    );
#else
_tal _extensible short PRIORITY (
    short ,             /* IN OPTIONAL  */
                        /* NEW PRIORITY */
    short _near *       /* OUT OPTIONAL  */
                        /* INITIAL PRIORITY */
    );
#endif

#pragma section processaccessid
_tal short PROCESSACCESSID (
    void);

#pragma section processfilesecurity
_tal _extensible short PROCESSFILESECURITY (
    short               /* IN  */
                        /* THE NEW FILE SECURITY */
    );

#pragma section processhandle_compare_
_tal _extensible short PROCESSHANDLE_COMPARE_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short _far *        /* IN  */
                        /* [0:9] */
    );

#pragma section processhandle_decompose_
#include <tnsint.h>
_tal _extensible short PROCESSHANDLE_DECOMPOSE_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t _far *,   /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    long long _far *    /* OUT OPTIONAL  */
    );

#pragma section processhandle_getmine_
_tal short PROCESSHANDLE_GETMINE_ (
    short _far *        /* OUT  */
    );

#pragma section processhandle_nullit_
_tal _extensible short PROCESSHANDLE_NULLIT_ (
    short _far *        /* OUT  */
                        /*  PROCESSHANDLE */
    );

#pragma section processhandle_to_crtpid_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PROCESSHANDLE_TO_CRTPID_ (
    short _ptr32 *,       /* IN  */
                          /* [0:9] */
    short _ptr32 *,       /* OUT  */
    short ,               /* IN OPTIONAL  */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short PROCESSHANDLE_TO_CRTPID_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section processhandle_to_filename_
_tal _extensible short PROCESSHANDLE_TO_FILENAME_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short               /* IN OPTIONAL  */
    );

#pragma section processhandle_to_string_
_tal _extensible short PROCESSHANDLE_TO_STRING_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section processinfo
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PROCESSINFO (
    short ,             /* IN  */
                        /* CPU/PIN */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* FULL 4-WORD PID */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* CREATOR ACCESSOR ID */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* PROCESS ACCESSOR ID */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* MAXIMUM PRIORITY OF INTEREST */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* PROGRAM FILE NAME */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* HOME TERMINAL FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* .<0> MUST MATCH <PID> FOR 3 WORDS */
                        /* .<1> MUST MATCH <CREATORID> */
                        /* .<2> MUST MATCH <PROCESSID> */
                        /* .<3> MUST BE <= PRIORITY */
                        /* .<4> MUST BE RUNNING FROM <PROGRAM> */
                        /* .<5> MUST HAVE <HOMETERM> HOME TERM */
                        /* .<6> MUST MATCH GMOMCRTPIDJOBID */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PRIV ONLY */
    long long _ptr32 *, /* OUT OPTIONAL  */
                        /* PROCESS TIMING */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* WAIT FLAGS */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* PROCESS STATE */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* LIBRARY FILE NAME */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* SWAP FILE NAME */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NUMBER OF CHANGES TO CONTEXT */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* MISCELLANEOUS INFORMATION */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* OBJECT FILE LICENSES */
    short _ptr32 *      /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short PROCESSINFO (
    short ,             /* IN  */
                        /* CPU/PIN */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* FULL 4-WORD PID */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* CREATOR ACCESSOR ID */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* PROCESS ACCESSOR ID */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* MAXIMUM PRIORITY OF INTEREST */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* PROGRAM FILE NAME */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* HOME TERMINAL FILE NAME */
    short ,             /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* .<0> MUST MATCH <PID> FOR 3 WORDS */
                        /* .<1> MUST MATCH <CREATORID> */
                        /* .<2> MUST MATCH <PROCESSID> */
                        /* .<3> MUST BE <= PRIORITY */
                        /* .<4> MUST BE RUNNING FROM <PROGRAM> */
                        /* .<5> MUST HAVE <HOMETERM> HOME TERM */
                        /* .<6> MUST MATCH GMOMCRTPIDJOBID */
    short _near *,      /* OUT OPTIONAL  */
                        /* PRIV ONLY */
    long long _near *,  /* OUT OPTIONAL  */
                        /* PROCESS TIMING */
    short _near *,      /* OUT OPTIONAL  */
                        /* WAIT FLAGS */
    short _near *,      /* OUT OPTIONAL  */
                        /* PROCESS STATE */
    short _near *,      /* OUT OPTIONAL  */
                        /* LIBRARY FILE NAME */
    short _near *,      /* OUT OPTIONAL  */
                        /* SWAP FILE NAME */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF CHANGES TO CONTEXT */
    short _near *,      /* OUT OPTIONAL  */
                        /* MISCELLANEOUS INFORMATION */
    short _near *,      /* OUT OPTIONAL  */
                        /* OBJECT FILE LICENSES */
    short _near *       /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section processname_create_
_tal _extensible short PROCESSNAME_CREATE_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section processorstatus
#include <tnsint.h>
_tal __int32_t PROCESSORSTATUS (
    void);

#pragma section processortype
_tal _extensible short PROCESSORTYPE (
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section processor_getinfolist_
_tal _extensible short PROCESSOR_GETINFOLIST_ (
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section processor_getname_
#include <tnsint.h>
_tal _extensible short PROCESSOR_GETNAME_ (
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR NUMBER */
    char _far *,        /* OUT  */
                        /* PROCESSOR'S TYPE, AS A STRING */
    short ,             /* IN  */
                        /* MAX NUMBER OF CHARS IN STRING */
    short _far *,       /* OUT  */
                        /* ACTUAL NUMBER OF CHARS IN STRING */
    short _far *,       /* OUT OPTIONAL  */
                        /* PROCESSOR'S TYPE, AS AN INT */
    const char _far *,  /* IN OPTIONAL  */
                        /* NAME OF TARGET NODE */
    short ,             /* IN OPTIONAL  */
                        /* NODE NAME LENGTH */
    __int32_t ,         /* IN OPTIONAL  */
                        /* NODE NUMBER */
    short ,             /* IN OPTIONAL  */
                        /* PROCESSOR'S TYPE */
    short ,             /* IN OPTIONAL  */
                        /* REFORMAT NAME TO MAKE LEGAL HAPPY */
    short _far *,       /* OUT OPTIONAL  */
                        /* THE MODEL NUMBER WITHIN THE TYPE */
    short               /* IN OPTIONAL  */
                        /* THE MODEL NUMBER WITHIN THE TYPE */
    );

#pragma section processstring_scan_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short PROCESSSTRING_SCAN_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
                          /* [0:9] */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short PROCESSSTRING_SCAN_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif


#pragma section processtime
_tal _extensible long long PROCESSTIME (
    short ,             /* IN OPTIONAL  */
                        /* PROCESS PID */
    short               /* IN OPTIONAL  */
                        /* SYSTEM NUMBER */
    );

#pragma section process_activate_
_tal _extensible short PROCESS_ACTIVATE_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short               /* IN OPTIONAL  */
    );

#pragma section process_create_
#include <tnsint.h>
_tal _extensible short PROCESS_CREATE_ (
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
                        /* RESERVED FOR INTERNAL USE */
    short               /* IN OPTIONAL  */
                        /* RESERVED FOR INTERNAL USE */
    );

#pragma section process_debug_
_tal _extensible short PROCESS_DEBUG_ (
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section process_delay_
#if _TANDEM_ARCH_ == 0  || _TANDEM_ARCH_ > 1 /* for TNS, TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
void PROCESS_DELAY_(
    long long           /* IN */
  );
#ifdef __cplusplus
}
#endif
#endif


#pragma section process_getinfolist_
#include <tnsint.h>
_tal _extensible short PROCESS_GETINFOLIST_ (
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    __int32_t           /* IN OPTIONAL */
    );

#pragma section process_getinfo_
#include <tnsint.h>
_tal _extensible short PROCESS_GETINFO_ (
    short _far *,       /* IN/OUT OPTIONAL  */
                        /* [0:9] */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    long long _far *,   /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
                        /* [0:9] */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t _far * ,  /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL */
    );

#pragma section process_getpairinfo_
#include <tnsint.h>
_tal _extensible short PROCESS_GETPAIRINFO_ (
    short _far *,       /* IN OPTIONAL  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section process_launch_
_tal _extensible short PROCESS_LAUNCH_ (
    void _far *,        /* IN  */
                        /*  ADDRESSES THE PROCESS_LAUNCH_PARMS_ STRUCTURE */
                        /*  THAT CONTAINS THE ATTRIBUTES OF THE PROCESS */
    short _far *,       /* OUT OPTIONAL  */
                        /*  RETURNS ADDITIONAL DETAIL ABOUT SOME CLASSES OF */
                        /*  ERROR */
    void _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
                        /*  ADDRESS, MAXLENGTH AND RETURNED LENGTH OF THE */
                        /*  STRUCTURE CONTAINING THE RESULTS OF THE */
                        /*  OPERATION */
                        /*  STRUCTURE IS SAME AS SYSMSG_PROCCREATE_TEMPLATE_ */
                        /*  (THE PROCESS CREATE COMPLETION MESSAGE) */
    );

#pragma section PROCESS_MONITOR_CPUS_
_tal _callable _resident void PROCESS_MONITOR_CPUS_(
        short  /*on*/
        );

#pragma section PROCESS_MONITOR_NET_
_tal _callable _resident void PROCESS_MONITOR_NET_(
    short  /*on*/
        );

#pragma section PROCESS_MONITOR_NEW_
_tal _callable _resident void PROCESS_MONITOR_NEW_(
        short  /*on*/
        );

#pragma section PROCESS_MONITOR_VCORE_
_tal _callable _resident void PROCESS_MONITOR_VCORE_(
    short  /*on*/
        );


#pragma section process_setinfo_
_tal _extensible short PROCESS_SETINFO_ (
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section process_setstringinfo_
_tal _extensible short PROCESS_SETSTRINGINFO_ (
    short _far *,       /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );

#pragma section process_spawn_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible __int32_t PROCESS_SPAWN_ (
    char _ptr32 *,              /* IN  */
    void _ptr32 *,              /* IN OPTIONAL  */
    char _ptr32 * _ptr32 *,     /* IN OPTIONAL  */
    char _ptr32 * _ptr32 *,     /* IN OPTIONAL  */
    void _ptr32 *,              /* IN OPTIONAL  */
    __int32_t ,                 /* IN OPTIONAL  */
    void _ptr32 *,              /* IN OPTIONAL  */
    void _ptr32 *,              /* IN/OUT OPTIONAL  */
    __int32_t ,                 /* IN OPTIONAL  */
    char _ptr32 *               /* IN OPTIONAL  */
    );
#else
_tal _extensible __int32_t PROCESS_SPAWN_ (
    char _far *,        /* IN  */
    void _far *,        /* IN OPTIONAL  */
    char _far * _far *, /* IN OPTIONAL  */
    char _far * _far *, /* IN OPTIONAL  */
    void _far *,        /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    void _far *,        /* IN OPTIONAL  */
    void _far *,        /* IN/OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    char _far *         /* IN OPTIONAL  */
    );
#endif

#pragma section process_spawn64_
#include <tnsint.h>
#if (_TANDEM_ARCH_ >= 2)
_tal _extensible __int32_t PROCESS_SPAWN64_ (
    char _ptr64 *,          /* IN */
                            /*  program_pathname */
    void _ptr64 *,          /* IN OPTIONAL */
                            /*  fdinfo */
    char _ptr64 * _ptr64 *, /* IN OPTIONAL */
                            /*  argv */
    char _ptr64 * _ptr64 *, /* IN OPTIONAL */
                            /*  envp */
    void _ptr64 *,          /* IN OPTIONAL */
                            /*  inheritance */
    __int32_t ,             /* IN OPTIONAL */
                            /*  inheritance_len */
    void _ptr64 *,          /* IN OPTIONAL */
                            /*  process_extension */
    void _ptr64 *,          /* IN/OUT OPTIONAL  */
                            /*  process_extension_results */
    long long ,             /* IN OPTIONAL */
                            /*  nowait_tag */
    char _ptr64 *           /* IN OPTIONAL */
                            /*  path */
    );
#endif /* _TANDEM_ARCH_ >= 2 */

#pragma section process_stop_
_tal _extensible short PROCESS_STOP_ (
    short _far *,       /* IN OPTIONAL  */
                        /* [0:9] */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN OPTIONAL  */
                        /* [0:5] */
    const char _far *,  /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section process_suspend_
_tal _extensible short PROCESS_SUSPEND_ (
    short _far *,       /* IN  */
                        /* [0:9] */
    short               /* IN OPTIONAL  */
    );

#pragma section programfilename
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status PROGRAMFILENAME (
    short _ptr32 *       /* OUT  */
                         /* FILE NAME */
    );
#else
_tal _cc_status PROGRAMFILENAME (
    short _near *       /* OUT  */
                        /* FILE NAME */
    );
#endif

#pragma section purge
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status PURGE (
    short _ptr32 *       /* IN  */
                         /* FILE NAME */
    );
#else
_tal _cc_status PURGE (
    short _near *       /* IN  */
                        /* FILE NAME */
    );
#endif

#pragma section putpool
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status PUTPOOL (
    short _ptr32 *,       /* IN/OUT  */
    char _ptr32 *         /* IN  */
    );
#else
_tal _cc_status PUTPOOL (
    short _far *,       /* IN/OUT  */
    char _far *         /* IN  */
    );
#endif

#pragma section read
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status READ (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status READ (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif


#pragma section readedit
#include <tnsint.h>
_tal _extensible short READEDIT (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
                        /*   EDIT line number times 1000  */
    char _far *,        /* OUT  */
                        /*   unpacked line image  */
    short ,             /* IN  */
                        /*   max byte length of ToLine  */
    short _far *,       /* OUT  */
                        /*   byte length of ToLine  */
    short ,             /* IN OPTIONAL  */
                        /*   column number for change tag text  */
    short ,             /* IN OPTIONAL  */
                        /*   space fill record area option  */
    short               /* IN OPTIONAL  */
                        /*   retain trailing spaces option  */
    );

#pragma section readeditp
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short READEDITP (
    short ,               /* IN  */
                          /*   open file number  */
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
                          /*   EDIT line number times 1000  */
    char _ptr32 *,        /* OUT  */
                          /*   packed line image  */
    short ,               /* IN  */
                          /*   max byte length of ToLine  */
    short _ptr32 *        /* OUT  */
                          /*   byte length of ToLine  */
    );
#else
_tal _extensible short READEDITP (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
                        /*   EDIT line number times 1000  */
    char _far *,        /* OUT  */
                        /*   packed line image  */
    short ,             /* IN  */
                        /*   max byte length of ToLine  */
    short _far *        /* OUT  */
                        /*   byte length of ToLine  */
    );
#endif

#pragma section readlock
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status READLOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status READLOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif


#pragma section readlockx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status READLOCKX (
    short ,                     /* IN  */
    char _ptr32 *,              /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status READLOCKX (
    short ,                     /* IN  */
    char _far *,                /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section readupdate
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status READUPDATE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status READUPDATE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif


#pragma section readupdatelock
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status READUPDATELOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status READUPDATELOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif

#pragma section readupdatelockx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status READUPDATELOCKX (
    short ,                     /* IN  */
    char _ptr32 *,              /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status READUPDATELOCKX (
    short ,                     /* IN  */
    char _far *,                /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section readupdatex
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status READUPDATEX (
    short ,                     /* IN  */
    char _ptr32 *,              /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status READUPDATEX (
    short ,                 /* IN  */
    char _far *,            /* OUT  */
    unsigned short,         /* IN  */
    unsigned short _far *,  /* OUT OPTIONAL  */
    __int32_t               /* IN OPTIONAL  */
    );
#endif

#pragma section readupdatexl
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
#if (_TANDEM_ARCH_ == 0)
_tal _extensible short READUPDATEXL (
    short,             /* IN */
    char _far *,       /* OUT */
    __int32_t,         /* IN */
    __int32_t _far *,  /* OUT OPTIONAL */
    long long          /* IN OPTIONAL */
        );
#else
 _tal _extensible short READUPDATEXL (
    short,               /* IN */
    char _ptr32 *,       /* OUT */
    __int32_t,           /* IN */
    __int32_t _ptr32 *,  /* OUT OPTIONAL */
    long long            /* IN OPTIONAL */
        );
#endif
#endif

#pragma section readx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status READX (
    short ,                     /* IN  */
    char _ptr32 *,              /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status READX (
    short ,                     /* IN  */
    char _far *,                /* OUT  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section read_file
#include <tnsint.h>
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("READ^FILE") _extensible short READ_FILE (
    short _ptr32 *,     /* IN  */
                        /* FCB OF FILE TO READ FROM */
    short _ptr32 *,     /* OUT  */
                        /* BUFFER TO READ DATA INTO */
    short _ptr32 *,     /* OUT  */
                        /* NUMBER OF BYTES ACTUALLY READ */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN BUFFER THAT ARE PROMPT */
    short ,             /* IN  */
                        /* MAX NUMBER OF BYTES TO USE IN BUFFER */
    short ,             /* IN  */
                        /* WHETHER READ IS WAITED OR NOT */
    short ,             /* IN  */
                        /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t           /* IN  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#elif _TANDEM_ARCH_ > 0   /* any native version */
_tal _alias ("READ^FILE") _extensible short READ_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO READ FROM */
    short _near *,      /* OUT  */
                        /* BUFFER TO READ DATA INTO */
    short _near *,      /* OUT  */
                        /* NUMBER OF BYTES ACTUALLY READ */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN BUFFER THAT ARE PROMPT */
    short ,             /* IN  */
                        /* MAX NUMBER OF BYTES TO USE IN BUFFER */
    short ,             /* IN  */
                        /* WHETHER READ IS WAITED OR NOT */
    short ,             /* IN  */
                        /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t           /* IN  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("READ^FILE") _variable short READ_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO READ FROM */
    short _near *,      /* OUT  */
                        /* BUFFER TO READ DATA INTO */
    short _near *,      /* OUT  */
                        /* NUMBER OF BYTES ACTUALLY READ */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN BUFFER THAT ARE PROMPT */
    short ,             /* IN  */
                        /* MAX NUMBER OF BYTES TO USE IN BUFFER */
    short ,             /* IN  */
                        /* WHETHER READ IS WAITED OR NOT */
    short ,             /* IN  */
                        /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t           /* IN  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section receiveinfo
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status RECEIVEINFO (
    short _ptr32 *,             /* OUT OPTIONAL  */
                                /* CRTPID OF PROCESS WHICH SENT LAST MESSAGE */
    short _ptr32 *,             /* OUT OPTIONAL  */
                                /* MESSAGE NUMBER OF LAST MESSAGE RECEIVED */
    __int32_t _ptr32 *,         /* OUT OPTIONAL  */
                                /* CURRENT SYNC ID */
    short _ptr32 *,             /* OUT OPTIONAL  */
                                /* FILE NUMBER OF LAST MESSAGE RECEIVED */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES EXPECTED IN REPLY TO */
                                /* LAST MESSAGE */
    short _ptr32 *              /* OUT OPTIONAL  */
                                /* MSG WAS: SYSTEM/WRITE/READ/WRITEREAD */
    );
#else
_tal _extensible _cc_status RECEIVEINFO (
    short _near *,              /* OUT OPTIONAL  */
                                /* CRTPID OF PROCESS WHICH SENT LAST MESSAGE */
    short _near *,              /* OUT OPTIONAL  */
                                /* MESSAGE NUMBER OF LAST MESSAGE RECEIVED */
    __int32_t _near *,          /* OUT OPTIONAL  */
                                /* CURRENT SYNC ID */
    short _near *,              /* OUT OPTIONAL  */
                                /* FILE NUMBER OF LAST MESSAGE RECEIVED */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES EXPECTED IN REPLY TO */
                                /* LAST MESSAGE */
    short _near *               /* OUT OPTIONAL  */
                                /* MSG WAS: SYSTEM/WRITE/READ/WRITEREAD */
    );
#endif


#pragma section refparam_boundscheck_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal short REFPARAM_BOUNDSCHECK_ (
    void _ptr32 *,         /* IN */
                           /* VARIABLE OR VECTOR TO BE CHECKED */
    __int32_t,             /* IN */
                           /* LENGTH OF START_ADDR IN BYTES */
    void _ptr32 *,         /* IN */
                           /* ADDRESS OF START OF CALLER'S STACK FRAME */
    short                  /* IN */
                           /* OPTION FLAGS */
    );
#else
_tal short REFPARAM_BOUNDSCHECK_ (
    void _far *,         /* IN */
                         /* VARIABLE OR VECTOR TO BE CHECKED */
    __int32_t,           /* IN */
                         /* LENGTH OF START_ADDR IN BYTES */
    void _far *,         /* IN */
                         /* ADDRESS OF START OF CALLER'S STACK FRAME */
    short                /* IN */
                         /* OPTION FLAGS */
    );
#endif

#pragma section refparam_boundscheck64_
#if (_TANDEM_ARCH_ > 1)
#include <tnsint.h>
#ifdef __cplusplus
extern "C" {
#endif
_callable _resident
short
REFPARAM_BOUNDSCHECK64_(void _ptr64 *  /*start_addr*/,
                        long long      /*area_length*/,
                        void _ptr64 *  /*framestart*/,
                        short          /*flags*/);
#ifdef __cplusplus
 }
#endif
#endif


#pragma section refresh
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short REFRESH (
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* 8 CHARACTER VOLUME NAME (ALL IF OMITTED) */
    short               /* IN OPTIONAL  */
                        /* <> 0 IF DIRTY CACHE SHOULD BE FLUSHED */
    );
#else
_tal _extensible short REFRESH (
    short _near *,      /* IN OPTIONAL  */
                        /* 8 CHARACTER VOLUME NAME (ALL IF OMITTED) */
    short               /* IN OPTIONAL  */
                        /* <> 0 IF DIRTY CACHE SHOULD BE FLUSHED */
    );
#endif

#pragma section remoteprocessorstatus
#include <tnsint.h>
_tal __int32_t REMOTEPROCESSORSTATUS (
    short               /* IN  */
    );

#pragma section remotetosversion
_tal _extensible short REMOTETOSVERSION (
    short               /* IN OPTIONAL  */
    );

#pragma section rename
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status RENAME (
    short ,             /* IN  */
                        /* FILE NUMBER */
#if (_TANDEM_ARCH_ > 1)
short _ptr32 *          /* IN  */
                        /* NEW FILE NAME */
#else
    short _near *       /* IN  */
                        /* NEW FILE NAME */
#endif
    );

#pragma section reply
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status REPLY (
    short _ptr32 *,             /* IN OPTIONAL  */
                                /* DATA BUFFER */
    unsigned short ,            /* IN OPTIONAL  */
                                /* TRANSFER COUNT */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* COUNT TRANSFERRED */
    short ,                     /* IN OPTIONAL  */
                                /* REPLY NUMBER */
    short                       /* IN OPTIONAL  */
                                /* ERROR TO RETURN TO SENDER */
    );
#else
_tal _variable _cc_status REPLY (
    short _near *,              /* IN OPTIONAL  */
                                /* DATA BUFFER */
    unsigned short ,            /* IN OPTIONAL  */
                                /* TRANSFER COUNT */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* COUNT TRANSFERRED */
    short ,                     /* IN OPTIONAL  */
                                /* REPLY NUMBER */
    short                       /* IN OPTIONAL  */
                                /* ERROR TO RETURN TO SENDER */
    );
#endif

#pragma section replyx
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status REPLYX (
    const char _ptr32 *,        /* IN OPTIONAL  */
    unsigned short ,            /* IN OPTIONAL  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    short ,                     /* IN OPTIONAL  */
    short                       /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status REPLYX (
    const char _far *,          /* IN OPTIONAL  */
    unsigned short ,            /* IN OPTIONAL  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    short ,                     /* IN OPTIONAL  */
    short                       /* IN OPTIONAL  */
    );
#endif

#pragma section replyxl
#if (_TANDEM_ARCH_ != 1)
#include <tnsint.h>
#if (_TANDEM_ARCH_ ==0 )
_tal _extensible short REPLYXL (
     const char _far *,  /* IN OPTIONAL  */
     __int32_t,          /* IN OPTIONAL  */
     __int32_t _far *,   /* OUT OPTIONAL  */
     short,              /* IN OPTIONAL  */
     short               /* IN OPTIONAL  */
     );
#else
_tal _extensible short REPLYXL (
     const char _ptr32 *,  /* IN OPTIONAL  */
     __int32_t,            /* IN OPTIONAL  */
     __int32_t _ptr32 *,   /* OUT OPTIONAL  */
     short,                /* IN OPTIONAL  */
     short                 /* IN OPTIONAL  */
     );
#endif
#endif

#pragma section reposition
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status REPOSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
#if (_TANDEM_ARCH_ > 1)
    short _ptr32 *      /* IN  */
                        /* ARRAY FOR POSITION INFORMATION */
#else
    short _near *       /* IN  */
                        /* ARRAY FOR POSITION INFORMATION */
#endif
    );

#pragma section reservelcbs
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status RESERVELCBS (
    short ,             /* IN  */
                        /* # TO RESERVE FOR $RECEIVE */
    short               /* IN  */
                        /* # TO RESERVE FOR SENDING */
    );

#pragma section resetsync
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _cc_status RESETSYNC (
    short               /* IN  */
                        /* FILE NUMBER */
    );

#pragma section resizepool
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short RESIZEPOOL (
    short _ptr32 *,       /* IN/OUT  */
    __int32_t            /* IN  */
    );
#else
_tal _extensible short RESIZEPOOL (
    short _far *,       /* IN/OUT  */
    __int32_t           /* IN  */
    );
#endif

#pragma section resizesegment
#include <tnsint.h>
_tal _extensible short RESIZESEGMENT (
    short ,             /* IN  */
    __int32_t           /* IN  */
    );

#pragma section resumetransaction
#include <tnsint.h>
_tal short RESUMETRANSACTION (
    __int32_t           /* IN  */
                        /* TAG RETURNED FROM BEGINTRANSACTION */
    );

#pragma section saveposition
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status SAVEPOSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _ptr32 *,     /* OUT  */
                        /* ARRAY FOR POSITION INFORMATION */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* SIZE OF SYNCINFO ARRAY */
    );
#else
_tal _variable _cc_status SAVEPOSITION (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _near *,      /* OUT  */
                        /* ARRAY FOR POSITION INFORMATION */
    short _near *       /* OUT OPTIONAL  */
                        /* SIZE OF SYNCINFO ARRAY */
    );
#endif

#pragma section segmentsize
#include <tnsint.h>
_tal __int32_t SEGMENTSIZE (
    short               /* IN  */
    );

#pragma section segment_allocate_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SEGMENT_ALLOCATE_ (
    short ,               /* IN  */
    __int32_t ,           /* IN OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    __int32_t _ptr32 *,   /* IN/OUT OPTIONAL  */
                          /* pointer */
    __int32_t ,           /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short SEGMENT_ALLOCATE_ (
    short ,             /* IN  */
    __int32_t ,         /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
                        /* pointer */
    __int32_t ,         /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section segment_allocate64_
#if (_TANDEM_ARCH_ > 1)
#ifdef __cplusplus
extern "C" {
#endif
_extensible _callable _resident
short
SEGMENT_ALLOCATE64_(short                  /*segment_id*/,
                    long long              /*segment_size*/,
                    const char _ptr64 *    /*filename*/,
                    short                  /*filename_len*/,
                    short _ptr64 *         /*error_detail*/,
                    unsigned short         /*pin*/,
                    short                  /*segtype*/,
                    void _ptr64 * _ptr64 * /*base_address*/,
                    long long              /*max_size*/,
                    short                  /*alloc_options*/);
#ifdef __cplusplus
 }
#endif
#endif


#pragma section segment_allocate_chkpt_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SEGMENT_ALLOCATE_CHKPT_ (
    short ,             /* IN  */
    char _ptr32 *,      /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#else
_tal _extensible short SEGMENT_ALLOCATE_CHKPT_ (
    short ,             /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section segment_deallocate_
#if ( _TANDEM_ARCH_ >= 2 )
#ifdef __cplusplus
#endif
_tal _extensible short SEGMENT_DEALLOCATE_ (
   short ,              /* IN  */
                        /*segment_id*/
   short ,              /* IN OPTIONAL  */
                        /*flags*/
   short _ptr64 *       /* OUT OPTIONAL  */
                        /*error_detail*/
   );
#else /* _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
#endif
_tal _extensible short SEGMENT_DEALLOCATE_ (
   short ,              /* IN  */
                        /*segment_id*/
   short ,              /* IN OPTIONAL  */
                        /*flags*/
   short _far *         /* OUT OPTIONAL  */
                        /*error_detail*/
   );
   #endif /* _TANDEM_ARCH_ < 2 */


#pragma section segment_deallocate_chkpt_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SEGMENT_DEALLOCATE_CHKPT_ (
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SEGMENT_DEALLOCATE_CHKPT_ (
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section segment_getbackupinfo_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SEGMENT_GETBACKUPINFO_ (
    short ,               /* IN  */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t _ptr32 *    /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SEGMENT_GETBACKUPINFO_ (
    short ,             /* IN  */
    __int32_t _far *,   /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t _far *    /* OUT OPTIONAL  */
    );
#endif

#pragma section segment_getinfo64_
#if (_TANDEM_ARCH_ > 1)
#ifdef __cplusplus
extern "C" {
#endif
 _extensible _resident
short
SEGMENT_GETINFO64_(short                        /*id*/,
                   unsigned long long _ptr64 *  /*segmentSize*/,
                   char   _ptr64 *              /*fileName*/,
                   short                        /*fileNameMaxLen*/,
                   short  _ptr64 *              /*fileNameLen*/,
                   short  _ptr64 *              /*errDetail*/,
                   unsigned long long _ptr64 *  /*baseAddress*/,
                   short  _ptr64 *              /*usageFlags*/);
#ifdef __cplusplus
 }
#endif

#endif

#pragma section segment_getinfo_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SEGMENT_GETINFO_ (
    short ,               /* IN  */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* pointer */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SEGMENT_GETINFO_ (
    short ,             /* IN  */
    __int32_t _far *,   /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* pointer */
    short _far *        /* OUT OPTIONAL  */
    );
#endif




#pragma section segment_get_min_align_
#if (_TANDEM_ARCH_ > 1)
#ifdef __cplusplus
extern "C" {
#endif
 _resident
int
SEGMENT_GET_MIN_ALIGN_(unsigned long long /*size*/);
#ifdef __cplusplus
 }
#endif
#endif


#pragma section segment_get_pref_align_
#if (_TANDEM_ARCH_ > 1)
#ifdef __cplusplus
extern "C" {
#endif
_resident
int
SEGMENT_GET_PREF_ALIGN_(unsigned long long /*size*/);
#ifdef __cplusplus
 }
#endif
#endif

#pragma section segment_resize64_
#if (_TANDEM_ARCH_ > 1)
#ifdef __cplusplus
extern "C" {
#endif
 _callable _resident _extensible
short
SEGMENT_RESIZE64_(short       /*segid*/,
                  long long   /*newSize*/);
#ifdef __cplusplus
 }
#endif
#endif


#pragma section segment_use_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
#ifdef __cplusplus
#endif
_tal _extensible short SEGMENT_USE_ (
      short ,                   /* IN  */
                                /* extended data segment id to put in use */
      short _ptr64 * ,          /* OUT OPTIONAL  */
                                /* extended data segment id that was in use */
      __int32_t _ptr64 * ,      /* OUT OPTIONAL  */
                                /* address of start of segment put in use */
      short _ptr64 *            /* OUT OPTIONAL  */
                                /* extra info if error is not zero. */
          );
#else /* _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
#endif
_tal _extensible short SEGMENT_USE_ (
      short ,                   /* IN  */
                                /* extended data segment id to put in use */
      short _far * ,            /* OUT OPTIONAL  */
                                /* extended data segment id that was in use */
      __int32_t _far * ,        /* OUT OPTIONAL  */
                                /* address of start of segment put in use */
      short _far *              /* OUT OPTIONAL  */
                                /* extra info if error is not zero. */
          );
#endif /* _TANDEM_ARCH_ < 2 */


#pragma section sendbreakmessage
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SENDBREAKMESSAGE (
    short _ptr32 *,       /* IN  */
    short _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _extensible short SENDBREAKMESSAGE (
    short _far *,       /* IN  */
    short _far *        /* IN OPTIONAL  */
    );
#endif

#pragma section serverclass_dialog_abort_
#include <tnsint.h>
_tal _extensible short SERVERCLASS_DIALOG_ABORT_ (
    __int32_t           /* IN  */
    );

#pragma section serverclass_dialog_begin_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SERVERCLASS_DIALOG_BEGIN_ (
    __int32_t _ptr32 *,   /* OUT  */
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    const char _ptr32 *,  /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN/OUT  */
    short ,               /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short SERVERCLASS_DIALOG_BEGIN_ (
    __int32_t _far *,   /* OUT  */
    const char _far *,  /* IN  */
    short ,             /* IN  */
    const char _far *,  /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif
 #pragma section serverclass_dialog_begin64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_DIALOG_BEGIN64_ (
     __int32_t _ptr64 *,   /* OUT  */
     const char _ptr64 *,  /* IN  */
     short ,               /* IN  */
     const char _ptr64 *,  /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN/OUT  */
     short ,               /* IN  */
     short ,               /* IN  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
  #endif

#pragma section serverclass_dialog_beginl_

#if (_TANDEM_ARCH_ > 1)
#include <tnsint.h>
_tal _extensible short SERVERCLASS_DIALOG_BEGINL_ (
        __int32_t _ptr32 *,   /* OUT  */
        char _ptr32 *,        /* IN  */
        short ,               /* IN  */
        char _ptr32 *,        /* IN  */
        short ,               /* IN  */
        char _ptr32 *,        /* IN/OUT  */
        char _ptr32 *,        /* OUT OPTIONAL */
        __int32_t ,           /* IN  */
        __int32_t ,           /* IN  */
        __int32_t _ptr32 * ,  /* OUT OPTIONAL  */
        __int32_t ,           /* IN OPTIONAL  */
        short ,               /* IN OPTIONAL  */
        short _ptr32 *,       /* OUT OPTIONAL  */
        long long             /* IN OPTIONAL  */
        );
#endif

#pragma section serverclass_dialog_beginl64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_DIALOG_BEGINL64_ (
     __int32_t _ptr64 *,   /* OUT  */
     const char _ptr64 *,  /* IN  */
     short ,               /* IN  */
     const char _ptr64 *,  /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN / OUT  */
     char _ptr64 *,        /* OUT OPTIONAL */
     __int32_t,            /* IN  */
     __int32_t,            /* IN  */
     __int32_t _ptr64 *,   /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
 #endif


#pragma section serverclass_dialog_end_
#include <tnsint.h>
_tal _extensible short SERVERCLASS_DIALOG_END_ (
    __int32_t           /* IN  */
    );

#pragma section serverclass_dialog_send_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SERVERCLASS_DIALOG_SEND_ (
    __int32_t ,         /* IN  */
    char _ptr32 *,      /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#else
_tal _extensible short SERVERCLASS_DIALOG_SEND_ (
    __int32_t ,         /* IN  */
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
 #endif

#pragma section serverclass_dialog_sendl_
#if (_TANDEM_ARCH_ > 1)
#include <tnsint.h>
_tal _extensible short SERVERCLASS_DIALOG_SENDL_ (
        __int32_t ,           /* IN  */
        char _ptr32 *,        /* IN/OUT  */
        char _ptr32 *,        /* OUT OPTIONAL */
        __int32_t ,           /* IN  */
        __int32_t ,           /* IN  */
        __int32_t _ptr32 *,   /* OUT OPTIONAL  */
        __int32_t ,           /* IN OPTIONAL  */
        short ,               /* IN OPTIONAL  */
        short _ptr32 *,       /* OUT OPTIONAL  */
        long long             /* IN OPTIONAL  */
        );
#endif

 #pragma section serverclass_dialog_send64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_DIALOG_SEND64_ (
     __int32_t ,           /* IN  */
     char _ptr64 *,        /* IN/OUT  */
     short ,               /* IN  */
     short ,               /* IN  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
  #endif


#pragma section serverclass_dialog_sendl64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_DIALOG_SENDL64_ (
     __int32_t ,           /* IN  */
     char _ptr64 *,        /* IN / OUT  */
     char _ptr64 *,        /* OUT OPTIONAL */
     __int32_t ,           /* IN  */
     __int32_t ,           /* IN  */
     __int32_t _ptr64 *,   /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
 #endif


#pragma section serverclass_send_
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SERVERCLASS_SEND_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN/OUT  */
    short ,               /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    __int32_t             /* IN OPTIONAL  */
    );
#else
_tal _extensible short SERVERCLASS_SEND_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN/OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

 #pragma section serverclass_send64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_SEND64_ (
     char _ptr64 *,        /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN/OUT  */
     short ,               /* IN  */
     short ,               /* IN  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
  #endif


#pragma section serverclass_sendl_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1)
_tal _extensible short SERVERCLASS_SENDL_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN/OUT  */
    char _ptr32 *,        /* OUT OPTIONAL */
    __int32_t ,           /* IN  */
    __int32_t ,           /* IN  */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
    __int32_t ,           /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    long long             /* IN OPTIONAL  */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short SERVERCLASS_SENDL_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN/OUT  */
    char _far *,        /* OUT OPTIONAL */
    __int32_t ,         /* IN  */
    __int32_t ,         /* IN  */
    __int32_t _far *,   /* OUT OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    long long           /* IN OPTIONAL  */
    );
#endif


 #pragma section serverclass_sendl64_
 #if (_TANDEM_ARCH_ > 1)
 #include <tnsint.h>
 short _tal _extensible SERVERCLASS_SENDL64_ (
     char _ptr64 *,        /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN  */
     short ,               /* IN  */
     char _ptr64 *,        /* IN / OUT  */
     char _ptr64 *,        /* OUT OPTIONAL */
     __int32_t ,           /* IN  */
     __int32_t ,           /* IN  */
     __int32_t _ptr64 *,   /* OUT OPTIONAL  */
     __int32_t ,           /* IN OPTIONAL  */
     short ,               /* IN OPTIONAL  */
     short _ptr64 *,       /* OUT OPTIONAL  */
     long long             /* IN OPTIONAL  */
     );
 #endif


#pragma section serverclass_send_info_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SERVERCLASS_SEND_INFO_ (
    short _ptr32 *,       /* OUT  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short SERVERCLASS_SEND_INFO_ (
    short _far *,       /* OUT  */
    short _far *        /* OUT  */
    );
#endif


#pragma section serverclass_send_info64_
#if (_TANDEM_ARCH_ > 1)
short _tal _extensible SERVERCLASS_SEND_INFO64_ (
     short _ptr64 *,       /* OUT  */
     short _ptr64 *        /* OUT  */
     );
#endif


#pragma section setlooptimer
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status SETLOOPTIMER (
    short ,             /* IN  */
                        /* NEW TIME */
    short _near *       /* OUT OPTIONAL  */
                        /* CURRENT TIMER OPTIONALLY RETURNED HERE */
    );

#pragma section setmode
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status SETMODE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* NUMBER OF CHARACTERISTIC TO BE CHANGED */
    short ,             /* IN OPTIONAL  */
                        /* FIRST PARAMETER */
    short ,             /* IN OPTIONAL  */
                        /* SECOND PARAMETER */
    short _ptr32 *       /* OUT OPTIONAL  */
                        /* ARRAY FOR RETURNING OLD VALUE */
    );
#else
_tal _variable _cc_status SETMODE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* NUMBER OF CHARACTERISTIC TO BE CHANGED */
    short ,             /* IN OPTIONAL  */
                        /* FIRST PARAMETER */
    short ,             /* IN OPTIONAL  */
                        /* SECOND PARAMETER */
    short _near *       /* OUT OPTIONAL  */
                        /* ARRAY FOR RETURNING OLD VALUE */
    );
#endif

#pragma section setmodenowait
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status SETMODENOWAIT (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* NUMBER OF CHARACTERISTIC TO BE CHANGED */
    short ,             /* IN OPTIONAL  */
                        /* FIRST PARAMETER */
    short ,             /* IN OPTIONAL  */
                        /* SECOND PARAMETER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* ARRAY FOR RETURNING OLD VALUE */
    __int32_t           /* IN OPTIONAL  */
                        /* SPECIFIED TAG FOR NOWAIT REQUESTS */
    );
#else
_tal _variable _cc_status SETMODENOWAIT (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short ,             /* IN  */
                        /* NUMBER OF CHARACTERISTIC TO BE CHANGED */
    short ,             /* IN OPTIONAL  */
                        /* FIRST PARAMETER */
    short ,             /* IN OPTIONAL  */
                        /* SECOND PARAMETER */
    short _near *,      /* OUT OPTIONAL  */
                        /* ARRAY FOR RETURNING OLD VALUE */
    __int32_t           /* IN OPTIONAL  */
                        /* SPECIFIED TAG FOR NOWAIT REQUESTS */
    );
#endif

#pragma section setmyterm
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status SETMYTERM (
    short _ptr32 *       /* IN  */
    );
#else
_tal _cc_status SETMYTERM (
    short _near *       /* IN  */
    );
#endif

#pragma section setparam
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status SETPARAM (
    short ,             /* IN  */
    short ,             /* IN  */
    short _ptr32 *,     /* IN OPTIONAL  */
    short ,             /* IN  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status SETPARAM (
    short ,             /* IN  */
    short ,             /* IN  */
    short _near *,      /* IN OPTIONAL  */
    short ,             /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    __int32_t           /* IN OPTIONAL  */
    );
#endif

#pragma section setstop
_tal short SETSTOP (
    short               /* IN  */
                        /* NEW STOP MODE */
    );

#pragma section setsyncinfo
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status SETSYNCINFO (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _ptr32 *      /* OUT  */
                        /* ARRAY FOR SYNCHRONIZATION INFORMATION */
    );
#else
_tal _cc_status SETSYNCINFO (
    short ,             /* IN  */
                        /* FILE NUMBER */
    short _near *       /* OUT  */
                        /* ARRAY FOR SYNCHRONIZATION INFORMATION */
    );
#endif

#pragma section setsystemclock
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _extensible _cc_status SETSYSTEMCLOCK (
    long long ,         /* IN OPTIONAL */
    short ,             /* IN OPTIONAL */
    short               /* IN OPTIONAL  */
    );


#pragma section set_file
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("SET^FILE") _extensible short SET_FILE (
    short _ptr32 *,     /* IN  */
                        /* FCB SET VALUES IN */
    short ,             /* IN  */
                        /* WHICH SET^FILE OPERATION TO PERFORM */
    short ,             /* IN OPTIONAL  */
                        /* NEW VALUE (IF SCALAR) */
    short _ptr32 * ,    /* OUT OPTIONAL  */
                        /* OLD VALUE (IF SCALAR) */
    short *             /* IN OPTIONAL  */
                        /* NEW VALUE (IF ADDRESS) */
    );
#elif _TANDEM_ARCH_ > 0   /* any native version */
_tal _alias ("SET^FILE") _extensible short SET_FILE (
    short _near *,      /* IN  */
                        /* FCB SET VALUES IN */
    short ,             /* IN  */
                        /* WHICH SET^FILE OPERATION TO PERFORM */
    short ,             /* IN OPTIONAL  */
                        /* NEW VALUE (IF SCALAR) */
    short _near * ,     /* OUT OPTIONAL  */
                        /* OLD VALUE (IF SCALAR) */
    short *             /* IN OPTIONAL  */
                        /* NEW VALUE (IF ADDRESS) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("SET^FILE") _variable short SET_FILE (
    short _near *,      /* IN  */
                        /* FCB SET VALUES IN */
    short ,             /* IN  */
                        /* WHICH SET^FILE OPERATION TO PERFORM */
    short ,             /* IN OPTIONAL  */
                        /* NEW VALUE (IF SCALAR) */
    short _near *       /* OUT OPTIONAL  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section shiftstring
#if (_TANDEM_ARCH_ > 1)
_tal void SHIFTSTRING (
    char _ptr32 *,      /* IN/OUT  */
                        /* String to be shifted */
    short ,             /* IN  */
                        /* Number of BYTES in String */
    short               /* IN  */
                        /* .<15> = 0 -> UPSHIFT, */
    );
#else
_tal void SHIFTSTRING (
    char _near *,       /* IN/OUT  */
                        /* String to be shifted */
    short ,             /* IN  */
                        /* Number of BYTES in String */
    short               /* IN  */
                        /* .<15> = 0 -> UPSHIFT, */
    );
#endif


#pragma section signalprocesstimeout
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status SIGNALPROCESSTIMEOUT (
    __int32_t ,         /* IN  */
                        /* TIMEOUT VALUE IN CENTISECONDS */
    short ,             /* IN OPTIONAL  */
                        /* TLE PARAMETER 1 */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TLE PARAMETER 1 */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* TLE ADDRESS */
    );
#else
_tal _extensible _cc_status SIGNALPROCESSTIMEOUT (
    __int32_t ,         /* IN  */
                        /* TIMEOUT VALUE IN CENTISECONDS */
    short ,             /* IN OPTIONAL  */
                        /* TLE PARAMETER 1 */
    __int32_t ,         /* IN OPTIONAL  */
                        /* TLE PARAMETER 1 */
    short _near *       /* OUT OPTIONAL  */
                        /* TLE ADDRESS */
    );
#endif

#pragma section signaltimeout
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status SIGNALTIMEOUT (
    __int32_t ,         /* IN  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _variable _cc_status SIGNALTIMEOUT (
    __int32_t ,         /* IN  */
    short ,             /* IN OPTIONAL  */
    __int32_t ,         /* IN OPTIONAL  */
    short _near *       /* OUT OPTIONAL  */
    );
#endif

#pragma section sms_getphysvolinfofrompool_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPHYSVOLINFOFROMPOOL_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETPHYSVOLINFOFROMPOOL_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section sms_getphysvolsinpoolend_
_tal _extensible short SMS_GETPHYSVOLSINPOOLEND_ (
    void);

#pragma section sms_getphysvolsinpoolnext_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPHYSVOLSINPOOLNEXT_ (
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETPHYSVOLSINPOOLNEXT_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section sms_getphysvolsinpoolstart_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPHYSVOLSINPOOLSTART_ (
    char _ptr32 *,      /* IN  */
    short ,             /* IN  */
    short               /* IN  */
    );
#else
_tal _extensible short SMS_GETPHYSVOLSINPOOLSTART_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short               /* IN  */
    );
#endif

#pragma section sms_getpoolofvolume_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPOOLOFVOLUME_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short SMS_GETPOOLOFVOLUME_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section sms_getpoolsend_
_tal _extensible short SMS_GETPOOLSEND_ (
    void);

#pragma section sms_getpoolsnext_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPOOLSNEXT_ (
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETPOOLSNEXT_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section sms_getpoolsstart_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETPOOLSSTART_ (
    char _ptr32 *,        /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETPOOLSSTART_ (
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section sms_getstgpoolhdr_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETSTGPOOLHDR_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short SMS_GETSTGPOOLHDR_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section sms_getvirtdisksend_
_tal _extensible short SMS_GETVIRTDISKSEND_ (
    void);

#pragma section sms_getvirtdisksnext_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETVIRTDISKSNEXT_ (
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *,       /* OUT  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETVIRTDISKSNEXT_ (
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section sms_getvirtdisksstart_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETVIRTDISKSSTART_ (
    char _ptr32 *,        /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */
    );
#else
_tal _extensible short SMS_GETVIRTDISKSSTART_ (
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section sms_getvirtualdiskhdr_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_GETVIRTUALDISKHDR_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* OUT  */
    short ,               /* IN  */
    short _ptr32 *        /* OUT  */
    );
#else
_tal _extensible short SMS_GETVIRTUALDISKHDR_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif

#pragma section sms_relocatefile_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SMS_RELOCATEFILE_ (
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN  */
    short ,               /* IN  */
    char _ptr32 *,        /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    char _ptr32 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SMS_RELOCATEFILE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section sortbuildparm
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)    /* TNS/E or later */
_tal _extensible short SORTBUILDPARM (
    short _ptr32 *,        /* IN  */
                           /* SORT CONTROL BLOCK */
    short ,                /* IN OPTIONAL  */
                           /* ALLOWED CPUS */
    short ,                /* IN OPTIONAL  */
                           /* FORBIDDEN CPUS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS AND NOWAIT */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _ptr32 *,        /* IN OPTIONAL  */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    short _ptr32 *         /* IN OPTIONAL  */
                           /* LIST OF SCRATCH VOLUMES */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _extensible short SORTBUILDPARM (
    short _far *,          /* IN  */
                           /* SORT CONTROL BLOCK */
    short ,                /* IN OPTIONAL  */
                           /* ALLOWED CPUS */
    short ,                /* IN OPTIONAL  */
                           /* FORBIDDEN CPUS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS AND NOWAIT */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _far *,          /* IN OPTIONAL  */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    short _far *           /* IN OPTIONAL  */
                           /* LIST OF SCRATCH VOLUMES */
    );
#else                      /* TNS */
_tal _extensible short SORTBUILDPARM (
    short _near *,         /* IN  */
                           /* SORT CONTROL BLOCK */
    short ,                /* IN OPTIONAL  */
                           /* ALLOWED CPUS */
    short ,                /* IN OPTIONAL  */
                           /* FORBIDDEN CPUS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS */
    __int32_t ,            /* IN OPTIONAL  */
                           /* TO BLOCK RECORDS AND NOWAIT */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    __int32_t ,            /* IN OPTIONAL  */
                           /* RESERVED FOR INTERNAL USE */
    short _far *           /* IN OPTIONAL  */
                           /* LIST OF SCRATCH VOLUMES */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sorterror
#if (_TANDEM_ARCH_ > 1)    /* TNS/E or later */
_tal short SORTERROR (
    short _ptr32 *,        /* IN  */
                           /* SORT CONTROL BLOCK */
    short _ptr32 *         /* OUT  */
                           /* BUFFER FOR RETURNED MESSAGE */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal short SORTERROR (
    short _far *,          /* IN  */
                           /* SORT CONTROL BLOCK */
    short _far *           /* OUT  */
                           /* BUFFER FOR RETURNED MESSAGE */
    );
#else                      /* TNS */
_tal short SORTERROR (
    short _near *,         /* IN  */
                           /* SORT CONTROL BLOCK */
    short _near *          /* OUT  */
                           /* BUFFER FOR RETURNED MESSAGE */
    );
#endif                     /*  _TANDEM_ARCH_ check  */


#pragma section sorterrordetail
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)    /* TNS/E or later */
_tal __int32_t SORTERRORDETAIL (
    short _ptr32 *         /* IN  */
                           /* SORT CONTROL BLOCK */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal __int32_t SORTERRORDETAIL (
    short _far *           /* IN  */
                           /* SORT CONTROL BLOCK */
    );
#else                      /* TNS */
_tal __int32_t SORTERRORDETAIL (
    short _near *          /* IN  */
                           /* SORT CONTROL BLOCK */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sorterrorsum
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)    /* TNS/E or later */
_tal _extensible short SORTERRORSUM (
    short _ptr32 *,        /* IN  */
                           /* SORT CONTROL BLOCK */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* BUFFER FOR RETURNED MESSAGE */
    __int32_t _ptr32 *,    /* OUT OPTIONAL  */
                           /* SORT ERROR + GUARDIAN ERROR */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* ERROR RELATED INFO */
    short _ptr32 *,        /* OUT OPTIONAL  */
                           /* SUBSORT NUMBER THAT DETECTED AN ERROR */
    short _ptr32 *         /* OUT OPTIONAL  */
                           /* CPU- PIN OF THIS SUBSORT */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _extensible short SORTERRORSUM (
    short _far *,          /* IN  */
                           /* SORT CONTROL BLOCK */
    short _far *,          /* OUT OPTIONAL  */
                           /* BUFFER FOR RETURNED MESSAGE */
    __int32_t _far *,      /* OUT OPTIONAL  */
                           /* SORT ERROR + GUARDIAN ERROR */
    short _far *,          /* OUT OPTIONAL  */
                           /* ERROR RELATED INFO */
    short _far *,          /* OUT OPTIONAL  */
                           /* SUBSORT NUMBER THAT DETECTED AN ERROR */
    short _far *           /* OUT OPTIONAL  */
                           /* CPU- PIN OF THIS SUBSORT */
    );
#else                      /* TNS */
_tal _extensible short SORTERRORSUM (
    short _near *,         /* IN  */
                           /* SORT CONTROL BLOCK */
    short _near *,         /* OUT OPTIONAL  */
                           /* BUFFER FOR RETURNED MESSAGE */
    __int32_t _near *,     /* OUT OPTIONAL  */
                           /* SORT ERROR + GUARDIAN ERROR */
    short _near *,         /* OUT OPTIONAL  */
                           /* ERROR RELATED INFO */
    short _near *,         /* OUT OPTIONAL  */
                           /* SUBSORT NUMBER THAT DETECTED AN ERROR */
    short _near *          /* OUT OPTIONAL  */
                           /* CPU- PIN OF THIS SUBSORT */
    );
#endif /*  _TANDEM_ARCH_ check  */


#pragma section sortfinish
#if (_TANDEM_ARCH_ > 1)
_tal void SORTFINISH (
    short _ptr32 *       /* IN  */
    );
#else
_tal void SORTFINISH (
    short _near *        /* IN  */
    );
#endif

#pragma section sortmergefinish
#if (_TANDEM_ARCH_ > 1)    /* TNS/E or later */
_tal _variable short SORTMERGEFINISH (
    short _ptr32 *,        /* IN  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _variable short SORTMERGEFINISH (
    short _far *,          /* IN  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    );
#else
_tal _variable short SORTMERGEFINISH (
    short _near *,         /* IN  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sortmergereceive
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)    /*  TNS/E or later  */
_tal _extensible short SORTMERGERECEIVE (
    short _ptr32 *,        /* IN  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short _ptr32 *,        /* OUT  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* OUT OPTIONAL  */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _extensible short SORTMERGERECEIVE (
    short _far *,          /* IN  */
    short _far *,          /* OUT OPTIONAL  */
    short _far *,          /* OUT  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SORTMERGERECEIVE (
    short _near *,         /* IN  */
    short _near *,         /* OUT OPTIONAL  */
    short _near *,         /* OUT  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* OUT OPTIONAL  */
    );

#endif /*  _TANDEM_ARCH_ check  */

#pragma section sortmergesend
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)    /*  TNS/E or later  */
_tal _extensible short SORTMERGESEND (
    short _ptr32 *,        /* IN  */
    short _ptr32 *,        /* IN OPTIONAL  */
    short ,                /* IN  */
    short _ptr32 *,        /* OUT OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* IN OPTIONAL  */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _extensible short SORTMERGESEND (
    short _far *,          /* IN  */
    short _far *,          /* IN OPTIONAL  */
    short ,                /* IN  */
    short _near *,         /* OUT OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* IN OPTIONAL  */
    );
#else
_tal _extensible short SORTMERGESEND (
    short _near *,         /* IN  */
    short _near *,         /* IN OPTIONAL  */
    short ,                /* IN  */
    short _near *,         /* OUT OPTIONAL  */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    __int32_t              /* IN OPTIONAL  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sortmergestart
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)     /*  TNS/E or later  */
_tal _variable short SORTMERGESTART (
    short _ptr32 *,         /* IN  */
    short _ptr32 *,         /* IN  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    __int32_t _ptr32 *,     /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    __int32_t _ptr32 *,     /* OUT OPTIONAL  */
    short (_ptr32 *)(
    ),                      /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    short _ptr32 *,         /* IN OPTIONAL  */
    const char _ptr32 *,    /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short                   /* IN/OUT OPTIONAL  */
                            /* RESERVED */
    );
#elif (_TANDEM_ARCH_ == 1)  /* TNS/R */
_tal _variable short SORTMERGESTART (
    short _far *,           /* IN  */
    short _far *,           /* IN  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    __int32_t _far *,       /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    __int32_t _far *,       /* OUT OPTIONAL  */
    short (*)(
    ),                      /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    short _far *,           /* IN OPTIONAL  */
    const char _far *,      /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short ,                 /* IN OPTIONAL  */
    short                   /* IN/OUT OPTIONAL  */
                            /* RESERVED */
    );
#else
_tal _variable short SORTMERGESTART (
    short _near *,         /* IN  */
    short _near *,         /* IN  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    __int32_t _near *,     /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    __int32_t _near *,     /* OUT OPTIONAL  */
    short (*)(
    ),                     /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    short _near *,         /* IN OPTIONAL  */
    char _near *,          /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short ,                /* IN OPTIONAL  */
    short                  /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sortmergestatistics
#if (_TANDEM_ARCH_ > 1)    /*  TNS/E or later  */
_tal _extensible short SORTMERGESTATISTICS (
    short _ptr32 *,        /* IN  */
    short _ptr32 *,        /* IN/OUT  */
    short _ptr32 *,        /* OUT  */
    short ,                /* IN */
                           /* RETURN STATISTICS USING THE 22-WORD ARRAY */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT  */
                           /* INDICATE WHERE THE SORT TOOK PLACE: */
                           /* UPS/SORTPROG */
    );
#elif (_TANDEM_ARCH_ == 1) /* TNS/R */
_tal _extensible short SORTMERGESTATISTICS (
    short _far *,          /* IN  */
    short _far *,          /* IN/OUT  */
    short _far *,          /* OUT  */
    short ,                /* IN */
                           /* RETURN STATISTICS USING THE 22-WORD ARRAY */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT  */
                           /* INDICATE WHERE THE SORT TOOK PLACE:*/
                           /* UPS/SORTPROG */
    );
#else
_tal _extensible short SORTMERGESTATISTICS (
    short _near *,         /* IN  */
    short _near *,         /* IN/OUT  */
    short _near *,         /* OUT  */
    short ,                /* IN */
                           /* RETURN STATISTICS USING THE 22-WORD ARRAY */
    short ,                /* IN/OUT OPTIONAL  */
                           /* RESERVED */
    short                  /* IN/OUT  */
                           /* INDICATE WHERE THE SORT TOOK PLACE:*/
                           /* UPS/SORTPROG */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section sortreceive
#if (_TANDEM_ARCH_ > 1)
_tal short SORTRECEIVE (
    short _ptr32 *,      /* IN  */
    short _ptr32 *       /* IN  */
    );
#else
_tal short SORTRECEIVE (
    short _near *,      /* IN  */
    short _near *       /* IN  */
    );
#endif

#pragma section sortsend
#if (_TANDEM_ARCH_ > 1)
_tal void SORTSEND (
    short _ptr32 *,      /* IN  */
    short _ptr32 *,      /* IN  */
    short               /* IN  */
    );
#else
_tal void SORTSEND (
    short _near *,      /* IN  */
    short _near *,      /* IN  */
    short               /* IN  */
    );
#endif

#pragma section sortstart
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable void SORTSTART (
    short _ptr32 *,     /* IN  */
    short _ptr32 *,     /* IN  */
                        /* NAME OF SOURCE FILE */
    short _ptr32 *,     /* IN  */
                        /* NAME OF DESTINATION FILE */
    short ,             /* OUT  */
                        /* OPTIONS */
    __int32_t ,         /* IN  */
                        /* MAXIMUM RECORD COUNT */
    short ,             /* IN  */
                        /* MAXIMUM RECORD SIZE */
    short _ptr32 *,     /* OUT  */
                        /* KEY DESCRIPTIONS */
    short (_ptr32 *)(
    ),                  /* OUT  */
                        /* ERROR PROCEDURE */
    short _ptr32 *,     /* OUT  */
                        /* ERROR NUMBER RETURN CELL */
    short ,             /* IN/OUT  */
                        /* CPU NUMBER */
    short ,             /* IN/OUT  */
                        /* MEMORY SIZE */
    short ,             /* IN/OUT  */
                        /* PRIORITY */
    short _ptr32 *      /* IN/OUT  */
                        /* SCRATCH FILE OR VOLUME NAME */
    );
#else
_tal _variable void SORTSTART (
    short _near *,      /* IN  */
    short _near *,      /* IN  */
                        /* NAME OF SOURCE FILE */
    short _near *,      /* IN  */
                        /* NAME OF DESTINATION FILE */
    short ,             /* OUT  */
                        /* OPTIONS */
    __int32_t ,         /* IN  */
                        /* MAXIMUM RECORD COUNT */
    short ,             /* IN  */
                        /* MAXIMUM RECORD SIZE */
    short _near *,      /* OUT  */
                        /* KEY DESCRIPTIONS */
    short (*)(
    ),                  /* OUT  */
                        /* ERROR PROCEDURE */
    short _near *,      /* OUT  */
                        /* ERROR NUMBER RETURN CELL */
    short ,             /* IN/OUT  */
                        /* CPU NUMBER */
    short ,             /* IN/OUT  */
                        /* MEMORY SIZE */
    short ,             /* IN/OUT  */
                        /* PRIORITY */
    short _near *       /* IN/OUT  */
                        /* SCRATCH FILE OR VOLUME NAME */
    );
#endif

#pragma section spi_buffer_formatfinish_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPI_BUFFER_FORMATFINISH_ (
    short _ptr32 *,       /* IN/OUT  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SPI_BUFFER_FORMATFINISH_ (
    short _far *,       /* IN/OUT  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section spi_buffer_formatnext_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPI_BUFFER_FORMATNEXT_ (
    short ,             /* IN  */
    short _ptr32 *,     /* IN/OUT  */
    char _ptr32 *,      /* OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _ptr32 *,     /* OUT  */
    short _ptr32 *,     /* OUT OPTIONAL  */
    short _ptr32 *      /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SPI_BUFFER_FORMATNEXT_ (
    short ,             /* IN  */
    short _far *,       /* IN/OUT  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section spi_buffer_formatstart_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPI_BUFFER_FORMATSTART_ (
    short _ptr32 *,       /* OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _ptr32 *,       /* OUT OPTIONAL  */
    short _ptr32 *        /* OUT OPTIONAL  */
    );
#else
_tal _extensible short SPI_BUFFER_FORMATSTART_ (
    short _far *,       /* OUT  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *        /* OUT OPTIONAL  */
    );
#endif

#pragma section spi_format_close_
_tal void SPI_FORMAT_CLOSE_ (
    void);

#pragma section spoolbatchname
#if (_TANDEM_ARCH_ > 1)
_tal short SPOOLBATCHNAME (
    short ,             /* IN  */
                        /* FILE NUMBER OF THE COLLECTOR */
    short _ptr32 *      /* OUT  */
                        /* NAME OF THE BATCH JOB */
    );
#else
_tal short SPOOLBATCHNAME (
    short ,             /* IN  */
                        /* FILE NUMBER OF THE COLLECTOR */
    short _near *       /* OUT  */
                        /* NAME OF THE BATCH JOB */
    );
#endif

#pragma section spoolcontrol
_tal _extensible short SPOOLCONTROL (
    short _near *,      /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short ,             /* IN  */
                        /* CONTROL OPERATION */
    short ,             /* IN  */
                        /* CONTROL PARAMETER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IN BLKBUF */
    short _far *        /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );

#pragma section spoolcontrolbuf
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPOOLCONTROLBUF (
    short _ptr32 *,     /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short ,             /* IN  */
                        /* CONTROLBUF OPERATION */
    short _ptr32 *,     /* IN  */
                        /* CONTROLBUF BUFFER */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN CONTROL BUFFER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IN BLKBUF */
    short _ptr32 *      /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );
#else
_tal _extensible short SPOOLCONTROLBUF (
    short _near *,      /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short ,             /* IN  */
                        /* CONTROLBUF OPERATION */
    short _near *,      /* IN  */
                        /* CONTROLBUF BUFFER */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN CONTROL BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IN BLKBUF */
    short _far *        /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );
#endif

#pragma section spoolend
_tal _extensible short SPOOLEND (
    short _near *,      /* IN  */
                        /* BLOCKING BUFFER */
    short ,             /* IN OPTIONAL  */
                        /* FLAGS WORD */
    short _far *        /* IN/OUT OPTIONAL  */
                  /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );

#pragma section spoolercommand
#if (_TANDEM_ARCH_ > 1)
_tal _variable short SPOOLERCOMMAND (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* COMMAND PARAMETER BUFFER */
    short ,             /* IN  */
                        /* SUBCOMMAND NUMBER */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* SUBCOMMAND PARAMETER BUFFER */
    );
#else
_tal _variable short SPOOLERCOMMAND (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short _near *,      /* IN OPTIONAL  */
                        /* COMMAND PARAMETER BUFFER */
    short ,             /* IN  */
                        /* SUBCOMMAND NUMBER */
    short _near *       /* IN OPTIONAL  */
                        /* SUBCOMMAND PARAMETER BUFFER */
    );
#endif

#pragma section spoolerequest
#if (_TANDEM_ARCH_ > 1)
_tal short SPOOLEREQUEST (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* JOB NUMBER REQUESTED */
    short _ptr32 *      /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal short SPOOLEREQUEST (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* JOB NUMBER REQUESTED */
    short _near *       /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section spoolerequest2
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPOOLEREQUEST2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* JOB NUMBER REQUESTED */
    short _ptr32 *      /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#else
_tal _extensible short SPOOLEREQUEST2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR */
    short ,             /* IN  */
                        /* JOB NUMBER REQUESTED */
    short _near *       /* OUT  */
                        /* BUFFER FOR SPOOL SUPERVISOR */
    );
#endif

#pragma section spoolerstatus
#if (_TANDEM_ARCH_ > 1)
_tal short SPOOLERSTATUS (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short ,             /* IN  */
                        /* METHOD USED IN SCANNING FOR NEXT ITEM */
                        /* STATUS */
    short _ptr32 *      /* IN/OUT  */
                        /* BUFFER TO RELAY STATUS INFORMATION TO */
                        /* THE SPOOL SUPERVISOR */
    );
#else
_tal short SPOOLERSTATUS (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short ,             /* IN  */
                        /* METHOD USED IN SCANNING FOR NEXT ITEM */
                        /* STATUS */
    short _near *       /* IN/OUT  */
                        /* BUFFER TO RELAY STATUS INFORMATION TO */
                        /* THE SPOOL SUPERVISOR */
    );
#endif

#pragma section spoolerstatus2
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SPOOLERSTATUS2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short ,             /* IN  */
                        /* METHOD USED IN SCANNING FOR NEXT ITEM */
                        /* STATUS */
    short _ptr32 *      /* IN/OUT  */
                        /* BUFFER TO RELAY STATUS INFORMATION TO */
                        /* THE SPOOL SUPERVISOR */
    );
#else
_tal _extensible short SPOOLERSTATUS2 (
    short ,             /* IN  */
                        /* FILE TO SPOOL SUPERVISOR PROCESS */
    short ,             /* IN  */
                        /* COMMAND NUMBER */
    short ,             /* IN  */
                        /* METHOD USED IN SCANNING FOR NEXT ITEM */
                        /* STATUS */
    short _near *       /* IN/OUT  */
                        /* BUFFER TO RELAY STATUS INFORMATION TO */
                        /* THE SPOOL SUPERVISOR */
    );
#endif

#pragma section spooljobnum
#if (_TANDEM_ARCH_ > 1)
_tal short SPOOLJOBNUM (
    short ,             /* IN  */
                        /* FILE NUMBER OF FILE OPEN TO COLLECTOR PROCESS */
    short _ptr32 *      /* OUT  */
                        /* JOB NUMBER RETURN */
    );
#else
_tal short SPOOLJOBNUM (
    short ,             /* IN  */
                        /* FILE NUMBER OF FILE OPEN TO COLLECTOR PROCESS */
    short _near *       /* OUT  */
                        /* JOB NUMBER RETURN */
    );
#endif

#pragma section spoolsetmode
_tal _extensible short SPOOLSETMODE (
    short _near *,      /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short ,             /* IN  */
                        /* SETMODE FUNCTION */
    short ,             /* IN OPTIONAL  */
                        /* FIRST PARAMETER */
    short ,             /* IN OPTIONAL  */
                        /* SECOND PARAMETER */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IN BLKBUF */
    short _far *        /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );


#pragma section spoolstart
#include <tnsint.h>
_tal _extensible short SPOOLSTART (
    short ,             /* IN  */
                        /* FILE TO SPOOL COLLECTOR PROCESS */
    short _near *,      /* OUT OPTIONAL  */
                        /* BLOCKING BUFFER */
    short _near *,      /* IN OPTIONAL  */
                        /* LOCATION FOR SPOOLED DATA */
    short _near *,      /* IN OPTIONAL  */
                        /* FORM NAME */
    short _near *,      /* IN OPTIONAL  */
                        /* REPORT NAME */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF COPIES */
    short ,             /* IN OPTIONAL  */
                        /* PAGE SIZE */
    short ,             /* IN OPTIONAL  */
                        /* FLAGS WORD */
    short ,             /* IN OPTIONAL  */
                        /* OWNER OF JOB */
    __int32_t ,         /* IN OPTIONAL  */
                        /* MAXIMUM LINES */
    __int32_t ,         /* IN OPTIONAL  */
                        /* MAXIMUM PAGES */
    short _near *,      /* IN OPTIONAL  */
                        /* FILE */
    short _near *,      /* IN OPTIONAL  */
                        /* FILE */
    short _far *        /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );

#pragma section spoolwrite
_tal _extensible short SPOOLWRITE (
    short _near *,      /* IN/OUT  */
                        /* BLOCKING BUFFER */
    short _near *,      /* IN  */
                        /* DATA BUFFER */
    short ,             /* IN  */
                        /* NUMBER OF BYTES TO WRITE */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IN BLKBUF */
    short _far *        /* IN/OUT OPTIONAL  */
                        /* BLOCKING BUFFER - EXTENDED MEMORY (ALTERNATIVE) */
    );

#pragma section sqladdr
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal __int32_t SQLADDR (
    char _ptr32 *         /* IN  */
    );
#else
_tal __int32_t SQLADDR (
    char _far *         /* IN  */
    );
#endif

#pragma section sqlcadisplay
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void SQLCADISPLAY (
    short _ptr32 *,     /* IN  */
                        /* SQLCA REF */
                        /* REF TO SQLCA^DEFV0^STRUCT */
    short ,             /* IN/OUT OPTIONAL  */
                        /* STREAM FILE NUMBER */
                        /* DEFAULT HOMETERM */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* REMEMBERS IMMU MSG FNO */
                        /* CALLER SETS TO -1 ON FIRST */
                        /* CALL. AVOIDS REPEONING */
                        /* FILE ON LATER CALLS. */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
                        /* "R" JUST PRINT ROWS */
                        /* "C" JUST PRINT COST */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT CALLER */
                        /* PROGRAM ID AND LINE NUM */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* REF TO  SQLCA^DISPLAY^STRUCT */
                        /* SIO: "Y" =>SIO WRITES */
                        /* OUT^FCB^1: IF NONNULL, */
                        /* DO SIO WRITE TO IT. */
                        /* OUT^FCB^2: IF NONNULL, */
                        /* DO SIO WRITE TO IT. */
    );
#else
_tal _extensible void SQLCADISPLAY (
    short _far *,       /* IN  */
                        /* SQLCA REF */
                        /* REF TO SQLCA^DEFV0^STRUCT */
    short ,             /* IN/OUT OPTIONAL  */
                        /* STREAM FILE NUMBER */
                        /* DEFAULT HOMETERM */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* REMEMBERS IMMU MSG FNO */
                        /* CALLER SETS TO -1 ON FIRST */
                        /* CALL. AVOIDS REPEONING */
                        /* FILE ON LATER CALLS. */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
                        /* "R" JUST PRINT ROWS */
                        /* "C" JUST PRINT COST */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT CALLER */
                        /* PROGRAM ID AND LINE NUM */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _far *,        /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _far *,        /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    short _far *        /* IN OPTIONAL  */
                        /* REF TO  SQLCA^DISPLAY^STRUCT */
                        /* SIO: "Y" =>SIO WRITES */
                        /* OUT^FCB^1: IF NONNULL, */
                        /* DO SIO WRITE TO IT. */
                        /* OUT^FCB^2: IF NONNULL, */
                        /* DO SIO WRITE TO IT. */
    );
#endif

#pragma section sqlcafscode
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SQLCAFSCODE (
    short _ptr32 *,     /* IN  */
                        /* THE SQLCA (REQUIRED) */
                        /* REFERENCE TO SQLCA^STRUCT */
    short               /* IN OPTIONAL  */
                        /* IF SET OR NOT PROVIDED, THEN */
                        /* RETURN THE FIRST FS ERROR SET */
                        /* ELSE RETURN THE LAST FS ERROR */
    );
#else
_tal _extensible short SQLCAFSCODE (
    short _far *,       /* IN  */
                        /* THE SQLCA (REQUIRED) */
                        /* REFERENCE TO SQLCA^STRUCT */
    short               /* IN OPTIONAL  */
                        /* IF SET OR NOT PROVIDED, THEN */
                        /* RETURN THE FIRST FS ERROR SET */
                        /* ELSE RETURN THE LAST FS ERROR */
    );
#endif

#pragma section sqlcagetinfolist
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SQLCAGETINFOLIST (
    short _ptr32 *,     /* IN  */
                        /* THE SQLCA FROM WHICH INFORMATION IS TO BE */
                        /* RETRIEVED. */
    short _ptr32 *,     /* IN  */
                        /* THE ARRAY OF ITEM CODES THAT DESCRIBES THE */
                        /* INFORMATION TO BE RETURNED INTO <RESULT>. */
    short ,             /* IN  */
                        /* THE NUMBER OF ITEMS GIVEN IN <ITEMLIST>. */
    short _ptr32 *,     /* OUT  */
                        /* THE BUFFER IN WHICH THE REQUESTED INFORMATION */
                        /* IS RETURNED.  THE ITEMS ARE RETURNED IN THE */
                        /* ORDER SPECIFIED IN <ITEMLIST>.  EACH ITEM */
                        /* IS ALIGNED ON A WORD BOUNDARY. */
    short ,             /* IN  */
                        /* THE MAXIMUM SIZE, IN BYTES, OF <RESULT>. */
    short ,             /* IN OPTIONAL  */
                        /* THE INDEX OF THE SQLCA ENTRY IN WHICH THE */
                        /* CALLER IS INTERESTED.  IGNORED FOR ITEMS */
                        /* WHICH ARE NOT RELATED TO AN ERROR ENTRY */
                        /* (SUCH AS NUMBER OF ERRORS).  IF THE ITEM IS */
                        /* RELATED TO AN ERROR ENTRY, BUT THE */
                        /* <ERRORINDEX> IS OMITTED, THE FIRST ERROR */
                        /* ENTRY IS ASSUMED. */
    short ,             /* IN OPTIONAL  */
                        /* THE MAXIMUM LENGTH THE CALLER WILL ALLOW FOR */
                        /* PROCEDURE IDS AND FILENAMES.  IF THE NAMES */
                        /* EXCEED THIS LENGTH, THEY WILL BE TRUNCATED */
                        /* (NOT AN ERROR) AND A TRUNCATION WARNING */
                        /* CODE WILL BE RETURNED. */
    short ,             /* IN OPTIONAL  */
                        /* THE MAXIMUM LENGTH THE CALLER WILL ALLOW FOR */
                        /* PARAM INFORMATION.  IF THE PARAM */
                        /* INFORMATION EXCEEDS THIS LENGTH, IT WILL BE */
                        /* TRUNCATED (NOT AN ERROR) AND A TRUNCATION */
                        /* WARNING CODE RETURNED. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* THE TOTAL NUMBER OF BYTES USED IN <RESULT>. */
    short _ptr32 *      /* OUT OPTIONAL  */
                        /* THE INDEX OF THE ITEM IN <ITEMLIST> THAT WAS */
                        /* BEING PROCESSED WHEN THE ERROR OCCURRED. */
                        /* THE INDEX STARTS WITH 0. */
    );
#else
_tal _extensible short SQLCAGETINFOLIST (
    short _far *,       /* IN  */
                        /* THE SQLCA FROM WHICH INFORMATION IS TO BE */
                        /* RETRIEVED. */
    short _far *,       /* IN  */
                        /* THE ARRAY OF ITEM CODES THAT DESCRIBES THE */
                        /* INFORMATION TO BE RETURNED INTO <RESULT>. */
    short ,             /* IN  */
                        /* THE NUMBER OF ITEMS GIVEN IN <ITEMLIST>. */
    short _far *,       /* OUT  */
                        /* THE BUFFER IN WHICH THE REQUESTED INFORMATION */
                        /* IS RETURNED.  THE ITEMS ARE RETURNED IN THE */
                        /* ORDER SPECIFIED IN <ITEMLIST>.  EACH ITEM */
                        /* IS ALIGNED ON A WORD BOUNDARY. */
    short ,             /* IN  */
                        /* THE MAXIMUM SIZE, IN BYTES, OF <RESULT>. */
    short ,             /* IN OPTIONAL  */
                        /* THE INDEX OF THE SQLCA ENTRY IN WHICH THE */
                        /* CALLER IS INTERESTED.  IGNORED FOR ITEMS */
                        /* WHICH ARE NOT RELATED TO AN ERROR ENTRY */
                        /* (SUCH AS NUMBER OF ERRORS).  IF THE ITEM IS */
                        /* RELATED TO AN ERROR ENTRY, BUT THE */
                        /* <ERRORINDEX> IS OMITTED, THE FIRST ERROR */
                        /* ENTRY IS ASSUMED. */
    short ,             /* IN OPTIONAL  */
                        /* THE MAXIMUM LENGTH THE CALLER WILL ALLOW FOR */
                        /* PROCEDURE IDS AND FILENAMES.  IF THE NAMES */
                        /* EXCEED THIS LENGTH, THEY WILL BE TRUNCATED */
                        /* (NOT AN ERROR) AND A TRUNCATION WARNING */
                        /* CODE WILL BE RETURNED. */
    short ,             /* IN OPTIONAL  */
                        /* THE MAXIMUM LENGTH THE CALLER WILL ALLOW FOR */
                        /* PARAM INFORMATION.  IF THE PARAM */
                        /* INFORMATION EXCEEDS THIS LENGTH, IT WILL BE */
                        /* TRUNCATED (NOT AN ERROR) AND A TRUNCATION */
                        /* WARNING CODE RETURNED. */
    short _far *,       /* OUT OPTIONAL  */
                        /* THE TOTAL NUMBER OF BYTES USED IN <RESULT>. */
    short _far *        /* OUT OPTIONAL  */
                        /* THE INDEX OF THE ITEM IN <ITEMLIST> THAT WAS */
                        /* BEING PROCESSED WHEN THE ERROR OCCURRED. */
                        /* THE INDEX STARTS WITH 0. */
    );
#endif

#pragma section sqlcatobuffer
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void SQLCATOBUFFER (
    short _ptr32 *,     /* IN  */
                        /* SQLCA REF */
                        /* REF TO SQLCA^DEFV0^STRUCT */
    char _ptr32 *,      /* IN/OUT  */
                        /* BUFFER TO GET OUTPUT */
    short ,             /* IN  */
                        /* LENGTH OF BUFFER. */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF FIRST DESIRED */
                        /* LINE (COUNTING FROM 1) */
                        /* DEFAULT IS 1. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NUMBER OF LINES IN BUFFER */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* "Y" MEANS BUFFER OVERFLOW */
                        /* "N" ALL RECS FIT IN BUF */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* REMEMBERS IMMU MSG FNO */
                        /* CALLER SETS TO -1 ON FIRST */
                        /* CALL. AVOIDS REPEONING */
                        /* FILE ON LATER CALLS. */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* CALLERS PROGAM LOCATION */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#else
_tal _extensible void SQLCATOBUFFER (
    short _far *,       /* IN  */
                        /* SQLCA REF */
                        /* REF TO SQLCA^DEFV0^STRUCT */
    char _far *,        /* IN/OUT  */
                        /* BUFFER TO GET OUTPUT */
    short ,             /* IN  */
                        /* LENGTH OF BUFFER. */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF FIRST DESIRED */
                        /* LINE (COUNTING FROM 1) */
                        /* DEFAULT IS 1. */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF LINES IN BUFFER */
    short _near *,      /* OUT OPTIONAL  */
                        /* "Y" MEANS BUFFER OVERFLOW */
                        /* "N" ALL RECS FIT IN BUF */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* REMEMBERS IMMU MSG FNO */
                        /* CALLER SETS TO -1 ON FIRST */
                        /* CALL. AVOIDS REPEONING */
                        /* FILE ON LATER CALLS. */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* CALLERS PROGAM LOCATION */
                        /* DEFAULT "Y" */
    short ,             /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _far *,        /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _far *,        /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#endif

#pragma section sqlca_display2_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void SQLCA_DISPLAY2_ (
    short _ptr32 *,     /* IN  */
                        /* SQLCA REF */
                        /* REQUIRED */
    short ,             /* IN/OUT OPTIONAL  */
                        /* STREAM FILE NUMBER */
                        /* DEFAULT HOMETERM */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* FILE NUMBER OF IMMU */
                        /* FILE, SET TO -1 BY CALLER */
                        /* ON FIRST CALL AND SET TO */
                        /* IMMU FILE NUMBER. PASSING */
                        /* THIS IMPROVES PERFORMANCE */
                        /* BY SAVING IMMU OPENS ON */
                        /* LATER CALLS. */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
                        /* "R" JUST PRINT ROWS */
                        /* "C" JUST PRINT COST */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT CALLER */
                        /* PROGRAM ID AND LINE NUM */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#else
_tal _extensible void SQLCA_DISPLAY2_ (
    short _far *,       /* IN  */
                        /* SQLCA REF */
                        /* REQUIRED */
    short ,             /* IN/OUT OPTIONAL  */
                        /* STREAM FILE NUMBER */
                        /* DEFAULT HOMETERM */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* FILE NUMBER OF IMMU */
                        /* FILE, SET TO -1 BY CALLER */
                        /* ON FIRST CALL AND SET TO */
                        /* IMMU FILE NUMBER. PASSING */
                        /* THIS IMPROVES PERFORMANCE */
                        /* BY SAVING IMMU OPENS ON */
                        /* LATER CALLS. */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
                        /* "R" JUST PRINT ROWS */
                        /* "C" JUST PRINT COST */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT CALLER */
                        /* PROGRAM ID AND LINE NUM */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _far *,        /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _far *,        /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#endif

#pragma section sqlca_tobuffer2_
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void SQLCA_TOBUFFER2_ (
    short _ptr32 *,     /* IN  */
                        /* SQLCA REF */
                        /* REQUIRED */
    char _ptr32 *,      /* IN/OUT  */
                        /* BUFFER TO GET OUTPUT */
                        /* REQUIRED. */
    short ,             /* IN  */
                        /* LENGTH OF BUFFER. */
                        /* REQUIRED. */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF FIRST DESIRED */
                        /* LINE (COUNTING FROM 1) */
                        /* DEFAULT IS 1. */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* NUMBER OF LINES IN BUFFER */
                        /* OPTIONAL. */
    char _ptr32 *,      /* OUT OPTIONAL  */
                        /* "Y" MEANS BUFFER OVERFLOW */
                        /* "N" ALL RECS FIT IN BUF */
                        /* OPTIONAL. */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _ptr32 *,     /* IN/OUT OPTIONAL  */
                        /* FILE NUMBER OF IMMU */
                        /* FILE, SET TO -1 BY CALLER */
                        /* ON FIRST CALL AND SET TO */
                        /* IMMU FILE NUMBER. PASSING */
                        /* THIS IMPROVES PERFORMANCE */
                        /* BY SAVING IMMU OPENS ON */
                        /* LATER CALLS. */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* CALLERS PROGAM LOCATION */
                        /* DEFAULT "Y" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#else
_tal _extensible void SQLCA_TOBUFFER2_ (
    short _far *,       /* IN  */
                        /* SQLCA REF */
                        /* REQUIRED */
    char _far *,        /* IN/OUT  */
                        /* BUFFER TO GET OUTPUT */
                        /* REQUIRED. */
    short ,             /* IN  */
                        /* LENGTH OF BUFFER. */
                        /* REQUIRED. */
    short ,             /* IN OPTIONAL  */
                        /* NUMBER OF FIRST DESIRED */
                        /* LINE (COUNTING FROM 1) */
                        /* DEFAULT IS 1. */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF LINES IN BUFFER */
                        /* OPTIONAL. */
    char _far *,        /* OUT OPTIONAL  */
                        /* "Y" MEANS BUFFER OVERFLOW */
                        /* "N" ALL RECS FIT IN BUF */
                        /* OPTIONAL. */
    short ,             /* IN OPTIONAL  */
                        /* WIDTH OF OUTPUT DEVICE */
                        /* DEFAULT 79 */
    short _near *,      /* IN/OUT OPTIONAL  */
                        /* FILE NUMBER OF IMMU */
                        /* FILE, SET TO -1 BY CALLER */
                        /* ON FIRST CALL AND SET TO */
                        /* IMMU FILE NUMBER. PASSING */
                        /* THIS IMPROVES PERFORMANCE */
                        /* BY SAVING IMMU OPENS ON */
                        /* LATER CALLS. */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT ONLY SQLCODE */
                        /* "Y" => PRINT ALL ERRORS */
                        /* "B" => PRINT ALL ERRORS */
                        /* WITHOUT "ERROR #" */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT NO WARNINGS */
                        /* "Y" => PRINT ALL WARNSINGS */
                        /* "B" => PRINT ALL WARNINGS */
                        /* WITHOUT "WARNING #" */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => PRINT NO STATISTICS */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* CALLERS PROGAM LOCATION */
                        /* DEFAULT "Y" */
    char _far *,        /* IN OPTIONAL  */
                        /* "N" => DO NOT PRINT SQL */
                        /* EXECUTOR ERROR LOCATION */
                        /* DEFAULT "N" */
    char _far *,        /* IN OPTIONAL  */
                        /* PREFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short ,             /* IN OPTIONAL  */
                        /* LENGTH OF PREFIX. */
                        /* DEFAULT IS 0 */
    char _far *,        /* IN OPTIONAL  */
                        /* SYFFIX FOR OUTPUT LINES */
                        /* DEFAULT IS NULL */
    short               /* IN OPTIONAL  */
                        /* LENGTH OF SUFFIX. */
                        /* DEFAULT IS 0 */
    );
#endif

#pragma section sqlgetcatalogversion
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SQLGETCATALOGVERSION (
    char _ptr32 *,      /* IN OPTIONAL  */
                        /* name of SQL catalog for */
                        /* which version information is needed */
    short _ptr32 *      /* OUT  */
                        /* value indicating catalog format */
                        /* version. */
    );
#else
_tal _extensible short SQLGETCATALOGVERSION (
    char _far *,        /* IN OPTIONAL  */
                        /* name of SQL catalog for */
                        /* which version information is needed */
    short _far *        /* OUT  */
                        /* value indicating catalog format */
                        /* version. */
    );
#endif

#pragma section sqlgetobjectversion
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SQLGETOBJECTVERSION (
    char _ptr32 *,      /* IN  */
                        /* name of SQL object for which */
                        /* version information is needed */
    short _ptr32 *      /* OUT  */
                        /* value indicating catalog format */
                        /* version. */
    );
#else
_tal _extensible short SQLGETOBJECTVERSION (
    char _far *,        /* IN  */
                        /* name of SQL object for which */
                        /* version information is needed */
    short _far *        /* OUT  */
                        /* value indicating catalog format */
                        /* version. */
    );
#endif

#pragma section sqlgetsystemversion
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SQLGETSYSTEMVERSION (
    short ,             /* IN OPTIONAL  */
                        /* node number of system for */
                        /* which SQL version information is needed. */
    short _ptr32 *      /* OUT  */
                        /* value indicating SQL release version */
    );
#else
_tal _extensible short SQLGETSYSTEMVERSION (
    short ,             /* IN OPTIONAL  */
                        /* node number of system for */
                        /* which SQL version information is needed. */
    short _far *        /* OUT  */
                        /* value indicating SQL release version */
    );
#endif

#pragma section sqlsadisplay
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void SQLSADISPLAY (
    short _ptr32 *,     /* IN  */
                        /* SQLSA ref */
                        /* ref to sqlsa^struct */
                        /* required */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* SQLCA ref */
    short ,             /* IN/OUT OPTIONAL  */
                        /* stream file number */
                        /* default hometerm */
    short _ptr32 *      /* IN OPTIONAL  */
                        /* ref to  sqlca^display^struct */
                        /* sio: "Y" =>SIO rather than */
                        /* guardian write */
                        /* out^fcb^1: if nonnull, */
                        /* do SIO write to it. */
                        /* out^fcb^2: if nonnull, */
                        /* do SIO write to it. */
    );
#else
_tal _extensible void SQLSADISPLAY (
    short _far *,       /* IN  */
                        /* SQLSA ref */
                        /* ref to sqlsa^struct */
                        /* required */
    short _far *,       /* IN OPTIONAL  */
                        /* SQLCA ref */
    short ,             /* IN/OUT OPTIONAL  */
                        /* stream file number */
                        /* default hometerm */
    short _far *        /* IN OPTIONAL  */
                        /* ref to  sqlca^display^struct */
                        /* sio: "Y" =>SIO rather than */
                        /* guardian write */
                        /* out^fcb^1: if nonnull, */
                        /* do SIO write to it. */
                        /* out^fcb^2: if nonnull, */
                        /* do SIO write to it. */
    );
#endif

#pragma section sqlsystem
_tal _extensible short SQLSYSTEM (
    void);

#pragma section ssget
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSGET (
    short _ptr32 *,       /* IN/OUT  */
    short _ptr32 *,       /* IN  */
    char _ptr32 *,        /* IN/OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short SSGET (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section ssgettkn
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSGETTKN (
    short _ptr32 *,       /* IN/OUT  */
    __int32_t ,           /* IN  */
    char _ptr32 *,        /* IN/OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN/OUT OPTIONAL  */
    );
#else
_tal _extensible short SSGETTKN (
    short _far *,       /* IN/OUT  */
    __int32_t ,         /* IN  */
    char _far *,        /* IN/OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN/OUT OPTIONAL  */
    );
#endif

#pragma section ssidtotext
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSIDTOTEXT (
    short _ptr32 *,       /* IN  */
                          /* internal form subsystem ID */
    char _ptr32 *,        /* OUT  */
                          /* string to be filled */
    __int32_t _ptr32 *,   /* OUT OPTIONAL  */
                          /* error status */
    short                 /* IN OPTIONAL  */
                          /* external SSID format type */
    );
#else
_tal _extensible short SSIDTOTEXT (
    short _far *,       /* IN  */
                        /* internal form subsystem ID */
    char _far *,        /* OUT  */
                        /* string to be filled */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* error status */
    short               /* IN OPTIONAL  */
                        /* external SSID format type */
    );
#endif

#pragma section ssinit
_tal _extensible short SSINIT (
    short _far *,       /* IN/OUT  */
    short ,             /* IN  */
    short _far *,       /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );

#pragma section ssmove
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSMOVE (
    short _ptr32 *,       /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _extensible short SSMOVE (
    short _far *,       /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );
#endif

#pragma section ssmovetkn
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSMOVETKN (
    __int32_t ,           /* IN  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT  */
    short ,               /* IN OPTIONAL  */
    short _ptr32 *,       /* IN/OUT OPTIONAL  */
    short _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _extensible short SSMOVETKN (
    __int32_t ,         /* IN  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* IN/OUT OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );
#endif

#pragma section ssnull
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short SSNULL (
    short _ptr32 *,       /* IN  */
    char _ptr32 *,        /* OUT  */
    long long _ptr32 *    /* IN OPTIONAL  */
    );
#else
_tal _extensible short SSNULL (
    short _far *,       /* IN  */
    char _far *,        /* OUT  */
    long long _near *   /* IN OPTIONAL  */
    );
#endif

#pragma section ssput
_tal _extensible short SSPUT (
    short _far *,       /* IN/OUT  */
    short _far *,       /* IN  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );

#pragma section ssputtkn
#include <tnsint.h>
_tal _extensible short SSPUTTKN (
    short _far *,       /* IN/OUT  */
    __int32_t ,         /* IN  */
    const char _far *,  /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *        /* IN OPTIONAL  */
    );

#pragma section statustransaction
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short STATUSTRANSACTION (
    short _ptr64 *,     /* OUT  */
                        /* status of transaction (if FEOK returned) */
    long long           /* IN OPTIONAL  */
                        /* status requested for this transid (optional) */
    );
#else
_tal _extensible short STATUSTRANSACTION (
    short _far *,       /* OUT  */
                        /* status of transaction (if FEOK returned) */
    long long           /* IN OPTIONAL  */
                        /* status requested for this transid (optional) */
    );
#endif


#pragma section stepmom
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status STEPMOM (
    short _ptr32 *       /* IN  */
                         /* CRTPID OF PROCESS */
    );
#else
_tal _cc_status STEPMOM (
    short _near *       /* IN  */
                        /* CRTPID OF PROCESS */
    );
#endif

#pragma section stop
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status STOP (
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* processid to be stopped */
    short ,             /* IN OPTIONAL  */
                        /* if true, abend backup */
    short _ptr32 *,     /* OUT OPTIONAL  */
                        /* returned error value */
    short ,             /* IN OPTIONAL  */
                        /* completion code */
    short ,             /* IN OPTIONAL  */
                        /* termination info */
    short _ptr32 *,     /* IN OPTIONAL  */
                        /* subsystem ID */
    short ,             /* IN OPTIONAL  */
                        /* length of text in bytes */
    const char _ptr32 *  /* IN OPTIONAL  */
                        /* text */
    );
#else
_tal _extensible _cc_status STOP (
    short _near *,      /* IN OPTIONAL  */
                        /* processid to be stopped */
    short ,             /* IN OPTIONAL  */
                        /* if true, abend backup */
    short _near *,      /* OUT OPTIONAL  */
                        /* returned error value */
    short ,             /* IN OPTIONAL  */
                        /* completion code */
    short ,             /* IN OPTIONAL  */
                        /* termination info */
    short _far *,       /* IN OPTIONAL  */
                        /* subsystem ID */
    short ,             /* IN OPTIONAL  */
                        /* length of text in bytes */
    const char _far *   /* IN OPTIONAL  */
                        /* text */
    );
#endif

#pragma section string_upshift_
_tal _extensible short STRING_UPSHIFT_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    char _far *,        /* OUT  */
    short               /* IN  */
    );

#pragma section suspendprocess
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status SUSPENDPROCESS (
    short _ptr32 *       /* IN  */
    );
#else
_tal _cc_status SUSPENDPROCESS (
    short _near *       /* IN  */
    );
#endif

#pragma section systemclock_set_
_tal _extensible _callable short SYSTEMCLOCK_SET_ (
     long long ,         /* IN OPTIONAL JulianGMT */
     short ,             /* IN OPTIONAL MODE */
     short               /* IN OPTIONAL TUID  */
     );

#pragma section systementrypointlabel
_tal short SYSTEMENTRYPOINTLABEL (
    char _near *,       /* IN  */
    short               /* IN  */
    );

#pragma section systementrypoint_risc_
#include <tnsint.h>
_tal __int32_t SYSTEMENTRYPOINT_RISC_ (
    char _far *,        /* IN  */
                        /*  procedure name */
    short               /* IN  */
                        /*  length of procedure name in bytes */
    );

#pragma section take_break
#if (_TANDEM_ARCH_ > 1)
_tal _alias ("TAKE^BREAK") short TAKE_BREAK (
    short _ptr32 *       /* IN  */
                         /* FCB OF FILE TO TAKE BREAK FROM */
    );
#else
_tal _alias ("TAKE^BREAK") short TAKE_BREAK (
    short _near *       /* IN  */
                        /* FCB OF FILE TO TAKE BREAK FROM */
    );
#endif

#pragma section tandemtoexternal
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _variable short TANDEMTOEXTERNAL (
    __int32_t _ptr32 *,  /* IN/OUT OPTIONAL  */
    __int32_t _ptr32 *,  /* IN/OUT OPTIONAL  */
    short ,              /* IN  */
    short _ptr32 *,      /* IN/OUT  */
    short ,              /* IN OPTIONAL  */
    short ,              /* IN  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    char _ptr32 *,       /* IN OPTIONAL  */
    char _ptr32 *        /* IN OPTIONAL  */
    );
#else
_tal _variable short TANDEMTOEXTERNAL (
    __int32_t _near *,  /* IN/OUT OPTIONAL  */
    __int32_t _near *,  /* IN/OUT OPTIONAL  */
    short ,             /* IN  */
    short _near *,      /* IN/OUT  */
    short ,             /* IN OPTIONAL  */
    short ,             /* IN  */
    short _near *,      /* OUT OPTIONAL  */
    char _near *,       /* IN OPTIONAL  */
    char _near *        /* IN OPTIONAL  */
    );
#endif

#pragma section texttossid
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1)
_tal _extensible short TEXTTOSSID (
     char _ptr32 *,      /* IN  */
                         /* string to be scanned */
     short _ptr32 *,     /* OUT  */
                         /* internal form subsystem ID */
     __int32_t _ptr32 *, /* OUT OPTIONAL  */
                         /* error status */
     short               /* IN OPTIONAL  */
                         /* external SSID format type */
    );
#else
_tal _extensible short TEXTTOSSID (
    char _far *,        /* IN  */
                        /* string to be scanned */
    short _far *,       /* OUT  */
                        /* internal form subsystem ID */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* error status */
    short               /* IN OPTIONAL  */
                        /* external SSID format type */
    );
#endif

#pragma section texttotransid
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TEXTTOTRANSID (
    char _ptr64 *,        /* IN  */
    short ,               /* IN  */
    long long _ptr64 *    /* OUT  */
    );
#else
_tal _extensible short TEXTTOTRANSID (
    char _far *,        /* IN  */
    short ,             /* IN  */
    long long _far *    /* OUT  */
    );
#endif


#pragma section time
_tal void TIME (
    short _near *       /* OUT  */
    /* TIME RETURNED HERE IS PREVIOUSLY DESCRIBED FORMAT */
    );

#pragma section timestamp
_tal void TIMESTAMP (
    short _near *       /* OUT  */
    );

#pragma section timer_start_
#if _TANDEM_ARCH_ > 1   /* TNS/E native version */
#ifdef __cplusplus
extern "C" {
#endif
#include <tnsint.h>
__int32_t TIMER_START_ (
    long long,            /* IN */
    long long,            /* IN */
    long long,            /* IN */
    __int32_t _far *      /* OUT */
    );
#ifdef __cplusplus
}
#endif
#endif

#pragma section timer_stop_
#if _TANDEM_ARCH_ > 1   /* TNS/E native version */
#include <tnsint.h>
#ifdef __cplusplus
extern "C" {
#endif
__int32_t TIMER_STOP_ (
    __int32_t             /* IN */
    );
#ifdef __cplusplus
}
#endif
#endif

#pragma section tmf_begintag_from_txhandle_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_BEGINTAG_FROM_TXHANDLE_ (
    short _ptr64 *,       /* IN  */
    __int32_t _ptr64 *    /* OUT  */
    );
#else
_tal _extensible short TMF_BEGINTAG_FROM_TXHANDLE_ (
    short _far *,       /* IN  */
    __int32_t _far *    /* OUT  */
    );
#endif


#pragma section tmf_gettxhandle_
#if ( _TANDEM_ARCH_ >= 2 )
_tal short TMF_GETTXHANDLE_ (
    short _ptr64*        /* OUT  */
    );
#else
_tal short TMF_GETTXHANDLE_ (
    short _far *        /* OUT  */
    );
#endif

#pragma section tmf_get_exttransid_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_GET_EXTTRANSID_ (
 int _ptr64 *,       /* OUT  */
 long long _ptr64 *  /* OUT OPTIONAL  */
 );
 #elif (_TANDEM_ARCH_ != 1)
 _tal _extensible short TMF_GET_EXTTRANSID_ (
  int _far *,       /* OUT  */
  long long _far *  /* OUT OPTIONAL  */
   );
#endif



#pragma section tmf_get_tx_id_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_GET_TX_ID_ (
    short _ptr64 *,       /* IN  */
    long long _ptr64 *    /* OUT  */
    );
#else
_tal _extensible short TMF_GET_TX_ID_ (
    short _far *,       /* IN  */
    long long _far *    /* OUT  */
    );
#endif


#pragma section tmf_join_
_tal _extensible short TMF_JOIN_ (
    long long           /* IN  */
    );
#pragma section tmf_join_ext_
 #if (_TANDEM_ARCH_ >= 2)
_tal _extensible _resident
short TMF_JOIN_EXT_ (
int _ptr64 *          /* IN  */
 );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible _resident
short TMF_JOIN_EXT_ (
int _far *          /* IN  */
);
#endif

#pragma section tmf_resume_
_tal _extensible short TMF_RESUME_ (
    long long           /* IN  */
    );

#pragma section tmf_settxhandle_
#if ( _TANDEM_ARCH_ >= 2 )
_tal short TMF_SETTXHANDLE_ (
    short _ptr64 *        /* IN  */
    );
#else
_tal short TMF_SETTXHANDLE_ (
    short _far *        /* IN  */
    );
#endif


#pragma section tmf_suspend_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_SUSPEND_ (
    long long _ptr64 *    /* OUT  */
    );
#else
_tal _extensible short TMF_SUSPEND_ (
    long long _far *    /* OUT  */
    );
#endif


#pragma section tmf_suspend_ext_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_SUSPEND_EXT_ (
    int _ptr64 *         /* OUT */
    );
#elif (_TANDEM_ARCH_ != 1)
_tal _extensible short TMF_SUSPEND_EXT_ (
    int _far *         /* OUT */
    );
#endif


#pragma section tmf_txbegin_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_TXBEGIN_ (
    __int32_t ,           /* IN  */
    __int32_t _ptr64 *    /* OUT  */
    );
#else
_tal _extensible short TMF_TXBEGIN_ (
    __int32_t ,         /* IN  */
    __int32_t _far *    /* OUT  */
    );
#endif


#pragma section tmf_txhandle_from_begintag_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TMF_TXHANDLE_FROM_BEGINTAG_ (
    __int32_t ,           /* IN  */
    short _ptr64 *        /* OUT  */
    );
#else
_tal _extensible short TMF_TXHANDLE_FROM_BEGINTAG_ (
    __int32_t ,         /* IN  */
    short _far *        /* OUT  */
    );
#endif


#pragma section tmf_version_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal void TMF_VERSION_ (
    __int32_t ,         /* IN  */
                        /*  System Number of the system to interrogate */
    short _ptr64 *,     /* OUT  */
                        /*  Version number of the TMP process */
    short _ptr64 *      /* OUT  */
                        /*  File System Error Code */
    );
#else
_tal void TMF_VERSION_ (
    __int32_t ,         /* IN  */
                        /*  System Number of the system to interrogate */
    short _far  *,      /* OUT  */
                        /*  Version number of the TMP process */
    short _far  *       /* OUT  */
                        /*  File System Error Code */
    );
#endif

#pragma section TMF_VERSION_EXT_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _callable _extensible short TMF_VERSION_EXT_ (
  short _ptr64 *,  /*OUT OPTIONAL */
                   /* VERSION NUMBER OF THE TMF */
  short _ptr64 *,  /* OUT OPTIONAL */
                   /* SUB VERSION NUMBER OF TMF */
  char _ptr64 *,   /* OUT OPTIONAL */
  short,           /* IN REQUIRED IF VERSION_STRING IS REQUESTED */
  char _ptr64 *,   /* OUT OPTIONAL */
  short,           /* IN REQUIRED IF RELEASE_STRING IS REQUESTED */
  char _ptr64 *,   /* OUT OPTIONAL */
  short,           /* IN REQUIRED IF RELEASE_DATE_STRING IS REQUESTED */
  short _ptr64 *,  /* OUT REQUIRED IF VERSION_STRING IS REQUESTED */
  short _ptr64 *,  /* OUT REQUIRED IF RELEASE_STRING IS REQUESTED */
  short _ptr64 *,  /* OUT REQUIRED IF RELEASE_DATE_STRING IS REQUESTED */
  short _ptr64 *   /* OUT  */
  );
#else
_tal _callable _extensible short TMF_VERSION_EXT_ (
  short _far *,   /*OUT OPTIONAL */
                  /* VERSION NUMBER OF THE TMF */
  short _far *,   /* OUT OPTIONAL */
                  /* SUB VERSION NUMBER OF TMF */
  char _far *,    /* OUT OPTIONAL */
  short,          /* IN REQUIRED IF VERSION_STRING IS REQUESTED */
  char _far *,    /* OUT OPTIONAL */
  short,          /* IN REQUIRED IF RELEASE_STRING IS REQUESTED */
  char _far *,    /* OUT OPTIONAL */
  short,          /* IN REQUIRED IF RELEASE_DATE_STRING IS REQUESTED */
  short _far *,   /* OUT OPTIONAL */
  short _far *,   /* OUT REQUIRED IF VERSION_STRING IS REQUESTED */
  short _far *,   /* OUT REQUIRED IF RELEASE_STRING IS REQUESTED */
  short _far *,   /* OUT REQUIRED IF RELEASE_DATE_STRING IS REQUESTED */
  short _far *    /* OUT */
 );
#endif


#pragma section tosversion
_tal short TOSVERSION (
    void);

#pragma section transidtotext
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short TRANSIDTOTEXT (
    long long ,         /* IN  */
    char _ptr64*,       /* OUT  */
    short ,             /* IN  */
    short _ptr64*       /* OUT  */
    );
#else
_tal _extensible short TRANSIDTOTEXT (
    long long ,         /* IN  */
    char _far *,        /* OUT  */
    short ,             /* IN  */
    short _far *        /* OUT  */
    );
#endif


#pragma section ts_nanosecs_
#if _TANDEM_ARCH_ == 0   /* for TNS version */
#ifdef __cplusplus
extern "C" {
#endif
_callable long long TS_NANOSECS_( void );
#ifdef __cplusplus
}
#endif
#elif  _TANDEM_ARCH_ >= 2   /* for TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
_callable unsigned long long TS_NANOSECS_( void );
#ifdef __cplusplus
}
#endif
#endif

#pragma section ts_unique_compare_
#include <tnsint.h>
#if _TANDEM_ARCH_  >= 2 /* for TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
__int32_t TS_UNIQUE_COMPARE_(
    short  _ptr64 *,        /* INPUT */
    short  _ptr64 *         /* INPUT */
);
#ifdef __cplusplus
}
#endif
#else      /*  _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
extern "C" {
#endif
__int32_t TS_UNIQUE_COMPARE_(
    short  _far *,        /* INPUT */
    short  _far *         /* INPUT */
);
#ifdef __cplusplus
}
#endif
#endif

#pragma section ts_unique_convert_to_julian_
#if _TANDEM_ARCH_  >= 2 /* for TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
void TS_UNIQUE_CONVERT_TO_JULIAN_(
    short  _ptr64 *,           /* INPUT */
    long long  _ptr64 *        /* OUTPUT */
);
#ifdef __cplusplus
}
#endif
#else      /*  _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
extern "C" {
#endif
void TS_UNIQUE_CONVERT_TO_JULIAN_(
    short   _far *,            /* INPUT */
    long long  *               /* OUTPUT */
);
#ifdef __cplusplus
}
#endif
#endif

#pragma section ts_unique_create_
#if _TANDEM_ARCH_ >= 2 /* for TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
_callable _resident short TS_UNIQUE_CREATE_(
    short   _ptr64  *       /* OUTPUT */
);
#ifdef __cplusplus
}
#endif
#else   /*_TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
extern "C" {
#endif
_callable _resident short TS_UNIQUE_CREATE_(
    short   _far  *         /* OUTPUT */
);
#ifdef __cplusplus
}
#endif
#endif


#pragma section unlockfile
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status UNLOCKFILE (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );

#pragma section unlockmemory
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal void UNLOCKMEMORY (
    char _ptr32 *,        /* IN  */
    __int32_t             /* IN  */
    );
#else
_tal void UNLOCKMEMORY (
    char _far *,        /* IN  */
    __int32_t           /* IN  */
    );
#endif

#pragma section unlockrec
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable _cc_status UNLOCKREC (
    short ,             /* IN  */
                        /* FILE NUMBER */
    __int32_t           /* IN OPTIONAL  */
                        /* NO-WAIT REQUEST TAG */
    );

#pragma section unpackedit
#if (_TANDEM_ARCH_ > 1)
_tal _extensible void UNPACKEDIT (
    const char _ptr32 *,  /* IN  */
                          /*   packed line image  */
    short ,               /* IN  */
                          /*   byte length of FromLine  */
    char _ptr32 *,        /* OUT  */
                          /*   unpacked line image  */
    short ,               /* IN  */
                          /*   max byte length of ToLine  */
    short _ptr32 *,       /* OUT  */
                          /*   byte length of ToLine  */
    short ,               /* IN OPTIONAL  */
                          /*   space fill record area option  */
    short                 /* IN OPTIONAL  */
                          /*   retain trailing spaces option  */
    );
#else
_tal _extensible void UNPACKEDIT (
    const char _far *,  /* IN  */
                        /*   packed line image  */
    short ,             /* IN  */
                        /*   byte length of FromLine  */
    char _far *,        /* OUT  */
                        /*   unpacked line image  */
    short ,             /* IN  */
                        /*   max byte length of ToLine  */
    short _far *,       /* OUT  */
                        /*   byte length of ToLine  */
    short ,             /* IN OPTIONAL  */
                        /*   space fill record area option  */
    short               /* IN OPTIONAL  */
                        /*   retain trailing spaces option  */
    );
#endif

#pragma section userdefaults
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short USERDEFAULTS (
    char _ptr32 *,        /* IN OPTIONAL  */
                          /* <0:7> = GROUPID  , <8:15> = USERID */
    char _ptr32 *,        /* IN/OUT OPTIONAL  */
                          /* [0:3] = GROUPNAME, [4:7]  = USERNAME */
    char _ptr32 *,        /* OUT OPTIONAL  */
                          /* [0:3] = VOLUME   , [4:7]  = SUBVOLUME */
    char _ptr32 *         /* OUT OPTIONAL  */
                          /* GUARDIAN SECURITY, SAME AS SETMODE #1 */
    );
#else
_tal _extensible short USERDEFAULTS (
    char _far *,        /* IN OPTIONAL  */
                        /* <0:7> = GROUPID  , <8:15> = USERID */
    char _far *,        /* IN/OUT OPTIONAL  */
                        /* [0:3] = GROUPNAME, [4:7]  = USERNAME */
    char _far *,        /* OUT OPTIONAL  */
                        /* [0:3] = VOLUME   , [4:7]  = SUBVOLUME */
    char _far *         /* OUT OPTIONAL  */
                        /* GUARDIAN SECURITY, SAME AS SETMODE #1 */
    );
#endif

#pragma section UserEventFile_Register_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short USEREVENTFILE_REGISTER_ (
    short _ptr64*,        /* OUTPUT */
    short _ptr64*         /* OUTPUT */
   );
#ifdef __cplusplus
}
#endif
#else /* _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short USEREVENTFILE_REGISTER_ (
    short *,              /* OUTPUT */
    short *               /* OUTPUT */
    );
#ifdef __cplusplus
}
#endif
#endif /* _TANDEM_ARCH_ < 2 */


#pragma section UserEvent_Awake_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short  USEREVENT_AWAKE_(
    short _ptr64*,        /* INPUT */
    __uint32_t                /* INPUT */
    );
#ifdef __cplusplus
}
#endif
#else /* _TANDEM_ARCH_ < 2 */
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short  USEREVENT_AWAKE_(
    short *,              /* INPUT */
    __uint32_t            /* INPUT */
    );
#ifdef __cplusplus
}
#endif
#endif /* _TANDEM_ARCH_ < 2 */


#pragma section UserEvent_Get_
#include <tnsint.h>
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable __uint32_t  USEREVENT_GET_(void);
#ifdef __cplusplus
    }
#endif


#pragma section UserEvent_Set_
#include <tnsint.h>
#ifdef __cplusplus
    extern "C" {
#endif
_resident _callable short  USEREVENT_SET_(
    __uint32_t,    /* INPUT */
    short          /* INPUT */
    );
#ifdef __cplusplus
    }
#endif


#pragma section UserEvent_Wait_
#include <tnsint.h>
#ifdef __cplusplus
    extern "C" {
#endif
_resident _callable __uint32_t   USEREVENT_WAIT_(
    __uint32_t,        /* INPUT */
    long long          /* INPUT */
    );
#ifdef __cplusplus
    }
#endif


#pragma section Userevent64_Awake_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short USEREVENT64_AWAKE_(
    short _ptr64 *,       /* INPUT */
    unsigned long long    /* INPUT */
    );
#ifdef __cplusplus
}
#endif
#endif


#pragma section Userevent64_File_Register_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short USEREVENT64_FILE_REGISTER_(
    short _ptr64 *,        /* OUTPUT */
    short _ptr64 *         /* OUTPUT */
    );
#ifdef __cplusplus
}
#endif
#endif


#pragma section Userevent64_Get_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable unsigned long long USEREVENT64_GET_(void);
#ifdef __cplusplus
}
#endif
#endif


#pragma section Userevent64_Set_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable short USEREVENT64_SET_(
    unsigned long long,        /* INPUT */
    short                      /* INPUT */
    );
#ifdef __cplusplus
}
#endif
#endif


#pragma section Userevent64_Wait_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ > 1 )
#ifdef __cplusplus
extern "C" {
#endif
_resident _callable unsigned long long USEREVENT64_WAIT_(
    unsigned long long,        /* INPUT */
    long long                  /* INPUT */
    );
#ifdef __cplusplus
}
#endif
#endif


#pragma section useridtousername
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status USERIDTOUSERNAME (
    short _ptr32 *       /* IN/OUT  */
    );
#else
_tal _cc_status USERIDTOUSERNAME (
    short _near *       /* IN/OUT  */
    );
#endif

#pragma section useriobuffer_allow_
#if (_TANDEM_ARCH_ != 1)
_tal void USERIOBUFFER_ALLOW_ (void);
#endif

#pragma section usernametouserid
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _cc_status USERNAMETOUSERID (
    short _ptr32 *       /* IN/OUT  */
    );
#else
_tal _cc_status USERNAMETOUSERID (
    short _near *       /* IN/OUT  */
    );
#endif

#pragma section user_authenticate_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short USER_AUTHENTICATE_ (
    char _ptr64 *,        /* IN  */
    short ,               /* IN  */
    short ,               /* IN OPTIONAL  */
    long long _ptr64 *,   /* IN/OUT OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    char _ptr64 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    char _ptr64 *,        /* IN OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    char _ptr64 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    char _ptr64 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    char _ptr64 *,        /* OUT OPTIONAL  */
    short ,               /* IN OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    short _ptr64 *,       /* OUT OPTIONAL  */
    long long _ptr64 *,   /* OUT OPTIONAL  */
    long long _ptr64 *,   /* OUT OPTIONAL  */
    char _ptr64 *,        /* IN OPTIONAL  */
    short                 /* IN OPTIONAL  */

    );
#else
_tal _extensible short USER_AUTHENTICATE_ (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short ,             /* IN OPTIONAL  */
    long long _far *,   /* IN/OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    char _far *,        /* OUT OPTIONAL  */
    short ,             /* IN OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    short _far *,       /* OUT OPTIONAL  */
    long long _far *,   /* OUT OPTIONAL  */
    long long _far *,   /* OUT OPTIONAL  */
    char _far *,        /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */

    );
#endif


#pragma section user_getinfo_
#include <tnsint.h>
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short USER_GETINFO_ (
    char _ptr64 *,        /* IN/OUT OPTIONAL  */
                          /* NAME OF USER */
    short ,               /* IN OPTIONAL  */
                          /* MAXIMUM LENGTH OF USER_NAME BUFFER */
    short _ptr64 *,       /* IN/OUT OPTIONAL  */
                          /* LENGTH OF USER NAME */
    int _ptr64 *,         /* IN/OUT OPTIONAL  */
                          /* USER ID NUMBER OF A USER */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* WHETHER OR NOT IT IS AN ALIAS */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* NUMBER OF GROUPS IN THE USER'S LIST */
    int _ptr64 *,         /* OUT OPTIONAL  */
                          /* USER'S LIST OF GROUPS */
                          /* 32 ELEMENT ARRAY */
    int _ptr64 *,         /* OUT OPTIONAL  */
                          /* USER'S PRIMARY GROUP */
    char _ptr64 *,        /* OUT OPTIONAL  */
                          /* THE USER'S DEFAULT VOL AND SUBVOL */
                          /* 16 ELEMENT ARRAY */
    short ,               /* IN OPTIONAL  */
                          /* MAXIMUM LENGTH OF VOL_SUBVOL BUFFER */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* LENGTH OF USER'S VOL AND SUBVOL EXTERNAL */
                          /* FORMAT */
    char _ptr64 *,        /* OUT OPTIONAL  */
                          /* USER'S INITIAL DIRECTORY PATH */
    short ,               /* IN OPTIONAL  */
                          /* MAXIMUM LENGTH OF INITIAL_DIR BUFFER */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* LENGTH OF USER'S INITIAL DIRECTORY */
    char _ptr64 *,        /* OUT OPTIONAL  */
                          /* USER'S INITIAL PROGRAM PATH */
    short ,               /* IN OPTIONAL  */
                          /* MAXIMUM LENGTH OF INITIAL_PROG BUFFER */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* LENGTH OF USER'S INITIAL PROGRAM PATH */
    short _ptr64 *,       /* OUT OPTIONAL  */
                          /* GUARDIAN DEFAULT FILE SECURITY VECTOR */
    char _ptr64 *,        /* OUT OPTIONAL */
                          /* TEXT DESCRIPTION FIELD OF SPECIFIED USER/ALIAS */
    short ,               /* IN OPTIONAL */
                          /* MAXIMUM LENGTH OF TEXT DESCRIPTION FIELD */
    short _ptr64 *,       /* OUT OPTIONAL */
                          /* ACTUAL LENGTH OF TEXT DESCRIPTION FIELD */
    char _ptr64 *,        /* OUT OPTIONAL */
                          /* BINARY DESCRIPTION FIELD OF SPECIFIED */
                          /* USER/ALIAS */
    short ,               /* IN OPTIONAL */
                          /* MAXIMUM LENGTH OF BINARY DESCRIPTION FIELD */
    short _ptr64 *        /* OUT OPTIONAL */
                          /* ACTUAL LENGTH OF BINARY DESCRIPTION FIELD */
    );
 #else
_tal _extensible short USER_GETINFO_ (
    char _far *,        /* IN/OUT OPTIONAL  */
                        /* NAME OF USER */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF USER_NAME BUFFER */
    short _far *,       /* IN/OUT OPTIONAL  */
                        /* LENGTH OF USER NAME */
    __int32_t _far *,   /* IN/OUT OPTIONAL  */
                        /* USER ID NUMBER OF A USER */
    short _far *,       /* OUT OPTIONAL  */
                        /* WHETHER OR NOT IT IS AN ALIAS */
    short _far *,       /* OUT OPTIONAL  */
                        /* NUMBER OF GROUPS IN THE USER'S LIST */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* USER'S LIST OF GROUPS */
                        /* 32 ELEMENT ARRAY */
    __int32_t _far *,   /* OUT OPTIONAL  */
                        /* USER'S PRIMARY GROUP */
    char _far *,        /* OUT OPTIONAL  */
                        /* THE USER'S DEFAULT VOL AND SUBVOL */
                        /* 16 ELEMENT ARRAY */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF VOL_SUBVOL BUFFER */
    short _far *,       /* OUT OPTIONAL  */
                        /* LENGTH OF USER'S VOL AND SUBVOL EXTERNAL FORMAT */
    char _far *,        /* OUT OPTIONAL  */
                        /* USER'S INITIAL DIRECTORY PATH */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF INITIAL_DIR BUFFER */
    short _far *,       /* OUT OPTIONAL  */
                        /* LENGTH OF USER'S INITIAL DIRECTORY */
    char _far *,        /* OUT OPTIONAL  */
                        /* USER'S INITIAL PROGRAM PATH */
    short ,             /* IN OPTIONAL  */
                        /* MAXIMUM LENGTH OF INITIAL_PROG BUFFER */
    short _far *,       /* OUT OPTIONAL  */
                        /* LENGTH OF USER'S INITIAL PROGRAM PATH */
    short _far *,       /* OUT OPTIONAL  */
                        /* GUARDIAN DEFAULT FILE SECURITY VECTOR */
    char _far *,        /* OUT OPTIONAL */
                        /* TEXT DESCRIPTION FIELD OF SPECIFIED USER/ALIAS */
    short ,             /* IN OPTIONAL */
                        /* MAXIMUM LENGTH OF TEXT DESCRIPTION FIELD */
    short _far *,       /* OUT OPTIONAL */
                        /* ACTUAL LENGTH OF TEXT DESCRIPTION FIELD */
    char _far *,        /* OUT OPTIONAL */
                        /* BINARY DESCRIPTION FIELD OF SPECIFIED USER/ALIAS */
    short ,             /* IN OPTIONAL */
                        /* MAXIMUM LENGTH OF BINARY DESCRIPTION FIELD */
    short _far *        /* OUT OPTIONAL */
                        /* ACTUAL LENGTH OF BINARY DESCRIPTION FIELD */
    );
 #endif

#pragma section user_getnext_
#if ( _TANDEM_ARCH_ >= 2 )
_tal _extensible short USER_GETNEXT_ (
    char _ptr64 *,      /* IN/OUT  */
                        /* NAME OF USER */
    short ,             /* IN  */
                        /* MAXIMUM LENGTH OF USER_NAME BUFFER */
    short _ptr64 *,     /* IN/OUT  */
                        /* LENGTH OF USER NAME */
    short _ptr64 *      /* IN/OUT  */
                        /* WHETHER OR NOT USER NAME IS AN ALIAS */
    );
#else
_tal _extensible short USER_GETNEXT_ (
    char _far *,        /* IN/OUT  */
                        /* NAME OF USER */
    short ,             /* IN  */
                        /* MAXIMUM LENGTH OF USER_NAME BUFFER */
    short _far *,       /* IN/OUT  */
                        /* LENGTH OF USER NAME */
    short _far *        /* IN/OUT  */
                        /* WHETHER OR NOT USER NAME IS AN ALIAS */
    );
#endif


#pragma section usesegment
/* This procedure cannot be used from a C program.  The following syntax is
   illegal; it will cause an error if this section is explicitly included. */
#ifndef WHOLE_CEXTDECS_INCLUDED__
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
_tal _variable short & _cc_status USESEGMENT (
    short ,             /* IN OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section verifyuser
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status VERIFYUSER (
    short _ptr32 *,      /* IN  */
    short ,              /* IN OPTIONAL  */
    short _ptr32 *,      /* OUT OPTIONAL  */
    short                /* IN OPTIONAL  */
    );
#else
_tal _variable _cc_status VERIFYUSER (
    short _near *,      /* IN  */
    short ,             /* IN OPTIONAL  */
    short _near *,      /* OUT OPTIONAL  */
    short               /* IN OPTIONAL  */
    );
#endif

#pragma section VRO_SET_
#if _TANDEM_ARCH_ == 0  || _TANDEM_ARCH_ >= 2 /* for TNS, TNS/E or later */
#ifdef __cplusplus
extern "C" {
#endif
void VRO_SET_(void);
#ifdef __cplusplus
}
#endif
#endif

#pragma section wait_file
#include <tnsint.h>
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("WAIT^FILE") _extensible short WAIT_FILE (
    short _ptr32 *,      /* IN  */
                         /* FCB OF FILE TO WAIT ON */
    short _ptr32 *,      /* OUT OPTIONAL  */
                         /* NUMBER OF BYTES IF OPERATION WAS READ */
    __int32_t            /* IN OPTIONAL  */
                         /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#elif _TANDEM_ARCH_ > 0   /* any native version */
_tal _alias ("WAIT^FILE") _extensible short WAIT_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO WAIT ON */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IF OPERATION WAS READ */
    __int32_t           /* IN OPTIONAL  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0 )  /* any native version */
_tal _alias ("WAIT^FILE") _variable short WAIT_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO WAIT ON */
    short _near *,      /* OUT OPTIONAL  */
                        /* NUMBER OF BYTES IF OPERATION WAS READ */
    __int32_t           /* IN OPTIONAL  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section write
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status WRITE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status WRITE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
 #endif

#pragma section writeedit
#include <tnsint.h>
_tal _extensible short WRITEEDIT (
    short ,             /* IN  */
                        /*    open file number  */
    __int32_t ,         /* IN OPTIONAL  */
                        /*    EDIT line number times 1000  */
    char _far *,        /* IN  */
                        /*    unpacked line image  */
    short ,             /* IN  */
                        /*    byte length of FromLine  */
    short ,             /* IN OPTIONAL  */
                        /*    retain trailing spaces option  */
    __int32_t _far *    /* OUT OPTIONAL  */
                        /*   record number of line written  */
    );

#pragma section writeeditp
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 1)
_tal _extensible short WRITEEDITP (
    short ,               /* IN  */
                          /*   open file number  */
    __int32_t ,           /* IN  */
                          /*   EDIT line number times 1000  */
    const char _ptr32 *,  /* IN  */
                          /*   packed line image  */
    short                 /* IN  */
                          /*   byte length of FromLine  */
    );
#else
_tal _extensible short WRITEEDITP (
    short ,             /* IN  */
                        /*   open file number  */
    __int32_t ,         /* IN  */
                        /*   EDIT line number times 1000  */
    const char _far *,  /* IN  */
                        /*   packed line image  */
    short               /* IN  */
                        /*   byte length of FromLine  */
    );
#endif

#pragma section writeread
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status WRITEREAD (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* IN/OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO WRITE */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO READ */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY READ */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status WRITEREAD (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* IN/OUT  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO WRITE */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO READ */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY READ */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif

#pragma section writereadx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status WRITEREADX (
    short ,                     /* IN  */
    char _ptr32 *,              /* IN/OUT  */
    unsigned short,             /* IN  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status WRITEREADX (
    short ,                     /* IN  */
    char _far *,                /* IN/OUT  */
    unsigned short,             /* IN  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section writeupdate
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status WRITEUPDATE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status WRITEUPDATE (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#endif

#pragma section writeupdateunlock
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _variable _cc_status WRITEUPDATEUNLOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _ptr32 *,             /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
#else
_tal _variable _cc_status WRITEUPDATEUNLOCK (
    short ,                     /* IN  */
                                /* FILE NUMBER */
    short _near *,              /* IN  */
                                /* DATA BUFFER */
    unsigned short,             /* IN  */
                                /* NUMBER OF BYTES TO TRANSFER */
    unsigned short _near *,     /* OUT OPTIONAL  */
                                /* NUMBER OF BYTES ACTUALLY TRANSFERRED */
    __int32_t                   /* IN OPTIONAL  */
                                /* NO-WAIT REQUEST TAG */
    );
 #endif

#pragma section writeupdateunlockx
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status WRITEUPDATEUNLOCKX (
    short ,                     /* IN  */
    const char _ptr32 *,        /* IN  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status WRITEUPDATEUNLOCKX (
    short ,                     /* IN  */
    const char _far *,          /* IN  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
 #endif

#pragma section writeupdatex
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status WRITEUPDATEX (
    short ,                     /* IN  */
    const char _ptr32 *,        /* IN  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status WRITEUPDATEX (
    short ,                     /* IN  */
    const char _far *,          /* IN  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section writex
#include <tnsint.h>
#if (_TANDEM_ARCH_ > 0) && !defined(___cc_status_DEFINED)
#define ___cc_status_DEFINED
typedef int _cc_status;
#endif
#if (_TANDEM_ARCH_ > 1)
_tal _extensible _cc_status WRITEX (
    short ,                     /* IN  */
    const char _ptr32 *,        /* IN  */
    unsigned short,             /* IN  */
    unsigned short _ptr32 *,    /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#else
_tal _extensible _cc_status WRITEX (
    short ,                     /* IN  */
    const char _far *,          /* IN  */
    unsigned short,             /* IN  */
    unsigned short _far *,      /* OUT OPTIONAL  */
    __int32_t                   /* IN OPTIONAL  */
    );
#endif

#pragma section write_file
#include <tnsint.h>
#if _TANDEM_ARCH_ > 1   /* any native version */
_tal _alias ("WRITE^FILE") _extensible short WRITE_FILE (
    short _ptr32 *,      /* IN  */
                         /* FCB OF FILE TO WRITE TO */
    short _ptr32 *,      /* IN  */
                         /* BUFFER WITH DATA TO WRITE */
    short ,              /* IN  */
                         /* NUMBER OF BYTES IN BUFFER TO WRITE */
    short ,              /* IN OPTIONAL  */
                         /* REPLY CODE (FOR $RECEIVE ONLY) */
    short ,              /* IN OPTIONAL  */
                         /* FORMS CONTROL TO PERFORM BEFORE WRITE */
    short ,              /* IN OPTIONAL  */
                         /* WHETHER WRITE IS WAITED OR NOT */
    short ,              /* IN OPTIONAL  */
                         /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t            /* IN OPTIONAL  */
                         /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#elif _TANDEM_ARCH_ > 0   /* any native version */
_tal _alias ("WRITE^FILE") _extensible short WRITE_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO WRITE TO */
    short _near *,      /* IN  */
                        /* BUFFER WITH DATA TO WRITE */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN BUFFER TO WRITE */
    short ,             /* IN OPTIONAL  */
                        /* REPLY CODE (FOR $RECEIVE ONLY) */
    short ,             /* IN OPTIONAL  */
                        /* FORMS CONTROL TO PERFORM BEFORE WRITE */
    short ,             /* IN OPTIONAL  */
                        /* WHETHER WRITE IS WAITED OR NOT */
    short ,             /* IN OPTIONAL  */
                        /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t           /* IN OPTIONAL  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */

#if ! (_TANDEM_ARCH_ > 0  ) /* any native version */
_tal _alias ("WRITE^FILE") _variable short WRITE_FILE (
    short _near *,      /* IN  */
                        /* FCB OF FILE TO WRITE TO */
    short _near *,      /* IN  */
                        /* BUFFER WITH DATA TO WRITE */
    short ,             /* IN  */
                        /* NUMBER OF BYTES IN BUFFER TO WRITE */
    short ,             /* IN OPTIONAL  */
                        /* REPLY CODE (FOR $RECEIVE ONLY) */
    short ,             /* IN OPTIONAL  */
                        /* FORMS CONTROL TO PERFORM BEFORE WRITE */
    short ,             /* IN OPTIONAL  */
                        /* WHETHER WRITE IS WAITED OR NOT */
    short ,             /* IN OPTIONAL  */
                        /* WHETHER COMPLETING NOWAIT I/O */
    __int32_t           /* IN OPTIONAL  */
                        /* TIME TO WAIT ON COMPLETE (UNITS .01 SEC) */
    );
#endif /*  _TANDEM_ARCH_ check  */


#pragma section xbndstest
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ XBNDTEST;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal short XBNDSTEST (
    char _far *,        /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    long long           /* IN  */
    );
#endif /*  _TANDEM_ARCH_ check  */

#pragma section xstacktest
#if _TANDEM_ARCH_ > 0   /* any native version */
#  ifndef WHOLE_CEXTDECS_INCLUDED__
   /* Obsolete function */ XSTACKTEST;
   /* cannot be called from TNS/R or TNS/E */
#  endif
#else /*  not a native version  */
_tal short XSTACKTEST (
    short _near *,      /* IN  */
    short ,             /* IN  */
    short ,             /* IN  */
    long long _near *   /* OUT  */
    );
#endif /*  _TANDEM_ARCH_ check  */
